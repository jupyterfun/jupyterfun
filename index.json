[
  {
    "content": "内置函数 all()，Python 官方文档描述如下：\nhelp(all) Help on built-in function all in module builtins:\rall(iterable, /)\rReturn True if bool(x) is True for all values x in the iterable.\rIf the iterable is empty, return True.\r如果可迭代对象（iterable）的所有元素均为真值（或可迭代对象为空）则返回 True 。\nall('0123') # 字符串 '0' 是真值 True\rall([0,1,2,3]) False\rall({}) True\rall({1:[], 2:0 }) True\r",
    "description": "",
    "tags": null,
    "title": "all() 所有元素布尔值为真？",
    "uri": "/python/11_built-in_function/02_all/"
  },
  {
    "content": "字典方法 dict.keys()，Python 官方文档描述如下：\nhelp(dict.keys) Help on method_descriptor:\rkeys(...)\rD.keys() -\u003e a set-like object providing a view on D's keys\r返回一个由字典的键组成的动态视图。字典的视图支持成员检测，可以被迭代。\nd = {'a':1, 'b':2} d.keys() dict_keys(['a', 'b'])\r'a' in d.keys() True\rlist(d.keys()) ['a', 'b']\rd = {'a':1, 'b':2} d_view = d.keys() print(d_view) d['c'] = 3 # 添加元素，视图也动态变化 print(d_view) dict_keys(['a', 'b'])\rdict_keys(['a', 'b', 'c'])\r",
    "description": "",
    "tags": null,
    "title": "dict.keys 键视图",
    "uri": "/python/07_dictionary/02_dict.keys/"
  },
  {
    "content": "python 很重要, 但不需要这么多知识…… 2024. 11. 22\n",
    "description": "",
    "tags": null,
    "title": "Python 语法基础知识详解和查询手册",
    "uri": "/python/"
  },
  {
    "content": "range 对象是一个整数等差数列，用内置函数 range() 构造得到，类型是 range：\ntype(range(3)) range\rrange(-1,5,2) range(-1, 5, 2)\rrange 通常用于在 for 循环中循环指定的次数：\nfor i in range(3): print('重要的事情说三遍') 重要的事情说三遍\r重要的事情说三遍\r重要的事情说三遍\rrange 对象可以指定起始值（默认 0），结束值（不包含），和等差数列的公差（默认 1）。\n指定一个大于 0 的值则默认从 0 开始，公差为 1，到指定值之前一个整数结束：\nlist(range(5)) [0, 1, 2, 3, 4]\r因为公差默认为 1，指定一个小于等于 0 的值则得到空 range：\nlist(range(-5)) []\r起始值，结束值，公差都指定，则得到相应等差数列：\nlist(range(1,5)) [1, 2, 3, 4]\rlist(range(1,-5,-1)) [1, 0, -1, -2, -3, -4]\rrange 类型相比常规 list 或 tuple，优势在于一个 range 对象总是占用固定的（较小）内存，不论其所表示的范围有多大。因为 range 类型只保存了 start, stop 和 step 值，并会根据需要计算具体单项或子范围的值。\n除了拆包可以使用操作符*，range 对象不可以像列表，元组等一样，使用 +，*，+=，*=进行拼接或重复：\n(*range(3),) (0, 1, 2)\r",
    "description": "",
    "tags": null,
    "title": "range 对象",
    "uri": "/python/05_sequence/02_range/"
  },
  {
    "content": "集合方法 set.isdisjoint()，Python 官方文档描述如下：\nhelp(set.isdisjoint) Help on method_descriptor:\risdisjoint(...)\rReturn True if two sets have a null intersection.\r两个集合的交集为空，则返回 True。方法中的参数可以是可迭代对象。\n{1,2}.isdisjoint([1,2]) False\r{1,2}.isdisjoint([3,4]) True\r{1,2}.isdisjoint('12') # 参数是字符串而非数字 True\r",
    "description": "",
    "tags": null,
    "title": "set.isdisjoint 交集为空吗？",
    "uri": "/python/06_set/02_set.isdisjoint/"
  },
  {
    "content": "元组方法 tuple.count()，Python 官方文档描述如下：\nhelp(tuple.count) Help on method_descriptor:\rcount(self, value, /)\rReturn number of occurrences of value.\r返回值为 value 的元素在元组中的出现次数。\n(1,2,1,3).count(1) 2\r(1,2,1,3).count(4) 0\r",
    "description": "",
    "tags": null,
    "title": "tuple.count 统计元素出现次数",
    "uri": "/python/04_tuple/02_tuple.count/"
  },
  {
    "content": "比较运算符有 \u003c，\u003e，\u003c=，\u003e=，==，!=，in，not in，is，is not。\n运算符 \u003c，\u003e，\u003e=，\u003c=，== 和 != 比较两个对象的值，\u003c，\u003e，\u003e= 和 \u003c= 称为次序比较；== 和 != 称为一致性比较。\n由于所有类型都是 object 的（直接或间接）子类型，它们都从 object 继承了默认的比较行为，一致性比较是默认的比较行为，因此可在任何对象之间进行。\nFalse == 0 != 'a' != int != {} True\r对象的值在 Python 中是一个相当抽象的概念：\n对象的值并没有一个规范的访问方法； 对象的值并不要求具有特定的构建方式，例如由其全部数据属性组成等； 比较运算符实现了一个特定的对象的值概念，可以认为正是通过实现对象比较，间接地定义了对象的值。 主要内置类型的比较行为：\n1，数字类型内部可跨类型比较，按数学（算法）规则正确进行比较且不会有精度损失。但复数不支持次序比较。\nTrue == 1 == 1.0 True\r3.14 \u003c 3 False\r0 \u003e= 0j ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-6-df80cad0b1a4\u003e in \u003cmodule\u003e\r----\u003e 1 0 \u003e= 0j\rTypeError: '\u003e=' not supported between instances of 'int' and 'complex'\r2，字符串使用其字符的 Unicode 码位数字值依次进行比较，某个字符比较出大小即停止。如果一个字符串包含另一个，较短的排前面。\nord('a'), ord('b'), ord('c') (97, 98, 99)\r'a' == 'a', 'a' == 'c' (True, False)\r'ab' \u003c 'ac' True\r'abc' \u003e 'ab' True\r3，序列（列表，元组，range 实例）只能进行类型内部比较。跨类型一致性比较结果将是不相等，跨类型次序比较将引发 TypeError。range 不支持次序比较。\n比较时按顺序对相应元素进行逐个比较，某个元素比较出大小即停止。如果一个序列元素包含另一个，较短的排前面。\n(1,2) == [1,2] False\r[1,2] == [1,2] True\r[1,4] \u003e [1,3,7] True\r[1,4] \u003c [1,4,7] True\r(1,2) \u003e= [1,2] ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-22-cb12354bca8e\u003e in \u003cmodule\u003e\r----\u003e 1 (1,2) \u003e= [1,2]\rTypeError: '\u003e=' not supported between instances of 'tuple' and 'list'\r4， 两个字典若要相等，必须当且仅当它们具有相同的 键值对。次序比较将引发 TypeError。\n{1:1} == {True:1.0} True\r{1:1} \u003c= {True:1.0} ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-24-a13e7674e543\u003e in \u003cmodule\u003e\r----\u003e 1 {1:1} \u003c= {True:1.0}\rTypeError: '\u003c=' not supported between instances of 'dict' and 'dict'\r5，集合 (set 或 frozenset 的实例) 可进行类型内部和跨类型的比较。\n它们将比较运算符定义为子集和超集检测，具体详见集合知识点。这类关系没有定义完全排序。相应地，集合不适宜作为依赖于完全排序的函数的参数。\n{1,2} == frozenset([1,2,1]) True\r{3,1} \u003e {1,2} False\rsorted([{3},{1},{2}]) [{3}, {1}, {2}]\r运算符 in 和 not in 用于成员检测。如果 x 是 s 的成员则 x in s 求值为 True，否则为 False。x not in s 返回 x in s 取反后的值。\n所有内置序列和集合类型以及字典都支持此运算，对于字典来说 in 检测其是否有给定的键。\n'a' in 'abc' True\r'abc' in 'abbc' False\r1 in [1,2] True\r[1] in [1,2] False\r'a' in {'a':1} True\r运算符 is 和 is not 用于检测对象的标识号：当且仅当 x 和 y 是同一对象时 x is y 为真。一个对象的标识号可使用 id() 函数来确定。x is not y 会产生相反的逻辑值。\n默认的一致性比较是基于对象的标识号。x is y 就意味着 x == y。\na = 1 b = 1 a is b, a == b (True, True)\ra = (1,3) b = (1,3) a is b, a == b (False, True)\r",
    "description": "",
    "tags": null,
    "title": "比较运算符",
    "uri": "/python/09_operator/02_compare/"
  },
  {
    "content": "异常处理通过 try 语句（详细语法及使用规则见 try 语句）来实现。\n通过 try 语句处理程序已经出现或可能出现异常，使代码能够继续执行，否则异常未被处理，程序终止执行。\n例如下列代码要求用户输入有效的整数：\nwhile True: try: x = int(input(\"Please enter a number: \")) break except ValueError: print(\"Oops! That was no valid number. Try again...\") Please enter a number: 3.14\rOops! That was no valid number. Try again...\rPlease enter a number: 314\rtry 语句的工作原理如下：\n首先执行 try 子句；\n如果没有异常发生，则跳过 except 子句并完成 try 语句的执行；\n如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分。然后，如果异常的类型和 except 关键字后面的异常匹配，则执行 except 子句，然后继续执行 try 语句之后的代码；\n如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个未处理异常，执行将停止并显示异常信息。\n一个 try 语句可能有多个 except 子句，以指定不同异常的处理程序，但最多会执行一个处理程序。\n处理程序只处理相应的 try 子句中发生的异常。如果发生的异常和 except 子句中的类是同一个类或者是它的基类，则异常和 except 子句中的类是兼容的。如果首先处理了基类，子类不再被处理（子类也被基类处理了）：\nclass B(Exception): pass class C(B): pass class D(C): pass for cls in [B, C, D]: try: raise cls() except D: print(\"D\") except C: print(\"C\") except B: print(\"B\") B\rC\rD\rclass B(Exception): pass class C(B): pass class D(C): pass for cls in [B, C, D]: try: raise cls() except B: # 下列都是 B 的子类，不再被处理 print(\"B\") except C: print(\"C\") except D: print(\"D\") B\rB\rB\r最后的 except 子句可以省略异常名，以用作通配符。但请谨慎使用，因为以这种方式很容易掩盖真正的编程错误！它还可用于打印错误消息，然后重新引发异常:\nimport sys try: 3/0 except ValueError as v: print(v) except: print(\"Unexpected error:\", sys.exc_info()[0]) raise Unexpected error: \u003cclass 'ZeroDivisionError'\u003e\r---------------------------------------------------------------------------\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-13-f0b3e840c5ab\u003e in \u003cmodule\u003e\r2 3 try:\r----\u003e 4 3/0\r5 except ValueError as v:\r6 print(v)\rZeroDivisionError: division by zero\r可选的 else 子句，在使用时必须放在所有的 except 子句后面。对于在 try 子句不引发异常时必须执行的代码来说很有用：\ntry: f = open('../11_built-in_function/test.txt', 'r',encoding='utf-8') except OSError: print('cannot open') else: print(len(f.readlines()), 'lines') f.close() 3 lines\r异常处理程序不仅处理 try 子句中遇到的异常，还处理 try 子句中调用（即使是间接地）的函数内部发生的异常。\n如果 try 子句中有多个可能的异常，只处理最先引发的：\ndef f(): return 3/0 try: f() * int('a') except ValueError as v: print(v) except ZeroDivisionError as z: print(z) division by zero\r",
    "description": "",
    "tags": null,
    "title": "处理异常",
    "uri": "/python/13_exception/02_handling/"
  },
  {
    "content": "创建一个模块非常简单，有两种方式：\n创建一个 .py 文件，即可创建一个模块；\n创建一个文件夹，则该文件夹也是一个模块（包）。\n模块中可以无任何内容。但模块是用来组织代码，实现处理各类问题或完成各种功能的，这更便于应用或开发。例如正则模块 re，科学计算库 pandas 等。\n创建一个文件夹，如果文件夹中包含一个 __init__.py 模块，则该文件夹是一个常规包；否则是一个命名空间包。包中还可以再创建子包或子模块。\n__init__.py 文件中可以无任何内容，但因为当一个常规包被导入时，这个 __init__.py 文件会隐式地被执行，所以通常用来写入一些导入包即可执行的代码，或导入子包，或导入子包中模块的属性等，从而可以直接调用某些属性，例如 pandas 包的文档描述属性 __doc__ 和 DataFrame 数据结构。\nimport folder # 创建的空文件夹 folder \u003cmodule 'folder' (namespace)\u003e\rimport pandas as pd print(pd.__doc__) pandas - a powerful data analysis and manipulation library for Python\r=====================================================================\r**pandas** is a Python package providing fast, flexible, and expressive data\rstructures designed to make working with \"relational\" or \"labeled\" data both\reasy and intuitive. It aims to be the fundamental high-level building block for\rdoing practical, **real world** data analysis in Python. Additionally, it has\rthe broader goal of becoming **the most powerful and flexible open source data\ranalysis / manipulation tool available in any language**. It is already well on\rits way toward this goal.\rMain Features\r-------------\rHere are just a few of the things that pandas does well:\r- Easy handling of missing data in floating point as well as non-floating\rpoint data.\r- Size mutability: columns can be inserted and deleted from DataFrame and\rhigher dimensional objects\r- Automatic and explicit data alignment: objects can be explicitly aligned\rto a set of labels, or the user can simply ignore the labels and let\r`Series`, `DataFrame`, etc. automatically align the data for you in\rcomputations.\r- Powerful, flexible group by functionality to perform split-apply-combine\roperations on data sets, for both aggregating and transforming data.\r- Make it easy to convert ragged, differently-indexed data in other Python\rand NumPy data structures into DataFrame objects.\r- Intelligent label-based slicing, fancy indexing, and subsetting of large\rdata sets.\r- Intuitive merging and joining data sets.\r- Flexible reshaping and pivoting of data sets.\r- Hierarchical labeling of axes (possible to have multiple labels per tick).\r- Robust IO tools for loading data from flat files (CSV and delimited),\rExcel files, databases, and saving/loading data from the ultrafast HDF5\rformat.\r- Time series-specific functionality: date range generation and frequency\rconversion, moving window statistics, date shifting and lagging.\r# 直接调用子包 core 中模块 frame 的属性 DataFrame pd.DataFrame pandas.core.frame.DataFrame\r",
    "description": "",
    "tags": null,
    "title": "创建模块",
    "uri": "/python/15_module/02_create_module/"
  },
  {
    "content": "打开方式不同，会创建不同类型的文件对象（流），不同类型的文件对象，可能有不同的属性或方法。\n下列检查或读取内容的属性或方法，是多数文件对象通用的：\nreadable() 如果可以读取流，则返回 True 。否则为 False ，且 read() 将引发 OSError 错误。 f = open('test.txt') f.readable() True\rread(size=-1) 从对象中读取 size 个字节并将其返回。作为一个便捷选项，如果 size 未指定或为 -1，则返回所有字节直到 EOF。流的位置与读取内容同步，不重设流的位置，内容只能被读取一次。\ntell() 返回当前流的位置。\nf = open('test.txt',encoding='utf-8') f.read() '为什么一定要掌握自学能力？\\n未来的日子还很长，\\n这世界进步得太快，\\n没有自学能力，\\n没有未来。'\rf = open('test.txt',encoding='utf-8') f.read(12) '为什么一定要掌握自学能力'\rf.tell() 36\rf.read() # 再次读取，将读取剩下未读部分 '？\\n未来的日子还很长，\\n这世界进步得太快，\\n没有自学能力，\\n没有未来。'\rf.read() # 已经没有内容 ''\rseek(offset, whence=0) 将流位置修改到给定的字节 offset。返回新的绝对位置。 f.seek(0, 0) 0\rf.read() # 从新位置读取 '为什么一定要掌握自学能力？\\n未来的日子还很长，\\n这世界进步得太快，\\n没有自学能力，\\n没有未来。'\rreadline(size=-1) 从流中读取并返回一行。如果指定了 size，将至多读取 size 个字节。 f = open('test.txt',encoding='utf-8') f.readline() '为什么一定要掌握自学能力？\\n'\rf.readline(2) # 再次读取，将读取剩下未读部分 '未来'\rreadlines(hint=-1) 从流中读取并返回包含多行的列表。可以指定 hint 来控制要读取的行数。指定行数可以多于实际。 f = open('test.txt',encoding='utf-8') f.readlines(1) ['为什么一定要掌握自学能力？\\n']\rf.readlines(10) # 再次读取，将读取剩下未读部分 ['未来的日子还很长，\\n', '这世界进步得太快，\\n']\r使用 for line in file: ... 就足够对文件对象进行迭代了，可以不必调用 file.readlines()。 f = open('test.txt',encoding='utf-8') for line in f: print(line) 为什么一定要掌握自学能力？\r未来的日子还很长，\r这世界进步得太快，\r没有自学能力，\r没有未来。\rclosed 如果流已关闭，则返回 True。 f.closed False\rclose() 刷新并关闭此流。无论读写操作，最后都应该关闭流。如果文件已经关闭，则此方法无效。文件关闭后，对文件的任何操作（例如读取或写入）都会引发 ValueError 。为方便起见，允许多次调用此方法。但是，只有第一个调用才会生效。 f.close() f.close() f.closed True\r",
    "description": "",
    "tags": null,
    "title": "读取文件内容",
    "uri": "/python/14_file/02_read/"
  },
  {
    "content": "赋值语句用于将名称绑定或重新绑定到特定值，以及修改属性或可变对象的成员项。\n赋值语句使用赋值操作符和增强赋值操作符。详见 操作符概述。\n# 将值 1 绑定到变量 a a = 1 print('a =', a) # 变量 a 重新绑定值 'a' a = 'a' print('a =', a) a = 1\ra = a\r同时进行多个值多个名称绑定，值和名称数量要相等：\n# 一个名称时，右边为元组 a = 1,2,3,4 a (1, 2, 3, 4)\r# 多个名称 a,b,c,d = 1,[2,3],4,5 f'a={a},b={b},c={c},d={d}' 'a=1,b=[2, 3],c=4,d=5'\r# 可迭代对象拆包，则需要更多名称 a,b,c,d,e = 1,*[2,3],4,5 f'a={a},b={b},c={c},d={d},e={e}' 'a=1,b=2,c=3,d=4,e=5'\r赋值一般左右两边一一对应 “同时” 赋值，但赋值给变量的多项集时可能不一样（例如列表的某一项）：\nx = [0,1] i = 0 i, x[i] = 1, 2 f'x={x},i={i}' 'x=[0, 2],i=1'\r修改属性或可变对象的成员项：\n# 新增属性 class A: x = 1 a = A() # 右边的 a.x 是访问类属性 # 左边的 a.x 是新增实例属性, 值为类属性值 + 1 a.x = a.x + 1 a.x, A.x (2, 1)\r# 修改列表项 a = [1,2,3] a[0] = [0,1] a [[0, 1], 2, 3]\r# 修改或新增字典项 d = {'a':1} d['a'] = 10 d['b'] = 2 d {'a': 10, 'b': 2}\r赋值操作符 =，可以进行连续赋值，绑定多个名称，但赋值语句非表达式语句，不能被求值，因此不能被括号包围或分隔：\na = b = c = 1 a,b,c (1, 1, 1)\ra = (b = c = 1) File \"\u003cipython-input-40-5dae496e91ce\u003e\", line 1\ra = (b = c = 1)\r^\rSyntaxError: invalid syntax\r不可变容器的增强赋值操作，是重新绑定对象；可变容器的增强赋值操作是增、删、改成员项：\ns = '123' print(id(s),s) # 因为不可变，相当于新建了一个字符串 '1234' 重新绑定 s s += '4' print(id(s),s) 2371959191728 123\r2371959179632 1234\rl = [1,2,3] print(id(l),l) # 可变，相当于在原列表 l 中增加元素 4 l += [4] print(id(l),l) 2371958877312 [1, 2, 3]\r2371958877312 [1, 2, 3, 4]\rl = [1,2,3] print(id(l),l) l *= 0 # 清空列表 print(id(l),l) 2371958290048 [1, 2, 3]\r2371958290048 []\rs = {1,2,3} print(id(s),s) s |= {0} print(id(s),s) 2371958464800 {1, 2, 3}\r2371958464800 {0, 1, 2, 3}\r带标注的赋值语句。单个语句中将变量或属性标注和可选的赋值语句合为一体。标注对提高代码的可读性非常有用，看标注而不需要看代码上下文就大概知道代码的使用。\n# 标注函数参数的类型及默认值 def f(n:int=1): print('Hi'*n) f(2) HiHi\rname: str = '小张' name '小张'\r",
    "description": "",
    "tags": null,
    "title": "赋值语句",
    "uri": "/python/10_statement/02_assignment/"
  },
  {
    "content": "函数定义有两种方式，def 语句定义有名字的函数（详见 def 定义函数），lambda 表达式定义匿名函数（详见 lambda 函数）。\n定义一个函数，即是创建了一个函数可执行代码的包装器，他将函数想要实现的功能包装起来。然后通过调用它来实现其功能。def 语句 详细介绍了定义函数的语法规则，下面看看如何将一个功能包装起来。\n例如下列函数，实现了将列表中的 字符串整数 以及 整数 相加求和的功能，以后只要遇到这种情况，都可以用它来求和：\nsumpro([1,'2','3']) 6\r# def 定义 def sumpro(lst): return sum(int(i) for i in lst) sumpro(['1 ',' 2',3]) 6\r# lambda 表达式定义 lambda lst: sum(int(i) for i in lst) \u003cfunction __main__.\u003clambda\u003e(lst)\u003e\rlst = [['2','8'],['3','4']] sorted(lst,key=lambda lst: sum(int(i) for i in lst)) [['3', '4'], ['2', '8']]\r函数定义，也可以定义为实现功能，但没有返回值（默认返回 None）的过程。\n例如下列函数，实现了将列表中的字符串整数都转换为整数：\ndef convert_to_numb(lst): for i in range(len(lst)): if type(lst[i]) != int: lst[i] = int(lst[i]) lst = ['1',2,'3'] n = convert_to_numb(lst) lst, n is None ([1, 2, 3], True)\r函数定义所使用的函数名称，不能与当前作用域中以定义的名称相同，这会屏蔽掉已存在的名称，或将自定义的函数对象重新赋值给了该名称。\nstr(123) '123'\rdef str(x): return f'x={x}' str(123) # 屏蔽掉了内置名称 str 'x=123'\rf = 0 def f(): pass f # f 被重新赋值 \u003cfunction __main__.f()\u003e\r",
    "description": "",
    "tags": null,
    "title": "函数定义",
    "uri": "/python/12_function/02_function_definition/"
  },
  {
    "content": "空值 None，此对象会由没有显式地设置返回值的函数返回。None 是个内置名称，空对象求值，什么也不会发生。\nNone help(None) Help on NoneType object:\rclass NoneType(object)\r| Methods defined here:\r| | __bool__(self, /)\r| self != 0\r| | __repr__(self, /)\r| Return repr(self).\r| | ----------------------------------------------------------------------\r| Static methods defined here:\r| | __new__(*args, **kwargs) from builtins.type\r| Create and return a new object. See help(type) for accurate signature.\r# 没有返回值的列表方法 a = [].append(1) a # 将 a 打印出来，将打印内置名称 None print(a) None\r",
    "description": "",
    "tags": null,
    "title": "空值 None",
    "uri": "/python/08_other_types/01_none/"
  },
  {
    "content": "类是用来创建用户定义对象的模板，是抽象的对象（类对象）。例如我们说鱼类，指的就是一类抽象的对象，而具体到武昌鱼，鲈鱼，鲫鱼…… 就是具体的对象。\n定义了一个类，就可以用这个模块来创建它的具体对象（实例）。类定义的详细语法规则见 class 定义类。\n创建一个类，需要继承另一个类。新创建的类是子类，继承的类是基类。如不指定，创建类默认继承自所有类的基类 object。\n下面是一个没有任何自定义属性的简单类：\nclass A: pass A __main__.A\rtype(A) type\rA.__bases__ # 查看基类 (object,)\r继承一个指定的类，可以对它进行定制化开发。需要注意参数 self, 它是约定名称（可自定义但不推荐），它就代表类创建的实例对象自身。\n例如创建一个自定义的列表类，增加 add() 方法：\nclass Mylist(list): def add(self,value): self.append(value) lst = Mylist('123') # 创建实例赋值给 lst lst.add(4) # lst 调用 add 方法，self 参数就是 lst lst ['1', '2', '3', 4]\r或者自定义一个字典，当访问的键不存在时，不报错，而是返回 None（__missing__() 是用来定义字典子类时找不到键如何处理的魔法方法）：\nclass Mydict(dict): def __missing__(self, key): return d = Mydict(a=1,b=2) d, d['c'] ({'a': 1, 'b': 2}, None)\r我们也可以自定义任意的类，其中 __init__() 方法是创建实例时用来初始化实例对象的魔法方法，可以用它来增加一些自定义属性。没有该方法，创建实例时，将自动调用基类的该方法完成初始化。\n例如定义一个 “人” 类：\nclass Person: '这是人类' # 定义人的属性 def __init__(self, name): self.name = name self.ears = '耳朵' self.brain = '大脑' self.hands = '双手' # 人有生活 def live(self): print(f'{self.name}用{self.ears}' '听着音乐，' '享受美好生活。') # 还有工作 def work(self): print(f'{self.name}用{self.brain}和' f'{self.hands}' '勤劳致富。') # 造人 xm = Person('小明') xz = Person('小张') xm.live() # 小明在享受生活 xz.work() # 小张在努力工作 小明用耳朵听着音乐，享受美好生活。\r小张用大脑和双手勤劳致富。\r",
    "description": "",
    "tags": null,
    "title": "类定义",
    "uri": "/python/16_class/02_class_definition/"
  },
  {
    "content": "列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。\n对比下列两种创建数值平方列表的方式：\nsquares = [] for x in range(5): squares.append(x**2) print(squares) print(x) # 产生了一个变量 x [0, 1, 4, 9, 16]\r4\rsquares = [y**2 for y in range(5)] print(squares) print(y) # 没有多余变量 y [0, 1, 4, 9, 16]\r---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-3-c81791cbad54\u003e in \u003cmodule\u003e\r1 squares = [y**2 for y in range(5)]\r2 print(squares)\r----\u003e 3 print(y) #\rNameError: name 'y' is not defined\r我们发现，列表推导式简洁漂亮、易读，不会产生多余的变量而可能带来副作用。\n列表推导式示例:\n[(x, y) for x in [1,2] for y in [1,3] if x != y] [(1, 3), (2, 1), (2, 3)]\r相当于：\n_list = [] for x in [1,2]: for y in [1,3]: if x != y: _list.append((x,y)) _list [(1, 3), (2, 1), (2, 3)]\r列表推导式可以使用复杂的表达式和嵌套函数：\nfrom math import pi [str(round(pi, i)) for i in range(1, 4)] ['3.1', '3.14', '3.142']\r嵌套的列表推导式：\nmatrix = [[1, 2, 3], [5, 6, 7]] [[row[i] for row in matrix] for i in range(3)] [[1, 5], [2, 6], [3, 7]]\r相当于：\nmatrix = [[1, 2, 3], [5, 6, 7]] _list = [] for i in range(3): lst = [] for row in matrix: lst.append(row[i]) _list.append(lst) _list [[1, 5], [2, 6], [3, 7]]\r判断语句在前的列表推导式：\n[True if i % 2 == 0 else False for i in [1,4,7,9]] [False, True, False, False]\r相当于：\n_list = [] for i in [1,4,7,9]: if i % 2 == 0: _list.append(True) else: _list.append(False) _list [False, True, False, False]\r",
    "description": "",
    "tags": null,
    "title": "列表推导式",
    "uri": "/python/03_list/02_list_comprehension/"
  },
  {
    "content": "数理统计以概率论为基础, 研究大量随机现象的统计规律性. 分为 描述统计 和 推断统计 , 在数据分析领域具有非常重要的地位\n描述统计, 就是从总体数据中提取变量的主要信息(总和, 均值, 最大, 最多等), 从而从总体层面上, 对数据进行统计性描述. 通常配合绘制相关统计图进行辅助\n统计学的变量类型 统计学中的变量指研究对象的特征(属性), 每个变量都有变量值和类型, 类型可分为:\n类别变量 : 对研究对象定性, 分类\n类别变量又可分为:\n有序类别变量: 描述对象等级或顺序等, 例如, 优良中差 无序类别变量: 仅做分类, 例如 A, B 血型, 男女 数值变量 : 对研究对象定量描述\n数值变量又可分为:\n离散变量: 取值只能用自然数或整数个单位计算, 例如统计人数 连续变量: 在一定区间内可以任意取值, 例如计算身高 数值变量对加, 减, 求平均等操作有意义, 而类别变量无意义\n统计量 描述统计所提取的统计信息, 称为统计量, 主要包括:\n类别分析: 频数, 频率 集中趋势分析: 均值, 中位数, 众数, 分位数 离散程度分析: 极差, 方差, 标准差 描述分布形状: 偏度, 峰度 准备数据:\nimport numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns plt.rcParams['font.family'] = 'SimHei' plt.rcParams['axes.unicode_minus'] = False # 正态分布 data1 = np.around(np.random.normal(10, 3, 600)).reshape(-1, 1) # 左偏 t1 = np.random.randint(1, 21, size=100) t2 = np.random.randint(21, 31, size=500) left_data = np.concatenate([t1, t2]).reshape(-1, 1) # 右偏 t3 = np.random.randint(1, 11, size=500) t4 = np.random.randint(11, 21, size=100) right_data = np.concatenate([t3, t4]).reshape(-1, 1) # 类别 type_data = np.random.randint(0, 2, size=600).reshape(-1, 1) data = np.concatenate([data1, left_data, right_data, type_data], axis=1) data = pd.DataFrame(data, columns=['data1', 'left_data', 'right_data', 'type_data']) # 随机取 10 条数据 data.sample(10) data1\tleft_data\tright_data\ttype_data 202\t13.0\t27.0\t8.0\t0.0 595\t12.0\t23.0\t15.0\t0.0 523\t11.0\t21.0\t20.0\t1.0 259\t12.0\t29.0\t8.0\t0.0 498\t12.0\t24.0\t3.0\t0.0 110\t8.0\t27.0\t1.0\t0.0 65\t7.0\t12.0\t5.0\t0.0 231\t13.0\t25.0\t2.0\t0.0 321\t8.0\t30.0\t3.0\t0.0 544\t5.0\t29.0\t19.0\t1.0 a, 频数 数据中某个类别出现的次数称为该类别的频数\n例如, 计算上述两个类别(0.0 和 1.0)出现的频数:\nfrequency = data['type_data'].value_counts() frequency 0.0 309 1.0 291 Name: type_data, dtype: int64 b, 频率 数据中某个类别出现次数与总次数的比值称为该类别的频率\n例如, 计算上述两个类别(0.0 和 1.0)出现的频率:\npercentage = frequency * 100 / len(data) percentage 0.0 51.5 1.0 48.5 Name: type_data, dtype: float64 c, 均值 平均值, 一组数据的总和除以数据的个数\nd, 中位数 将一组数据按顺序排列, 位于最中间位置的值, 即是中位数, 如果数据个数为偶数, 取中间两个的平均值\ne, 众数 一组数据中出现次数最多的值\n通常三者的关系如下图所示:\n注意点 :\n数值变量通常使用均值和中值表示集中趋势, 类别变量则通常使用众数\n正态分布下, 数据量足够多, 三者相同\n均值使用所有数据计算, 容易受极端值影响, 中位数和众数则不会\n众数在一组数据中可能不唯一\n例, 计算字段 data1 的均值, 中位数和众数:\nmean = data['data1'].mean() median = data['data1'].median() mode = data['data1'].mode() print(f'均值:{mean} 中位数:{median}\\n众数:\\n{mode}') 均值:10.121666666666666 中位数:10.0 众数: 0 9.0 dtype: float64 f, 分位数 通过 n - 1 个分位, 将升序排列的数据分为 n 个区间, 使得每个区间数值个数相等(或近似相等), 则每个分位对应的数, 就是该 n 分位的分位数. 常用的有四分位数和百分位数\n以四分位数为例:\n第一个分位称为 1/4 分位(下四分位), 第二个称为 2/4 分位(中四分位), 第三个称为 3/4 分位(上四分位), 其中中四分位数, 其实就是中位数\n求四分位的值:\n首先计算各个分位的位置\nindex1 = (n - 1) * 0.25\nindex2 = (n - 1) * 0.5\nindex3 = (n - 1) * 0.75\n(index 从 0 开始, n 为元素的个数)\n根据位置计算各个分位的值\nindex 为整数, 值就是相应的 index 对应的元素\nindex 不为整数, 四分位位置介于 ceil(index) 和 floor(index) 之间, 加权计算分位值\n例, 求 x 的四分位数:\nindex 为整数\nx = np.arange(0, 9) n = len(x) index1 = (n - 1) * 0.25 index2 = (n - 1) * 0.5 index3 = (n - 1) * 0.75 index = np.array([index1, index2, index3]).astype(np.int32) x[index] array([2, 4, 6]) index 不是整数\nx = np.arange(0, 10) n = len(x) index1 = (n - 1) * 0.25 index2 = (n - 1) * 0.5 index3 = (n - 1) * 0.75 index = np.array([index1, index2, index3]) left = np.floor(index).astype(np.int32) right = np.ceil(index).astype(np.int32) weight, _ = np.modf(index) # 获取 index 整数和小数部分 result = x[left] * (1 - weight) + x[right] * weight result array([2.25, 4.5 , 6.75]) Numpy 中计算分位数可直接用方法 np.quantile 和 np.percentile\nnp.quantile(x, q=[0.25, 0.5, 0.75]), np.percentile(x, q=[25, 50, 75]) (array([2.25, 4.5 , 6.75]), array([2.25, 4.5 , 6.75])) Pandas 中计算分位数可利用 describe (默认 4 分位)\ns = pd.Series(x) s.describe() count 10.00000 mean 4.50000 std 3.02765 min 0.00000 25% 2.25000 50% 4.50000 75% 6.75000 max 9.00000 dtype: float64 s.describe().iloc[4:7] 25% 2.25 50% 4.50 75% 6.75 dtype: float64 可自定义分位:\ns.describe(percentiles=[0.15, 0.4, 0.8]) count 10.00000 mean 4.50000 std 3.02765 min 0.00000 15% 1.35000 40% 3.60000 50% 4.50000 80% 7.20000 max 9.00000 dtype: float64 g, 极差 一组数据中, 最大值与最小值之差\nh, 方差 方差体现一组数据中, 每个元素与均值的偏离程度\n$$\\sigma^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(x_{i}-\\bar{x}\\right)^{2}$$ $x_{i}:$ 数组中的每个元素\n$n:$ 数组元素的个数\n$\\bar{x}:$ 数组中所有元素的均值\ni, 标准差 标准差为方差的开方. 方差和标准差可以体现数据的分散性, 越大越分散, 越小越集中. 也可体现数据波动性(稳定性), 越大波动越大, 反之亦然\n当数据足够多时, 可用 n 代替 n - 1\n例, 计算 left_data 字段的极差, 方差, 标准差:\nsub = np.ptp(data['left_data']) var = data['left_data'].var() std = data['left_data'].std() sub, var, std (29.0, 44.631048970506306, 6.680647346665315) 绘图对比 data1 和 left_data 的分散程度\nplt.figure(figsize=(11, 1)) plt.ylim(-0.5, 1.5) plt.plot(data['data1'], np.zeros(len(data)), ls='', marker='o', color='r', label='data1') plt.plot(data['left_data'], np.ones(len(data)), ls='', marker='o', color='g', label='left_data') plt.axvline(data['data1'].mean(), ls='--', color='r', label='data1均值') plt.axvline(data['left_data'].mean(), ls='--', color='g', label='left_data均值') plt.legend() plt.show() j, 偏度 统计数据分布偏斜方向和程度的度量, 统计数据分布非对称程度的数字特征, 偏度为 0 , 对称分布, 小于 0, 左偏分别, 大于 0, 右偏分布\nk, 峰度 表征概率密度分布曲线在平均值处峰值高低的特征数. 直观看来, 峰度反映了峰部的尖度, 峰度高意味着标准差增大是由低频度的大于或小于平均值的极端差值引起的. 在相同的标准差下，峰度越大，分布就有更多的极端值，那么其余值必然要更加集中在众数周围，其分布必然就更加陡峭\n样本的峰度是和正态分布相比较而言的统计量, 符合正态分布的峰度为 0\n例, 计算 data 中前三个字段的偏度, 峰度与标准差, 并绘图比较:\nprint('偏度:', data['data1'].skew(), data['left_data'].skew(), data['right_data'].skew()) print('峰度:', data['data1'].kurt(), data['left_data'].kurt(), data['right_data'].kurt()) print('标准差:', data['data1'].std(), data['left_data'].std(), data['right_data'].std()) 偏度: 0.0013827051273872734 -1.704193031847586 0.9122511031664028 峰度: 0.01807838530280126 2.5013831586663304 0.29539776195275813 标准差: 2.891504548352662 6.680647346665315 4.672046842962734 sns.kdeplot(data['data1'], shade=True, label='正态') sns.kdeplot(data['left_data'], shade=True, label='左偏') sns.kdeplot(data['right_data'], shade=True, label='右偏') plt.show() ",
    "description": "",
    "tags": null,
    "title": "描述统计",
    "uri": "/statistics/statistics1/"
  },
  {
    "content": "数字类型属于内置类型。有三种不同的数字类型：整数，浮点数和复数。\n整数通常只有数字，浮点数有小数点，而复数有实部（省略则为 0）和虚部，虚部必须有 J 或 j。\n它们的类型分别是 int，float 和 complex。\ntype(1), type(1.0), type(1j) (int, float, complex)\r它们虽然属于不同的类型，但 Python 完全支持其混合运算。\n而且布尔类型属于整数类型的子类型，布尔类型也可参与混合运算。\nTrue/3 + 1.5 - 1J (1.8333333333333333-1j)\r数字之间比较时，比较的是它们的精度决定的精确值：\nTrue == 1 == 1.0 True\r对于不同类型的数字，只要精确值相等，哈希值必定相等：\nhash(True) == hash(1) == hash(1.0) True\r因此作为集合的元素时，它们是一个元素；作为字典的键时，是同一个键。但这不是明智之举，因为浮点数存在精度问题：\n{True, 1, 1.0} {True}\r{True:1, 1:2, 1.0:3} {True: 3}\r1.00000000000000009 == 1 True\r整数，浮点数和复数的构造函数分别是：int()，float() 和 complex()。构造细节详见相应内置函数知识点。\nint('1'), float('1.0'), complex('1') (1, 1.0, (1+0j))\r关于各数字类型的特性和详细介绍见后面章节。\njupyter附件 01_numeric.ipynb (4 KB) 02_int.ipynb (8 KB) 03_bool.ipynb (6 KB) 04_float.ipynb (3 KB) 05_complex.ipynb (3 KB) 06_number_operations.ipynb (4 KB) ",
    "description": "",
    "tags": null,
    "title": "数字类型概述",
    "uri": "/python/01_numeric/"
  },
  {
    "content": "整数具有无限精度。有四种整数表示法：十六进制整数（0x 或 0X 开头），十进制整数，八进制整数（0o 或 0O 开头）和二进制整数（0b 或 0B 开头）。\n# 十六进制 0x10 16\r# 十进制 10 10\r# 八进制 0O10 8\r# 二进制 0b10 2\r数字之间或基数说明符（例如 0b）后，可以放一个下划线：\n123_456_789 123456789\r0b_1010 10\r十进制整数不可以 0 开头：\n012 File \"\u003cipython-input-44-95f378563ada\u003e\", line 1\r012\r^\rSyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\r整数类型按位运算 按位运算只对整数有意义。以优先级升序排序的按位运算:\nx | y x 和 y 按位 或 运算 x ^ y x 和 y 按位 异或 运算 x \u0026 y x 和 y 按位 与 运算 x \u003c\u003c n x 左移 n 位，相当于 x*2**n x \u003e\u003e n x 右移 n 位，相当于 x//(2**n) ~x x 逐位取反 下面以八位机为例，x 取 6，y 取 8，n 取 2：\n6 和 8 在内存中的储存分别为 00000110，00001000。\n按位 或 运算，规则如下：\n0|0, 1|0, 1|1 (0, 1, 1)\r6|8 逐位运算后结果为 00001110，十进制就是 14：\n6|8, 0b00001110 (14, 14)\r同理可按下列计算规则，计算出 6^8, 6\u00268:\n0^0, 0^1, 1^1 (0, 1, 0)\r0\u00260, 0\u00261, 1\u00261 (0, 0, 1)\r6^8, 6\u00268 (14, 0)\r6 左移 2 位结果为 00011000，十进制就是 24，相当于 6*2**2：\n6\u003c\u003c2, 0b00011000, 6*2**2 (24, 24, 24)\r同理可计算出 6»2，结果为 1:\n6\u003e\u003e2, 6//(2**2) (1, 1)\r6 逐位取反为 11111001，因为我们是以八位机来举例的，八位机中 11111001 表示 -7，这是个天才设计，正负整数计算可以利用一种电路即可完成，有兴趣的可以查资料了解详情。\n~6 -7\r例如 8 + (-7) 如此计算：\n00001000 + 11111001 =100000001 因为是八位机，结果有 9 位，所以第一个 1 溢出，结果就是 1。\n",
    "description": "",
    "tags": null,
    "title": "整数及其位运算",
    "uri": "/python/01_numeric/02_int/"
  },
  {
    "content": "空格拼接 相邻的两个字符串，无论中间隔了多少个空格（包括 0 个），都会自动连接到一起：\n'Py''thon', 'Py' 'thon' ('Python', 'Python')\r甚至可以用 () 包围实现换行拼接，这在字符串（或正则表达式）很长时非常有用：\n('Py' f'thon{3}' r'\\Go') 'Python3\\\\Go'\r运算符 + 拼接 运算符 + 拼接字符串，和空格类似，但 + 拼接字符串可以是变量的形式：\na = 'Py' b = 'thon' 'Py' + b, a + b ('Python', 'Python')\r运算符 + 还可以和赋值运算符 = 连用，拼接字符串的同时进行赋值：\n# 将 a 和 b 拼接，赋值给 a a += b print(a) # 将 b 和 a 拼接，赋值给 b b += a b Python\r'thonPython'\r",
    "description": "",
    "tags": null,
    "title": "字符串拼接",
    "uri": "/python/02_string/02_concatenated_string/"
  },
  {
    "content": "内置函数 any()，Python 官方文档描述如下：\nhelp(any) Help on built-in function any in module builtins:\rany(iterable, /)\rReturn True if bool(x) is True for any x in the iterable.\rIf the iterable is empty, return False.\r如果可迭代对象（iterable）的任一元素为真值则返回 True。如果可迭代对象为空，返回 False。\nany([0,1]) True\rany((None, [], range(1,1))) False\r",
    "description": "",
    "tags": null,
    "title": "any() 有一个元素布尔值为真？",
    "uri": "/python/11_built-in_function/03_any/"
  },
  {
    "content": "字典方法 dict.values()，Python 官方文档描述如下：\nhelp(dict.values) Help on method_descriptor:\rvalues(...)\rD.values() -\u003e an object providing a view on D's values\r返回由字典的值组成的动态视图。字典的视图支持成员检测，可以被迭代。\nd = {'a':1, 'b':2} d_view = d.values() print(d_view) d['c'] = 3 # 添加元素，视图也动态变化 print(d_view) dict_values([1, 2])\rdict_values([1, 2, 3])\r1 in d_view True\r[i for i in d_view] [1, 2, 3]\r",
    "description": "",
    "tags": null,
    "title": "dict.values 值视图",
    "uri": "/python/07_dictionary/03_dict.values/"
  },
  {
    "content": "if 语句用于有条件的执行。语法如下：\nif assignment_expression:\rsuite\relif assignment_expression: # 可选子句\rsuite\r... # 可以多个 elif\relse: #可选子句\rsuite 对于简单语句，可以写为一行，但不推荐。\n它通过对表达式逐个求值直至找到一个真值。然后执行该 if 语句或子句体下的代码，从而 if 语句的其他部分不会被执行或求值。\n如果所有表达式均为假值，else 子句体如果存在就会被执行。\nfor i in range(5): if i % 2 == 0:print(i) 0\r2\r4\rfor i in range(5): if i % 2 == 0: print(i) 0\r2\r4\ri,j = 0,1 if i \u003c 0: print(i) # 不执行 elif i == 0: print(i) # 执行，下面的则不再执行 elif j == 1: print(j) else: print(i,j) 0\ri,j = 0,1 if i \u003c 0: print(i) # 不执行 elif i == 1: print(i) # 不执行 elif j == 0: print(j) # 不执行 else: print(i,j) # 执行 0 1\r多个 if 语句连用，则分别判断，互不影响：\ni,j = 0,1 if i \u003c 0: print(i) # 不执行 else: print(i,j) # 执行 if i == 0: print(i) # 执行 if j == 1: print(j) # 执行 else: print(i,j) # 不执行 0 1\r0\r1\r",
    "description": "",
    "tags": null,
    "title": "if",
    "uri": "/python/10_statement/03_if/"
  },
  {
    "content": "集合方法 set.issubset()，Python 官方文档描述如下：\nhelp(set.issubset) Help on method_descriptor:\rissubset(...)\rReport whether another set contains this set.\r检查一个集合中的元素，是否都在另一个集合中。相当于 a \u003c= b（a，b 是两个集合），但方法中的参数可以是可迭代对象。\n{1,2}.issubset([1,2,3]) True\r{1,2} \u003c= {1,2,3} True\r{1,2}.issubset((1,1,2)) True\r该方法检查是否是子集，而对于真子集，可以使用 \u003c 进行检查：\n{1,2} \u003c {1,1,2} False\r{1,2} \u003c {1,2,3} True\r",
    "description": "",
    "tags": null,
    "title": "set.issubset 是子集吗？",
    "uri": "/python/06_set/03_set.issubset/"
  },
  {
    "content": "元组方法 tuple.index()，Python 官方文档描述如下：\nhelp(tuple.index) Help on method_descriptor:\rindex(self, value, start=0, stop=9223372036854775807, /)\rReturn first index of value.\rRaises ValueError if the value is not present.\r返回列表中第一个值为 value 的元素从零开始的索引。如果没有这样的元素将会抛出 ValueError 异常。\n可选参数 start 和 stop 是切片符号，用于将搜索限制为元组的特定子序列。返回的是相对于整个序列开始计算的索引，而不是相对于 start 参数。\n(1,2,3,4,1).index(1) 0\r(1,2,3,4,1).index(1,1) 4\r(1,2,3,4,1).index(1,1,3) ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-4-c6a812394eea\u003e in \u003cmodule\u003e\r----\u003e 1 (1,2,3,4,1).index(1,1,3)\rValueError: tuple.index(x): x not in tuple\r",
    "description": "",
    "tags": null,
    "title": "tuple.index 查找元素索引",
    "uri": "/python/04_tuple/03_tuple.index/"
  },
  {
    "content": "布尔值有 True 和 False，布尔类型是整数类型的子类型，所以整数的运算都适用布尔值运算。\nissubclass(bool,int) True\rTrue + 1 2\r~True -2\r任何对象都可以进行布尔值的检测，以便在 if 或 while 中作为条件或是作为下文所述布尔运算的操作数来使用。\n一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 __bool__() 方法且返回 False 或是定义了 __len__() 方法且返回零。\n下面基本完整地列出了会被视为假值的内置对象:\n被定义为假值的常量: None 和 False。 任何数值类型的零: 0, 0.0, 0j, Decimal(0), Fraction(0, 1) 空的序列和多项集: ‘’, (), [], {}, set(), range(0) 可以使用内置函数 bool() 来查看任意对象的布尔值：\nbool(None), bool(int), bool(0) (False, True, False)\r布尔运算 布尔运算按优先级升序排列：\nx or y, if x is false, then y, else x x and y, if x is false, then x, else y not x, if x is false, then True, else False 任何值（包括表达式求值结果），除了自身之外，还有相应的逻辑值（布尔值），所以布尔运算符 or，and，not 可对任何值进行运算。\n举例如下：\n1\u003e2 or 'python' 'python'\r1\u003e2 表达式结果为 False，所以布尔运算结果为 ‘python’。\n1+1 or 'python' 2\r1+1 表达式结果为 2，布尔值为 True，所以布尔运算结果为 2。\n1\u003e2 and 'python' False\r1\u003e2 表达式的结果为 False，所以布尔运算结果为 False。\n1\u003c2 and 'python' 'python'\r1\u003c2 表达式的结果为 True，所以布尔运算结果为 ‘python’。\nnot 'python' False\r‘python’ 的布尔值为 True，所以布尔运算结果为 False。\nnot 0 True\r0 的布尔值为 False，所以布尔运算结果为 True。\n",
    "description": "",
    "tags": null,
    "title": "布尔值及布尔运算",
    "uri": "/python/01_numeric/03_bool/"
  },
  {
    "content": "Python 表达式语句中操作符的优先顺序从最低优先级（最后绑定）到最高优先级（最先绑定）如下：\n:= 赋值表达式 lambda lambda 表达式 if -- else 条件表达式 or 布尔逻辑或 OR and 布尔逻辑与 AND not x 布尔逻辑非 NOT in, not in, is, is not, \u003c, \u003c=, \u003e, \u003e=, !=, == 比较运算 | 按位或 OR ^ 按位异或 XOR \u0026 按位与 AND \u003c\u003c, \u003e\u003e 移位 +, - 加和减 *, /, //, % 乘，矩阵乘，除，整除，取余 +x, -x, ~x 正，负，按位非 NOT ** 乘方（右边的先绑定） await x await 表达式 x[index], x[index:index], x(arguments...), x.attribute 抽取，切片，调用，属性引用 (expressions...), [expressions...], {key: value...}, {expressions...} 绑定或加圆括号的表达式，列表显示，字典显示，集合显示 一个表达式语句中可以有多个上述操作符，最终返回一个值（包括返回值为 None 的函数调用）。\n而赋值语句中的赋值操作符 =，+=，-=，*=，/=，//=，%=，\u0026=，|=，^=，\u003e\u003e=，\u003c\u003c=，**=，在操作符中优先级最低，它右边表达式的值计算完之后，才最后绑定到左边的名称。\n举例如下：\nvalue = int('2')**(-1) == 2/(3+1) value True\rint('2')**(-1) == 2/(3+1) True\r[].append(1) is None and not 1 - 1 True\rvalue = 1 if 'a' in 'a b c'.split()[1:3] else 2 value 2\rvalue **= 3 + 2 * 1 value 32\r操作符 = 可以用来连续赋值：\na = b = c = 1 a,b,c (1, 1, 1)\r",
    "description": "",
    "tags": null,
    "title": "操作符优先级",
    "uri": "/python/09_operator/03_precedence/"
  },
  {
    "content": "形参是函数定义中指定的参数名称。指定某个参数的形式，决定了该形参在函数调用时，可以接受实参的方式。关于实参详见 函数调用。\n因而形参分为五种：\n位置或关键字：指定一个可以作为 位置参数 传入也可以作为 关键字参数 传入的实参。这是默认的形参类型，但有默认值的形参必须置于无默认值的形参之后。 def f(a,b=None): print(f'a={a},b={b}') # 位置实参传入 f(1,2) # 关键字实参传入 f(b=2,a=1) a=1,b=2\ra=1,b=2\r仅限位置：指定一个只能通过位置传入的参数。仅限位置形参通过在函数定义的形参之后包含一个 / 字符来定义。/ 之前的参数为仅限位置形参，之后的形参为默认形参类型。有默认值的形参也必须置于无默认值的形参之后。 def f(a,b=None,/,c=None): # 因为 b 有默认值，c 必须要有默认值 print(f'a={a},b={b},c={c}') # 按位置传参调用 f(1,2,c=3) # 关键字传参则不允许 f(a=1,b=2) a=1,b=2,c=3\r---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-6-52b3afdaad4c\u003e in \u003cmodule\u003e\r4 f(1,2,c=3)\r5 # 关键字传参则不允许\r----\u003e 6 f(a=1,b=2)\rTypeError: f() got some positional-only arguments passed as keyword arguments: 'a, b'\r仅限关键字：指定一个只能通过关键字传入的参数。仅限关键字形参可通过在函数定义的形参中包含单个 可变位置形参 或者在形参之前放一个 * 来定义。可变位置形参 或 * 之后的参数为仅限关键字形参。 def f(*a,b=None,c=None): # b 和 c 必须有默认值 print(f'a={a},b={b},c={c}') # 位置传参将被解读为可变位置参数 f(1,2,3) # 关键字传参 f(1,b=2,c=3) a=(1, 2, 3),b=None,c=None\ra=(1,),b=2,c=3\rdef f(*,a,b=None,c): print(f'a={a},b={b},c={c}') # 关键字传参 f(b=2,a=1,c=3) # 位置传参不允许 f(1,2,3) a=1,b=2,c=3\r---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-1-9d584fa28622\u003e in \u003cmodule\u003e\r4 f(b=2,a=1,c=3)\r5 # 位置传参不允许\r----\u003e 6 f(1,2,3)\rTypeError: f() takes 0 positional arguments but 3 were given\r可变位置：指定一个可以接受任意数量的位置参数传入的参数。这种形参可通过在形参名称前加缀 * 来定义，并将接受到的参数封装成一个元组。该参数如果接受到了实参，它前面的参数必须为仅限位置参数。 def f(a,b=None,*c): print(f'a={a},b={b},c={c}') # c 没有接受参数 f(1); f(b=2,a=1) # c 接受到了参数 f(1,2,3,4,5) a=1,b=None,c=()\ra=1,b=2,c=()\ra=1,b=2,c=(3, 4, 5)\r可变关键字：指定一个可以接受任意数量的关键字参数的参数。这种形参可通过在形参名称前加缀 ** 来定义，并将接受到的参数封装成一个字典。 def f(a,b=None,**c): print(f'a={a},b={b},c={c}') f(1,2,c=3,d=4) f(d=4,b=2,a=1,c=3) a=1,b=2,c={'c': 3, 'd': 4}\ra=1,b=2,c={'d': 4, 'c': 3}\r带默认值的参数，可变位置参数和可变关键字参数，调用函数时可以不传参。\ndef f(a=1,*b,c=3,**d): print(f'a={a},b={b},c={c},d={d}') f() a=1,b=(),c=3,d={}\r默认值只会执行一次，这条规则很重要。如果参数有默认值且为可变对象，则需要做必要的限制：\ndef f(a=[]): print(id(a)) a.append(1) print(a) f() # 多次调用会引用参数指向的同一个对象 f() 2399568560064\r[1]\r2399568560064\r[1, 1]\r# 可以拷贝一个副本 def f(a=[]): b = a.copy() b.append(1) print(b) f() f() [1]\r[1]\r# 或者修改参数 def f(a=None): if a == None: a = [] a.append(1) else: a.append(1) print(a) f() f([]) [1]\r[1]\r函数的形参可以使用标注，标注的语法是参数后面接一个冒号 :，然后接一个表达式（任意表达式），通常用来指明应该（不是必须）传递什么类型的参数等。标注提高了代码的可读性：\n# a 标注为字符串类型，b 标注为整数，并设置默认值 2 def f(a:str,b:int=2): return a*b f('Hi',3) 'HiHiHi'\rdef f(a:'字符串',b:'整数'=2): return a*b f('Hi') 'HiHi'\r",
    "description": "",
    "tags": null,
    "title": "函数形参",
    "uri": "/python/12_function/03_formal_parameter/"
  },
  {
    "content": "每一个 .py 文件模块，都是 Python 的可执行文件。文件内容可以为空，但执行什么也不发生。\n你可以在某些编辑工具里打开文件执行，也可以在命令行使用 python 文件路径 或 python -m 模块 的方式执行。这些方式都是主模块中直接执行文件。\n主模块（你正在运行代码的当前模块）的 __name__ 属性总是 '__main__' （__main__ 是一个在解释器启动时直接初始化的特殊模块），因此直接执行文件，if __name__ == '__main__': 语句下的代码一定会被执行，而如果导入到其他模块则不会。\n__name__ '__main__'\r下面举例说明：\n当前文件路径下，有一个 myfile 的包，包里有 space.py 和 mycode.py 模块，内容如下：\n# space.py 为空 # mycode.py 的内容, 在此源码直接执行 _a = '自学' def __f(): print(_a) msg1 = '我是mycode模块中的代码' print(msg1) if __name__ == '__main__': msg2 = '我是导入其他模块不会执行的代码' print(msg2) 我是mycode模块中的代码\r我是导入其他模块不会执行的代码\r# 导入不会执行 __name__ == '__main__' 下面的代码 from myfile import mycode print(mycode.msg1) mycode.msg2 我是mycode模块中的代码\r我是mycode模块中的代码\r---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r~\\AppData\\Local\\Temp/ipykernel_21344/86150704.py in \u003cmodule\u003e\r2 from myfile import mycode\r3 print(mycode.msg1)\r----\u003e 4 mycode.msg2\rAttributeError: module 'myfile.mycode' has no attribute 'msg2'\r命令行直接执行模块效果同上。下面使用命令执行（%run 是 jupyter 的魔法命令，终端请改为 python）：\n# 文件路径必须带 .py，可以是相对或绝对路径 %run myfile/space.py %run myfile/mycode.py 我是mycode模块中的代码\r我是导入其他模块不会执行的代码\rimport warnings # 忽略警告 warnings.filterwarnings(\"ignore\") # 模块可以使用属性表示法，但不能有 .py %run -m myfile.mycode 我是mycode模块中的代码\r我是导入其他模块不会执行的代码\r",
    "description": "",
    "tags": null,
    "title": "可执行文件",
    "uri": "/python/15_module/04_executable_file/"
  },
  {
    "content": "列表是序列类型中的可变类型，它的索引和切片操作，和通用的序列操作比较，有许多不一样的地方，主要体现在利用索引和切片对列表元素进行增、删、改。\n索引和切片是序列类型通用操作，详细的规则和用法，见序列索引和切片。\n列表可以利用索引替换某一个元素：\n_list = [1,2,3] _list[1] = 0 _list [1, 0, 3]\r利用切片将切片中的元素替换为可迭代对象中的元素：\n_list = [1,2,3] _list[1:3] = '123' _list [1, '1', '2', '3']\r# 该替换,切片长度和可迭代对象长度必须相等 _list = [1,2,3,4,5] _list[1:5:2] = '24' _list [1, '2', 3, '4', 5]\r需要注意，替换并没有改变原来的列表对象：\nlist_1 = [1,2,3] print(id(list_1),list_1) list_1[2] = 0 print(id(list_1),list_1) list_1[:] = range(5) print(id(list_1),list_1) list_1[::2] = ('a','b','c') print(id(list_1),list_1) 2065281773704 [1, 2, 3]\r2065281773704 [1, 2, 0]\r2065281773704 [0, 1, 2, 3, 4]\r2065281773704 ['a', 1, 'b', 3, 'c']\r可以利用切片在列表中任意位置插入数据片段：\n_list = [1,2,3] # 在前面插入两个 0 _list[:0] = (0,0) print(_list) # 在索引为 2 的元素前面插入 'a','b' _list[2:2] = ['a','b'] _list [0, 0, 1, 2, 3]\r[0, 0, 'a', 'b', 1, 2, 3]\r列由切片浅拷贝列表，生成新的列表，但列表中有可变对象时，新列表中的可变对象和对应的原来列表中的可变对象是同一个对象的多次引用：\nlist_1 = [[1,2],3,4] list_2 = list_1[:] print('原列表：',id(list_1),'新列表：',id(list_2)) print('原列表中的可变对象：', id(list_1[0]), '\\n新列表中对应的可变对象：',id(list_2[0])) 原列表： 2065281774536 新列表： 2065281774664\r原列表中的可变对象： 2065281383112 新列表中对应的可变对象： 2065281383112\r改变其中一个，都会跟着改变。需要注意区分修改列表中元素的元素，和修改列表元素的区别：\nlist_1[0][0] = 'a' print(list_1, list_2) list_1[0] = 'a' print(list_1, list_2) [['a', 2], 3, 4] [['a', 2], 3, 4]\r['a', 3, 4] [['a', 2], 3, 4]\r",
    "description": "",
    "tags": null,
    "title": "列表的索引和切片",
    "uri": "/python/03_list/03_list_indexes_and_slices/"
  },
  {
    "content": "raise 语句 允许强制发生指定的异常。\nraise NameError('HiThere') ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-1-72c183edb298\u003e in \u003cmodule\u003e\r----\u003e 1 raise NameError('HiThere')\rNameError: HiThere\r如果你需要确定是否引发了异常但不打算处理它，则可以使用更简单的 raise 语句形式重新引发异常:\ntry: raise NameError('HiThere') except NameError: print('An exception flew by!') raise An exception flew by!\r---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-2-bf6ef4926f8c\u003e in \u003cmodule\u003e\r1 try:\r----\u003e 2 raise NameError('HiThere')\r3 except NameError:\r4 print('An exception flew by!')\r5 raise\rNameError: HiThere\r",
    "description": "",
    "tags": null,
    "title": "抛出异常",
    "uri": "/python/13_exception/03_raising/"
  },
  {
    "content": "内置类型除了数字类型，布尔类型，序列类型，集合类型，映射类型，迭代器类型，解释器支持的还有一些其他种类的对象。这些对象大都仅支持一两种操作。\n模块 模块唯一的特殊操作是属性访问: m.name，这里 m 为一个模块而 name 为定义在 m 的符号表中的一个属性的名称。模块属性可以被赋值。import 语句严格来说也是对模块对象的一种操作。关于模块有详细的知识点介绍。\ntype(math) module\rimport math math.pi 3.141592653589793\r函数 函数对象是通过函数定义创建的。对函数对象的唯一操作是调用它: func(argument-list)。\n实际上存在两种不同的函数对象：内置函数和用户自定义函数。两者支持同样的操作（调用函数），但实现方式不同，因此对象类型也不同。关于函数有详细的知识点介绍。\nprint('abc') # 调用函数 abc\rtype(print) builtin_function_or_method\rdef f():pass # 自定义函数 type(f) function\r方法 方法是在类中定义，使用属性表示法来调用的函数。关于方法有详细的知识点介绍。\ntype(list.append) method_descriptor\rtype([].append) builtin_function_or_method\r代码对象 代码对象可由内置的 compile() 函数返回，也可通过从函数对象的 __code__ 属性从中提取。\n可将代码对象（而非源码字符串）传给 exec() 或 eval() 内置函数来执行或求值。\ndef f(): print('代码对象') code = f.__code__ type(code) code\rexec(code) 代码对象\r类型对象 类型对象表示各种对象类型。对象的类型可通过内置函数 type() 来获取。类型没有特殊的操作。标准库模块 types 定义了所有标准内置类型的名称。\ntype(int), type(list) (type, type)\rtype(1), type([]) (int, list)\r",
    "description": "",
    "tags": null,
    "title": "其他内置类型",
    "uri": "/python/08_other_types/03_other_types/"
  },
  {
    "content": "实例是调用类对象创建的具体对象。例如调用内置类型 int，创建的所有整数，都是 int 类的实例。可通过内置函数 isinstance() 进行实例检查。\nint('1') 1\risinstance(1,int) True\rPython 中所有的实例对象，都是 object 的实例。所有的类都是 object 的子类，也被视为 object 的实例；所有的类也被视为默认的元类（创建类的类）type 的实例。\n如果一个实例对象应该视为某个类的实例，可以通过魔法方法 __instancecheck__() 来重载 isinstance() 函数，自定义实例检查行为。\nisinstance(1,object), isinstance([],object) (True, True)\risinstance(int,object) True\risinstance(int,type) True\r下面定义一个 “人” 类，来对实例进行说明：\nclass Person: '这是人类' # 定义人的属性 def __init__(self, name): self.name = name self.ears = '耳朵' self.brain = '大脑' self.hands = '双手' # 人有生活 def live(self): print(f'{self.name}用{self.ears}' '听着音乐，' '享受美好生活。') # 还有工作 def work(self): print(f'{self.name}用{self.brain}和' f'{self.hands}' '勤劳致富。') # 造人 xm = Person('小明') xz = Person('小张') 上述 “人” 类对象 Person 是类对象，调用类对象创建的 xm 和 xz，是两个具体的 “人”，是实例对象。\nPerson __main__.Person\rxm \u003c__main__.Person at 0x24cf9ef6d68\u003e\rxz \u003c__main__.Person at 0x24cf9ef6d30\u003e\risinstance(xm, Person), isinstance(xz, Person) (True, True)\risinstance(Person, object), isinstance(Person, type) (True, True)\r",
    "description": "",
    "tags": null,
    "title": "实例",
    "uri": "/python/16_class/03_instance/"
  },
  {
    "content": "官方文档\n正则表达式, 也叫规则表达式, 是强大的文本字符串处理工具, 通常用来验证, 查找, 筛选, 提取, 替换那些符合某个规则的文本字符串，是实现文本高效处理的神器\n1, 匹配规则 正则表达式的核心就是设计一个规则, 按照这个规则”按图索骥”, 去寻找符合这个规则的字符串, 并将它按需处理\n先以一个最简单的例子进行探索:\nre: 正则表达式模块\nfindall: 模块的一个方法, 传入 正则表达式 和 要去匹配字符串 将匹配结果以列表形式返回, 没有匹配结果返回空列表\n\\d: 定义的规则, 表示匹配任意一个 0~9 的数字\n198\\d年: 匹配符合 198某年 的字符串\n然后按照规则去匹配字符串: '1988年 2000年 2020年 1980年'\n# 导入模块 re import re # 按规则 r'198\\d年' 匹配, r 的作用在 python 基础部分已介绍 re.findall(r'198\\d年', '1988年 2000年 2020年 1980年') ['1988年', '1980年'] \\d 是其中一个规则定义符, 可以和其他字符组合成正则表达式, 它自身也是一个正则表达式\nd 则是字母 d 本身，像 \\d 这样的特殊规则定义符有许多，如 .，*，+，\\s，()，[] 等等\n任意一个非特殊字符都可以作为匹配它自身的正则表达式\n如果要匹配规则定义符，例如如要匹配 \\d, 需要用 \\ 进行转义，也就是要用 \\\\d 来匹配 \\d（其实是 \\\\ 来匹配 \\，d 来匹配 d）\nre.findall(r'\\\\d.+\\[a]', r'a\\d.+[a]') ['\\\\d.+[a]'] 2, 常用规则定义符 2.01, 定义类别匹配 \\w 匹配任意一个可以构成词语的 Unicode 字符, 包括数字及下划线, \\W 则相反\na = r'my\\wname' b = r'my\\Wname' c = 'my1name, my_name, my.name, my我name' re.findall(a, c) ['my1name', 'my_name', 'my我name'] re.findall(b, c) ['my.name'] \\d 匹配任意一个 十进制 数字, \\D 匹配任意一个非数字\na = r'01\\d-\\D123' b = '010-0123, 010-o123, 01０-P123' re.findall(a, b) ['010-o123', '01０-P123'] \\s 匹配任何Unicode空白字符（包括 [ \\t\\n\\r\\f\\v]，还有很多其他字符，比如不同语言排版规则约定的不换行空格）, \\S 则相反\na = r'a\\sb\\Sc' b = 'a b c, a bcc, a bcc' re.findall(a, b) ['a bcc'] . 匹配除换行符 \\n 之外的任意一个字符\na = r'a.b' b = '''a b, a-b, a b, a\\nb''' re.findall(a, b) ['a-b', 'a b'] \\b 匹配 \\w 和 \\W 之间（或 \\w 开头和结尾的边界）的空字符串, \\B 与 \\b 相反，匹配非 \\w 和 \\W 之间的空字符串（或 \\W 开头和结尾的边界）\nre.findall(r'\\b.', 'ab啊_c。d，\\n') ['a', '。', 'd', '，'] re.findall(r'.\\B', 'ab啊_c。d，\\n') ['a', 'b', '啊', '_', '，'] 2.02, 定义范围匹配 用括号 [] 将字符(表达式)包围起来, 表示在括号内指定的范围内匹配任意一个\nre.findall('[abc]', 'bill') ['b'] 在 [] 内, 以 ^ 开头, 表示排除括号内的字符(表达式)范围匹配\nre.findall('[^abc]', 'abcd') ['d'] 在 [] 内, 数字或字母之间用 - 连接, 表示在两者(包含)之间的范围内匹配\nre.findall('[a-d0-5A\\-D]', 'af357AB-') ['a', '3', '5', 'A', '-'] 一些特殊字符在 [] 内失去特殊含义\nre.findall('[(+*)\\]\\w]', '+(*)a].?') ['+', '(', '*', ')', 'a', ']'] 2.03, 定义边界匹配 ^ 或 \\A, 表示必须以接下来的字符(表达式)开头才能被匹配, 换行开头也不能匹配\na = '^b\\d[bc]' b = '''a2b b2b''' c = 'b2bcd' re.findall(a, b) [] re.findall(a, c) ['b2b'] a = '\\Ab\\d[bc]' b = '''a2b b2b''' c = 'b2bcd' re.findall(a, b) [] re.findall(a, c) ['b2b'] $ 或 \\Z表示必须以其前面的字符(表达式)结尾才能被匹配, 换行之前的结束也不能匹配\nre.findall('a\\w$', '''ab ac''') ['ac'] re.findall('a\\w\\Z', 'ab\\nad') ['ad'] 2.04, 定义数量匹配 + 其前面的字符(表达式)至少有一个的都能匹配\nre.findall(r'10+', '110, 100, 1001') ['10', '100', '100'] ? 其前面的字符(表达式)最多有一个的才能匹配\nre.findall(r'10?', '1, 10, 100') ['1', '10', '10'] * 其前面的字符(表达式)没有或有多个都可以匹配\nre.findall(r'10*', '1, 10, 1001') ['1', '10', '100', '1'] {n} 其前面的字符(表达式)有 n 个才能匹配\nre.findall(r'1\\d{3}', '12, 123, 1a23, 1234') ['1234'] {n,} 其前面的字符(表达式)有至少 n 个才能匹配, {m,n} 则表示有 m~n 个才能匹配, m 和 n 之间只有 , 号而不能有空格\nre.findall(r'1\\d{2,}', '12, 123, 1234, 12345') ['123', '1234', '12345'] re.findall(r'1\\d{2,3}', '12, 123, 1234, 12345') ['123', '1234', '1234'] 2.05, 或 匹配符 | 符号 | 两边的内容, 有一边匹配 或 两边都匹配都可以, 但当 | 在括号 [] 中则无此作用, 只代表它自身\nre.findall(r'aa|bb', 'aacbbcaabbab') ['aa', 'bb', 'aa', 'bb'] re.findall(r'a[|]b', 'ab, a|b') ['a|b'] 2.06, 定义组合匹配 用 () 将多个字符组合成一个整体来匹配, 不管 () 外是否有数量匹配符, 都只返回 () 内的内容, 如果表达式内有多个 () 封装的内容, 匹配结果以元组形式返回\n# 匹配的是 ab 和 abab 但只返回括号内的 ab re.findall(r'(ab)+', 'ab11abab') ['ab', 'ab'] re.findall(r'^(ab)+', 'ab11abab') # 必须 ab 开头 ['ab'] # 匹配的是后面的 abab 返回元组 re.findall(r'(ab)(ab)', 'ab11abab') [('ab', 'ab')] 将贪婪匹配转为非贪婪匹配\n# 贪婪匹配 \\d+ 使得无法将 000 取出 re.findall(r'(\\d+)(0*)$', '123000') [('123000', '')] # + 后面加个 ? 号 re.findall(r'(\\d+?)(0*)$', '123000') [('123', '000')] re.findall(r'[(ab)]', 'ab, (ab)') ['a', 'b', '(', 'a', 'b', ')'] 如果 () 内以 ?: 开头, 只有一组时，返回匹配的字符串，多组则 ?: 开头的不捕获不返回\nre.findall(r'(?:ab)+', 'ab11abab') ['ab', 'abab'] # 匹配的是后面的 abab, 但只返回前一个 () 内的内容 re.findall(r'(ab)(?:ab)+', 'ab11abab') ['ab'] 如果 () 内以 ?= 开头, 则 () 内的内容只是用来匹配, 不返回也不消耗匹配的字符, 也就是说, 匹配完了, 后面的字符需要继续匹配\nre.findall(r'a(?=bc)bc', 'ab, abc, abcde') ['abc', 'abc'] 如果 () 内以 ?! 开头, 则 () 内的内容只是用来排除, 也就是说, 排除括号内的内容都可以匹配, 不占字符, 匹配完了, 后面的字符需要继续匹配\n# a 后面除了 bc 都可以匹配 re.findall(r'a(?!bc)\\w+', 'abc, acb, abde') ['acb', 'abde'] \\number 匹配指定的组合，组合从 1 开始编号\n# \\1 匹配第一个组合 (a) re.findall(r'(a)(\\d+)(\\1)', 'aba1aa34a2') [('a', '1', 'a'), ('a', '34', 'a')] 绝大部分 Python 的标准转义字符也被正则表达式分析器支持:\n\\a \\b \\f \\n \\N \\r \\t \\u \\U \\v \\x \\\\ （注意 \\b 被用于表示词语的边界，它只在 [] 内表示退格，比如 [\\b]）\n2.07, 匹配规则修改标志 介绍几个常用的规则修改标志\nre.I 大小写不敏感匹配\nre.findall(r'aA','aA, aa', re.I) ['aA', 'aa'] re.S 使 . 匹配任何字符, 包括换行符\ns = '''a b, a-b''' re.findall(r'a.b', s, re.S) ['a\\nb', 'a-b'] re.M 使得 ^ 和 $ 能匹配换行的开始或换行前的结束\na = '^b\\d[bc]' b = '''b2c b2b''' re.findall(a, b, re.M) ['b2c', 'b2b'] a = 'a\\d[bc]$' b = '''a2b a2c''' re.findall(a, b, re.M) ['a2b', 'a2c'] 3, 匹配和处理方法 match 从字符串起始位置匹配, 匹配到的字符返回为 match 对象, 可以用方法加以获取\na = re.match(r'ab', 'abc') b = re.match(r'a(bc)d(ef)g', 'abcdefgh') c = re.match(r'ab', 'bab') a \u003cre.Match object; span=(0, 2), match='ab'\u003e b \u003cre.Match object; span=(0, 7), match='abcdefg'\u003e c # group() 获取匹配的全部字符, # group(1) 获取 () 内匹配的第一个, 以此类推 a.group(), b.group(), b.group(1), b.group(2) ('ab', 'abcdefg', 'bc', 'ef') # start 获取匹配开始的位置 a.start(), b.start() (0, 0) # end 获取匹配结束的位置 a.end(), b.end() (2, 7) # span 获取 (开始, 结束) 元组 a.span(), b.span() ((0, 2), (0, 7)) compile 编译正则表达式, 返回一个 Pattern 对象(后面简写为p), 然后可以用该对象调用方法\np = re.compile('\\d+') p re.compile(r'\\d+', re.UNICODE) # 调用上面的 match 方法, 可以指定开始和结束位置 a = p.match('12a21', 3) a \u003cre.Match object; span=(3, 5), match='21'\u003e re.search 扫描整个字符串, 第一个匹配的字符串返回为 match 对象\np.search 扫描指定范围, 不指定就全部扫描\nr = 'python\\d.\\d' s = 'python3.0, python3.8' p = re.compile(r) a = re.search(r, s) b = p.search(s) c = p.search(s, 1) a \u003cre.Match object; span=(0, 9), match='python3.0'\u003e b \u003cre.Match object; span=(0, 9), match='python3.0'\u003e c \u003cre.Match object; span=(11, 20), match='python3.8'\u003e sub 替换字符串中的匹配项, 可以控制替换次数, 还可传入函数高级替换\nr = '[,.]' s = '去掉,逗号和.句号.' p = re.compile(r) re.sub(p, '', s) '去掉逗号和句号' p.sub('', s, 1) '去掉逗号和.句号.' findall 已经介绍过\nr = r'\\D+(\\d+)\\D+(\\d+)\\D+(\\d+)*' s = '分组提取123所有456数字78.' p = re.compile(r) re.findall(p, s) [('123', '456', '78')] p.findall(s, 8) [('456', '78', '')] finditer 和 findall类似, 只是返回的是一个 match 迭代器\nimport re r = r'\\D+(\\d+)\\D+(\\d+)\\D+(\\d+)*' s = '分组提取123所有456数字78.' p = re.compile(r) a = re.finditer(p, s) b = p.finditer(s, 8) a \u003ccallable_iterator at 0x18d4fa31460\u003e b \u003ccallable_iterator at 0x18d4fa31430\u003e for i, j in zip(a, b): print(i) print(j) print(i.group(1, 2, 3)) print(j.group(1, 2, 3)) \u003cre.Match object; span=(0, 16), match='分组提取123所有456数字78'\u003e \u003cre.Match object; span=(8, 17), match='有456数字78.'\u003e ('123', '456', '78') ('456', '78', None) split 用匹配到的字符(或字符串), 将整个字符串分割返回列表, 可设置最大拆分数\nr = '[\\s\\,-]' s = '将,每 个-字 拆,开' p = re.compile(r) re.split(p, s) ['将', '每', '个', '字', '拆', '开'] p.split(s, 2) ['将', '每', '个-字 拆,开'] jupyter附件 regex.ipynb (32 KB) ",
    "description": "",
    "tags": null,
    "title": "通俗易懂 Python 正则表达式",
    "uri": "/regex/"
  },
  {
    "content": "推断统计, 通过样本推断总体的统计方法, 包括对总体的未知参数进行估计; 对关于参数的假设进行检查; 对总体进行预测预报等. 推断统计的基本问题可以分为两大类：一类是 参数估计 问题; 另一类是 假设检验 问题\n1, 总体, 个体与样本 总体, 要研究对象的所有数据, 获取通常比较困难. 总体中的某个数据, 就是个体. 从总体中抽取部分个体, 就构成了样本, 样本中的个体数, 称为样本容量.\n2, 参数估计 参数估计, 用样本指标(统计量)估计总体指标(参数). 参数估计有 点估计 和 区间估计 两种\n2.01, 点估计 点估计是依据样本统计量估计总体中的未知参数. 通常它们是总体的某个特征值，如数学期望, 方差和相关系数等. 点估计问题就是要构造一个只依赖于样本的量，作为总体未知参数的估计值.\n2.02, 区间估计 区间估计是根据样本的统计量, 计算出一个可能的区间(置信区间) 和 概率(置信度), 表示总体的未知参数有多少概率位于该区间.\n注意:\n点估计使用一个值来作为总体参数值, 能给出具体值, 但易受随机抽样影响, 准确性不够\n区间估计使用一个置信区间和置信度, 表示总体参数值有多少可能(置信度)会在该范围(置信区间)内, 能给出合理的范围和信心指数, 不能给出具体值\n2.03, 中心极限定理 要确定置信区间与置信度, 我们先要知道总体与样本之间, 在分布上有着怎样的联系. 中心极限定理(独立同分布的中心极限定理)给出了它们之间的联系:\n如果总体均值为 $\\mu$, 方差为 $\\sigma^{2}$, 我们进行随机抽样, 样本容量为 n, 当 n 增大时，则样本均值 $\\bar{X}$ 逐渐趋近服从均值为 $\\mu$, 方差为 $\\sigma^{2} / n$ 的正态分布：\n$$\\bar{X} \\sim N\\left(\\mu, \\sigma^{2} / n\\right)$$说明:\n进行多次抽样，每次抽样会得到一个均值, 这些均值会围绕在总体均值左右，呈正态分布\n当样本容量 n 足够大时, 抽样样本均值的均值 ≈ 样本均值 $\\bar{X}$ ≈ 总体均值 $\\mu$, 样本均值分布的标准差等于 $\\sigma / \\sqrt{n}$\n样本均值分布的标准差, 称为标准误差, 简称标准误\n模拟证明:\nimport numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns plt.rcParams['font.family'] = 'SimHei' plt.rcParams['axes.unicode_minus'] = False # 定义非正态分布总体(也可以是正态分布) data = np.random.normal(20, 5, size=10000) data.sort() all_ = np.random.choice(data[0:8000], size=10000) # sns.displot(all_) # 将总体的均值和标准差设为已知条件 print('总体均值:', all_.mean(), '总体标准差:', all_.std()) # 创建存放每次抽样的平均值的数组(初始值为 0) mean_arr = np.zeros(1000) # 循环抽取 1000 个样本, 每次抽 100 个 for i in range(len(mean_arr)): mean_arr[i] = np.random.choice(all_, size=100, replace=False).mean() # 验证结果 print('样本均值:', mean_arr[1], '样本均值的均值:', mean_arr.mean(), '标准误差:', mean_arr.std(), '偏度:', pd.Series(mean_arr).skew(), sep='\\n') sns.displot(mean_arr, kde=True) plt.show() 总体均值: 18.270423532980452 总体标准差: 3.8201265113791596 样本均值: 18.194948520041606 样本均值的均值: 18.26385715935595 标准误差: 0.373202226318143 偏度: 0.00746666188264042 2.04, 正态分布的特性 正态分布: $X \\sim N\\left(\\mu, \\sigma^{2}\\right)$\n以均值为中心:\n在 1 倍标准差内包含约 68.2% 的样本数据\n在 2 倍标准差内包含约 95.4% 的样本数据\n在 3 倍标准差内包含约 99.7% 的样本数据\n证明:\n# 定义标准差 scale = 10 # 定义数据 x = np.random.normal(0, scale, size=100000) # 计算 for times in range(1, 4): y = x[(x \u003e -times * scale) \u0026 (x \u003c times * scale)] print(f'{times}倍的标准差:') print(f'{len(y) * 100 / len(x)}%') 1倍的标准差: 68.206% 2倍的标准差: 95.354% 3倍的标准差: 99.711% 2.05, 重要结论 根据中心极限定理和正态分布的特性, 如果总体标准差为 $\\sigma$, 对总体进行一次抽样, 如果样本足够大, 则样品均值 $\\bar{X}$ 服从正态分布, 该均值约有 95.4% 的概率会在 2 倍的标准误差 ( $\\mu - 2\\sigma / \\sqrt{n}, \\mu + 2\\sigma / \\sqrt{n}$) 范围内, 并且该样本均值约等于总体均值 $\\mu$. 从而, 可以利用这一结论, 对总体均值进行区间估计.\n结论验证:\n# 随机生成总体均值, 其值未知 mean = np.random.randint(0, 10000) # 总体的标准差已知为 50 std = 50 # 定义总体数据 all_ = np.random.normal(mean, std, size=100000) # 从总体抽取 100 个元素构成样本 sample = np.random.choice(all_, size=100, replace=False) # 计算样本均值 sample_mean = sample.mean() print('样本均值:', sample_mean) # 计算样本的标准误差 se = std / np.sqrt(n) # 计算置信区间 95%置信度 min_ = sample_mean - 1.96 * se max_ = sample_mean + 1.96 * se print('置信区间(95%置信度):', (min_, max_)) # 区间估计 print(f'总体均值有 95% 的概率在{(min_, max_)}区间内') print('总体均值:', mean) # 绘图辅助 plt.plot(mean, 0, marker='*', color='orange', ms=12, label='总体均值') plt.plot(sample_mean, 0, marker='o', color='r', label='样本均值') plt.hlines(0, xmin=min_, xmax=max_, color='b', label='置信区间') plt.axvline(min_, 0.4, 0.6, color='r', ls='--', label='左边界') plt.axvline(max_, 0.4, 0.6, color='g', ls='--', label='右边界') plt.legend() plt.show() 样本均值: 9695.658932218576 置信区间(95%置信度): (9685.858932218576, 9705.458932218575) 总体均值有 95% 的概率在(9685.858932218576, 9705.458932218575)区间内 总体均值: 9696 3, 假设检验 假设检验(显著性检验), 先对总体做出假设, 然后通过判断样本与总体之间是否存在显著性差异, 来验证总体的假设\n假设检验使用了一种类似于 “反证法” 的推理方法，它的特点是：\n先对总体做出两个完全相反的假设, 原假设(设为真) 和 备择假设, 计算后导致不合理现象产生，则拒绝原假设, 接受备择假设, 反之接受原假设, 放弃备择假设\n这种 “反证法” 不同于一般的反证法. 所谓不合理现象产生，并非指形式逻辑上的绝对矛盾，而是基于小概率原理：概率很小的事件在一次试验中几乎是不可能发生的，若发生了，就是不合理的.\n怎样才算 “小概率”, 通常可将概率不超过 0.05 的事件称为 “小概率事件” ，也可视具体情形而取 0.1 或 0.01 等. 在假设检验中常记这个概率为 α，称为显著性水平\n假设检验可分为正态分布检验, 正态总体均值检验, 非参数检验三类, 本文只介绍 正态总体均值检验 , 包括 Z检验 和 t检验 两种情况\n3.01, 关键概念: 对总体参数做出两个完全对立的假设, 分别为:\n原假设(零假设) $H_{0}$\n备择假设(对立假设) $H_{1}$\n双边假设检验 :\n$H_{0}: \\mu=\\mu_{0}, H_{1}: \\mu \\neq \\mu_{0}$\n单边假设检验 :\n$H_{0}: \\mu \\geq \\mu_{0}, H_{1}: \\mu\u003c\\mu_{0}$ (左边检验)\n$H_{0}: \\mu \\leq \\mu_{0}, H_{1}: \\mu\u003e\\mu_{0}$ ( 右边检验 )\n$\\mu$ 为总体均值, $\\mu_{0}$ 为假设均值\n显著性水平 : 根据需要设定的小概率事件的概率 α (1 - α 为置信度)\n检验统计量 (Z 和 t): 用来判断样本均值与总体均值是否存在显著性差异\nP值: 通过检验统计量计算而得的概率值, 表示原假设可被拒绝的最小值(或可支持原假设的概率):\nP ≤ α, 原假设可被拒绝的最小值比显著性水平还低, 原假设可被拒绝, 则拒绝原假设\nP \u003e α, 原假设可被拒绝的最小值大于显著性水平, 原假设不可被拒绝, 支持原假设\n3.02, 假设检验的步骤 设置原假设与备择假设\n设置显著性水平 α\n根据问题选择假设检验的方式\n计算统计量(Z 或 t)\n计算 P值(Z 或 t 围成的分布面积)\n根据 P值 与 α值, 决定接受原假设还是备择假设\n例, 某车间用一台包装机包装葡萄糖. 袋装糖的净重是一个随机变量，它服从正态分布. 当机器正常时，其均值为 0.5kg，标准差为 0.015kg. 某日开工后为检验包装机是否正常，随机地抽取它所包装的糖 9 袋，称得净重为(kg):\n0.497, 0.506, 0.518, 0.524, 0.498, 0.511, 0.520, 0.515, 0.512\n判断下面说法是否正确:\n(1) 机器正常\n例, 某车间用包装机包装葡萄糖. 袋装糖的净重是一个随机变量，它服从正态分布. 随机地抽取糖 9 袋，称得净重为(kg):\n0.497, 0.506, 0.518, 0.524, 0.498, 0.511, 0.520, 0.515, 0.512\n判断下面说法是否正确:\n(2) 该车间袋装糖净重均值为 0.5kg\n(3) 该车间袋装糖净重均值不少于 0.5kg\n(4) 该车间袋装糖净重均值不多于 0.5kg\n3.03, Z检验 Z检验适用于: 总体正态分布且方差已知, 样本容量较大(一般 ≥ 30)\nZ统计量计算公式:\n$$Z=\\frac{\\bar{x}-\\mu_{0}}{S_{\\bar{x}}}=\\frac{\\bar{x}-\\mu_{0}}{\\sigma / \\sqrt{n}}$$ $\\bar{x}$: 样本均值\n$\\mu_{0}$: 假设的总体均值\n$S_{\\bar{x}}$: 样本的标准误差\n$\\sigma$: 总体的标准差\n$n$: 样本容量\n检验说法(1): 机器正常\n双边检验:\n原假设机器正常: $H_{0}: \\mu=\\mu_{0}=0.5kg$\n备择假设机器不正常: $H_{1}: \\mu \\neq \\mu_{0} \\neq 0.5kg$\n设置显著性水平: α = 0.05\nimport numpy as np from scipy import stats # 样本已知 a = np.array([0.497, 0.506, 0.518, 0.524, 0.498, 0.511, 0.520, 0.515, 0.512]) # 总体均值和标准差已知 mean, std = 0.5, 0.015 # 计算样本均值 sample_mean = a.mean() # 计算样本标准误差 se = std / np.sqrt(len(a)) # 计算 Z统计量 Z = (sample_mean - mean) / se print('Z统计量:', Z) # 计算 P值, 双边检验: Z值与其右边曲线围成的面积的 2 倍 P = 2 * stats.norm.sf(abs(Z)) print('P值:' , P) Z统计量: 2.244444444444471 P值: 0.02480381963225589 由结果可知, Z值 超过了 1.96, 由 Z值 与其右边曲线围成的面积的 2 倍, 必然小于 α(1.96 与其右边曲线围成的面积的 2 倍), 计算结果 P \u003c α, 因此拒绝原假设, 接受备择假设, 机器不正常\n3.04, t检验 t检验适用于: 总体正态分布, 方差未知, 样本数量较少(一般 \u003c 30), 但是随着样本容量的增加, 分布逐渐趋于正态分布\nt统计量计算公式:\n$$t=\\frac{\\bar{x}-\\mu_{0}}{S_{\\bar{x}}}=\\frac{\\bar{x}-\\mu_{0}}{S / \\sqrt{n}}$$ $\\bar{x}$: 样本均值\n$\\mu_{0}$: 假设的总体均值\n$S_{\\bar{x}}$: 样本的标准误差\n$S$: 样本的标准差\n$n$: 样本容量\n双边检验 :\n检验说法(2): 该车间袋装糖净重均值为 0.5kg\n原假设, 该车间袋装糖净重均值为 0.5kg: $H_{0}: \\mu=\\mu_{0}=0.5kg$\n备择假设, 该车间袋装糖净重均值不为 0.5kg: $H_{1}: \\mu \\neq \\mu_{0} \\neq 0.5kg$\n设置显著性水平: α = 0.05\n# 样本已知 a = np.array([0.497, 0.506, 0.518, 0.524, 0.498, 0.511, 0.520, 0.515, 0.512]) # 假设的总体均值已知 mean = 0.5 # 计算样本均值 sample_mean = a.mean() # 计算样本标准差 std = a.std() # 计算 t统计量 t = (sample_mean - mean) / ( std / np.sqrt(len(a))) print('t统计量:', t) # 计算 P值, df 是自由度: 样本变量可自由取值的个数 P = 2 * stats.t.sf(abs(t), df=len(a) - 1) print('P值:', P) t统计量: 3.802382179137283 P值: 0.005218925008708613 P \u003c α, 拒绝原假设, 接受备择假设: 该车间袋装糖净重均值不为 0.5kg\n还可以通过 scipy 提供的方法 ttest_1samp 来进行 t检验计算:\nfrom scipy import stats stats.ttest_1samp(a, 0.5) Ttest_1sampResult(statistic=3.584920298041139, pvalue=0.007137006417828698) 左边检验 :\n检验说法(3): 该车间袋装糖净重均值不少于 0.5kg\n原假设, 该车间袋装糖净重均值不少于 0.5kg: $H_{0}: \\mu \\geq \\mu_{0}$\n备择假设, 该车间袋装糖净重均值少于 0.5kg: $H_{1}: \\mu\u003c\\mu_{0}$\n设置显著性水平: α = 0.05\n# t统计量上述已经计算, 只需计算 P值: t统计量与其左边曲线围成的面积 P = stats.t.cdf(t, df=len(a) - 1) print('P值:', P) P值: 0.9973905374956458 P \u003e α, 接受原假设, 该车间袋装糖净重均值不少于 0.5kg\n右边检验 :\n检验说法(4): 该车间袋装糖净重均值不多于 0.5kg\n原假设, 该车间袋装糖净重均值不多于 0.5kg: $H_{0}: \\mu \\leq \\mu_{0}$\n备择假设, 该车间袋装糖净重均值多于 0.5kg: $H_{1}: \\mu\u003e\\mu_{0}$\n设置显著性水平: α = 0.05\n# 计算 P值: t统计量与其右边曲线围成的面积 P = stats.t.sf(t, df=len(a) - 1) print('P值:', P) P值: 0.0026094625043543065 P \u003c α, 拒绝原假设, 接受备择假设, 该车间袋装糖净重均值多于 0.5kg\n",
    "description": "",
    "tags": null,
    "title": "推断统计",
    "uri": "/statistics/statistics2/"
  },
  {
    "content": "打开方式不同，会创建不同类型的文件对象（流），不同类型的文件对象，可能有不同的属性或方法。\n打开模式不同，写入内容的方式也会不同，详见 open() 打开文件。\n下列检查或写入内容的属性或方法，是多数文件对象通用的：\nwritable() 如果流支持写入则返回 True。如为 False，则 write() 将引发 OSError。 f = open('test.txt','a',encoding='utf-8') f.writable() True\rf = open('test.txt') f.writable() f.write('这世界进步得太快，') ---------------------------------------------------------------------------\rUnsupportedOperation Traceback (most recent call last)\r\u003cipython-input-1-7bf449cf8958\u003e in \u003cmodule\u003e\r1 f = open('test.txt')\r2 f.writable()\r----\u003e 3 f.write('这世界进步得太快，')\rUnsupportedOperation: not writable\rwrite() 将字符串或字节串写入到流并返回写入的字符或字节数。对于阻塞流（需要刷新才能将内容写入文件），写入内容在缓冲区（打开文件看不到写入的内容）。 f = open('test.txt','a+',encoding='utf-8') f.write('\\n这世界进步得太快，') 10\rflush() 刷新流的写入缓冲区（打开文件将看到写入的内容）。这对只读和非阻塞流不起作用。 f.flush() writelines(lines) 将行列表写入到流。不会添加行分隔符，因此通常所提供的每一行都带有末尾行分隔符。对于阻塞流，写入内容在缓冲区。 f = open('test.txt','a+',encoding='utf-8') f.writelines(['\\n没有自学能力，\\n', '没有未来。']) f.tell() # 流的位置在末尾 137\rf.read() # 从末尾读取内容为空 ''\rf.seek(0, 0) # 重设流的位置为开头 0\rf.read() '为什么一定要掌握自学能力？\\n未来的日子还很长，\\n这世界进步得太快，\\n没有自学能力，\\n没有未来。'\rclosed 如果流已关闭，则返回 True。 f.closed False\rclose() 刷新并关闭此流。无论读写操作，最后都应该关闭流。如果文件已经关闭，则此方法无效。文件关闭后，对文件的任何操作（例如读取或写入）都会引发 ValueError 。为方便起见，允许多次调用此方法。但是，只有第一个调用才会生效。 f.close() f.close() f.closed True\r",
    "description": "",
    "tags": null,
    "title": "文件写入内容",
    "uri": "/python/14_file/03_write/"
  },
  {
    "content": "序列类型都可以使用下标进行索引或切片取值，这是序列类型通用操作。可变序列类型比较特殊，例如列表，可以利用索引或切片进行元素增、删、改，详见 列表的索引和切片。\n下标从前往后，则以 0 开始，从后往前，则从 -1 开始，双向索引：\n('a', 'b', 'c', 'd')\r0 1 2 3\r-4 -3 -2 -1 下标索引，直接取出对应索引下的值，超出范围则报错：\na = [1,2,3,4] a[10] ---------------------------------------------------------------------------\rIndexError Traceback (most recent call last)\r\u003cipython-input-18-5680bb375980\u003e in \u003cmodule\u003e\r1 a = [1,2,3,4]\r----\u003e 2 a[10]\rIndexError: list index out of range\ra = [1,2,3,4] a[0], a[-2] (1, 3)\r下标切片取值规则：[起始:结束:步长]，不包含结束。\n没有指定起始，则默认为 0； 没有指定结束则默认到最后一个元素结束； 下标可以双向混合使用； 没有指定步长，则默认为 1； 步长为负数，则反向取值，-1 开始。 a = [1,2,3,4,5,6,7] a[:3] [1, 2, 3]\ra = [1,2,3,4,5,6,7] a[3:] [4, 5, 6, 7]\ra = [1,2,3,4,5,6,7] a[1:-3], a[-6:4] ([2, 3, 4], [2, 3, 4])\ra = [1,2,3,4,5,6,7] a[::2] [1, 3, 5, 7]\ra = [1,2,3,4,5,6,7] a[::-2] # 默认 -1 开始取 [7, 5, 3, 1]\ra = [1,2,3,4,5,6,7] a[0:7:-2] []\ra = [1,2,3,4,5,6,7] a[-1:0:-2] [7, 5, 3]\r切片范围可以无限大，范围内没有元素，则得到空的容器：\na = [1,2,3,4,5,6,7] a[5:100], a[1:1], a[5:-10] ([6, 7], [], [])\r",
    "description": "",
    "tags": null,
    "title": "序列索引和切片",
    "uri": "/python/05_sequence/03_index_slice/"
  },
  {
    "content": "转义字符 \\ 本身不被当作字符，如果要表示一个字符 \\，需要自己将自己转义：\n'\\\\' '\\\\'\r'\\' File \"\u003cipython-input-2-d44a383620ab\u003e\", line 1\r'\\'\r^\rSyntaxError: EOL while scanning string literal\r上面这一行报错信息是 SyntaxError: EOL while scanning string literal。这是因为 \\' 表示的是单引号字符 '（Literal）—— 是可被输出到屏幕的 '，而不是用来标示字符串的那个 '—— 别急，无论哪个初学者第一次读到前面的句子都觉得有点莫名其妙…… —— 于是，Python 编译器扫描这个 “字符串” 的时候，还没找到标示字符串末尾的另外一个 ' 的时候就读到了 EOL（End Of Line）。\n如果你想输出这么个字符串，He said, it’s fine.，如果用双引号扩起来 \" 倒没啥问题，但是如果用单引号扩起来就麻烦了，因为编译器会把 it 后面的那个单引号 ' 当作字符串结尾。\n'He said, it's fine.' File \"\u003cipython-input-3-2bcf2ca6dd95\u003e\", line 1\r'He said, it's fine.'\r^\rSyntaxError: invalid syntax\r于是你就得用转义符 \\：\n# 要么你这么写： print('He said, it\\'s fine.') # 要么你这么写： print(\"He said, it's fine.\") # 要么，不管用单引号还是双引号标示字符串， # 都习惯于用 \\' 和 \\\" 书写属于字符串内部的引号…… \"He said, it\\'s fine.\" He said, it's fine.\rHe said, it's fine.\r\"He said, it's fine.\"\r转义字符 \\ 可与其他字符组合成有特殊含义的字符：\n转义字符 说明 \\(在行尾时) 续行符 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 响铃 \\b 退格 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\yy 八进制数 yy 码位的字符 \\xyy 十六进制数 yy 码位的字符 续航符，可以将两行代码（或字符串）连接起来，表示一行：\nfor i in \\ range(3): # 两行相当于 for i in range(10): print(i) 0\r1\r2\r'hello \\ world' 'hello world'\r八进制和十六进制字符举例：\n# 八进制字符 '\\101', '\\102' ('A', 'B')\r# 十六进制字符 '\\x41', '\\x42' ('A', 'B')\r# 十进制 chr(65),chr(66) ('A', 'B')\r在正则表达式中，转义字符 \\ 的应用更加普遍。详情请看《正则指引》。\n",
    "description": "",
    "tags": null,
    "title": "转义字符",
    "uri": "/python/02_string/03_escape_character/"
  },
  {
    "content": "字符串概述 Python 中处理文本数据使用 str 类型对象，也称为字符串。\ntype('abc') str\r字符串是由 Unicode 码位构成的不可变序列。每个字符的 Unicode 码位可由内建函数 ord() 查看：\nord('a'), ord('b'), ord('c') (97, 98, 99)\r内建函数 str() 可将其他类型对象转换为字符串：\nstr(3.14) '3.14'\r字符串有多种不同写法：\n单引号标示 单引号标示法，如果字符串中有单引号，需要用 \\' 表示：\n'it\\'s a book' \"it's a book\"\r双引号标示 双引号标示法，如果字符串中有双引号，需要用 \\\" 表示：\n\"it's a \\\"book\\\"\" 'it\\'s a \"book\"'\r三重引号标示 三重引号标示法，可以是三重单引号 '''，也可以是三重双引号 \"\"\"，字符串中的单引号或双引号不受影响，但不能紧挨着：\n# 注意最后四个双引号中有一个空格 '''it's a book''', \\ \"\"\"it's a \"book\" \"\"\" (\"it's a book\", 'it\\'s a \"book\" ')\r三重引号标示的字符串可以换行，自动以 \\n 表示：\n''' it's a book ''' \"\\nit's a \\nbook\\n\"\r若不想引入 \\n，可以使用续航符 \\：\n'''\\ it's a \\ book\\ ''' \"it's a book\"\r字符串可带前缀 u（或 U），r（或 R），f（或 F）。\nu 表示 Unicode 编码字符串（默认，可省略）；r 表示原始字符串，其中的反斜杠会被当作其本身来处理；f 表示格式化字符串字面值。r 和 f 可连用。\n'a\\nb{1+1}' 'a\\nb{1+1}'\rr'a\\nb{1+1}' 'a\\\\nb{1+1}'\rf'a\\nb{1+1}' 'a\\nb2'\rrf'a\\nb{1+1}' 'a\\\\nb2'\r注意带前缀 b（或 B），表示字节串对象：\ntype(b'abc') bytes\r字符串是不可变序列，下列切片操作得到的是原来的字符串：\na = 'abc' b = a[:] a is b True\rjupyter附件 01_string.ipynb (7 KB) 02_concatenated_string.ipynb (3 KB) 03_escape_character.ipynb (7 KB) 04_str.count.ipynb (3 KB) 05_str.replace.ipynb (3 KB) 06_str.expandtabs.ipynb (3 KB) 07_str.split.ipynb (4 KB) 08_str.rsplit.ipynb (3 KB) 09_str.partition.ipynb (2 KB) 10_str.rpartition.ipynb (3 KB) 11_str.splitlines.ipynb (4 KB) 12_str.strip.ipynb (2 KB) 13_str.lstrip.ipynb (2 KB) 14_str.rstrip.ipynb (2 KB) 15_str.find.ipynb (3 KB) 16_str.rfind.ipynb (3 KB) 17_str.index.ipynb (4 KB) 18_str.rindex.ipynb (4 KB) 19_str.join.ipynb (4 KB) 20_str.startswith.ipynb (3 KB) 21_str.endswith.ipynb (3 KB) 22_str.ljust.ipynb (2 KB) 23_str.center.ipynb (2 KB) 24_str.rjust.ipynb (2 KB) 25_str.format.ipynb (14 KB) 26_str.format_map.ipynb (3 KB) 27_f-string.ipynb (7 KB) 28_string_operators.ipynb (9 KB) 29_str.encode.ipynb (6 KB) 30_str.capitalize.ipynb (2 KB) 31_str.casefold.ipynb (2 KB) 32_str.lower.ipynb (2 KB) 33_str.title.ipynb (2 KB) 34_str.upper.ipynb (1 KB) 35_str.swapcase.ipynb (3 KB) 36_str.zfill.ipynb (2 KB) 37_str.translate.ipynb (4 KB) 38_str.maketrans.ipynb (4 KB) 39_str.isalnum.ipynb (2 KB) 40_str.isalpha.ipynb (3 KB) 41_str.isdecimal.ipynb (4 KB) 42_str.isdigit.ipynb (3 KB) 43_str.isnumeric.ipynb (3 KB) 44_str.islower.ipynb (2 KB) 45_str.isupper.ipynb (2 KB) 46_str.istitle.ipynb (2 KB) 47_str.isascii.ipynb (2 KB) 48_str.isidentifier.ipynb (3 KB) 49_str.isprintable.ipynb (3 KB) 50_str.isspace.ipynb (2 KB) 51_str.removeprefix.ipynb (1 KB) 52_str.removesuffix.ipynb (1 KB) ",
    "description": "",
    "tags": null,
    "title": "字符串概述",
    "uri": "/python/02_string/"
  },
  {
    "content": "内置函数 ascii()，Python 官方文档描述如下：\nhelp(ascii) Help on built-in function ascii in module builtins:\rascii(obj, /)\rReturn an ASCII-only representation of an object.\rAs repr(), return a string containing a printable representation of an\robject, but escape the non-ASCII characters in the string returned by\rrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\rto that returned by repr() in Python 2.\r就像函数 repr()，返回一个对象可打印的字符串，但是非 ASCII 编码的字符，会使用 \\x、\\u 和 \\U 来转义。\nascii(123) '123'\rascii(None) 'None'\rascii('python') \"'python'\"\rascii('嗨') \"'\\\\u55e8'\"\rrepr('嗨') \"'嗨'\"\r'\\u55e8' # 16 位十六进制数 55e8 码位的字符 '嗨'\r",
    "description": "",
    "tags": null,
    "title": "ascii() 返回对象的可打印字符串",
    "uri": "/python/11_built-in_function/04_ascii/"
  },
  {
    "content": "字典方法 dict.items()，Python 官方文档描述如下：\nhelp(dict.items) Help on method_descriptor:\ritems(...)\rD.items() -\u003e a set-like object providing a view on D's items\r返回字典的 (键,值) 元组组成的动态视图。字典的视图支持成员检测，可以被迭代。\nd = {'a':1, 'b':2} d_view = d.items() print(d_view) d['c'] = 3 # 添加元素，视图也动态变化 print(d_view) dict_items([('a', 1), ('b', 2)])\rdict_items([('a', 1), ('b', 2), ('c', 3)])\r('a', 1) in d_view True\r[k*j for k, j in d_view] ['a', 'bb', 'ccc']\r",
    "description": "",
    "tags": null,
    "title": "dict.items 键值对视图",
    "uri": "/python/07_dictionary/04_dict.items/"
  },
  {
    "content": "for 语句用于对可迭代对象中的元素进行迭代。语法如下：\nfor target_list in expression_list:\rsuite\relse: # 可选子句\rsuite 对于简单语句可以写为一行，但不推荐。\n表达式 expression_list 被求值一次，它应该产生一个可迭代对象。系统将为 expression_list 的结果创建一个迭代器，然后每一项会按标准赋值规则（详见见 赋值语句）被依次赋值给 target_list，每赋值一次执行一次语句下的代码。\n当所有项被耗尽时，else 子句如果存在将会被执行，并终止循环。\nfor i in range(3):print(i) 0\r1\r2\rfor i in zip('123','abc'): print(i) ('1', 'a')\r('2', 'b')\r('3', 'c')\rfor i,j in zip('123','abc'): print(f'{i}-\u003e{j}') else: print('end') 1-\u003ea\r2-\u003eb\r3-\u003ec\rend\rfor 循环会对 target_list 中的变量进行赋值。这将覆盖之前对这些变量的所有赋值，包括在 for 循环体中的赋值。\n变量在循环结束时不会被删除，但如果序列为空，则它们根本不会被循环所赋值。\ni = 'a' for i in range(3): print(i) print(i) 0\r1\r2\r2\rfor i in range(0): print(i) print(i) 2\r",
    "description": "",
    "tags": null,
    "title": "for",
    "uri": "/python/10_statement/04_for/"
  },
  {
    "content": "列表方法 list.clear()，Python 官方文档描述如下：\nhelp(list.clear) Help on method_descriptor:\rclear(self, /)\rRemove all items from list.\r删除列表中所有的元素。相当于 del a[:]（a 是列表）。\n_list = [1,2,3] _list.clear() _list []\rdel a[:] 是删除列表 a 中的所有元素，和 a 的浅拷贝无关：\na = [1,2,3] b = a[:] del a[:] a, b ([], [1, 2, 3])\r该方法是一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 None), 直接对原列表进行修改：\n_list = [1,2,3] a = _list.clear() print(a) None\r",
    "description": "",
    "tags": null,
    "title": "list.clear 删除所有元素",
    "uri": "/python/03_list/15_list.clear/"
  },
  {
    "content": "官方文档\nnumpy 是 python 的强大科学计算库, 它让 python 处理数据, 进行科学计算变得极其便捷, 高效\n一, N 维数组 ndarray 对象 1, ndaraay 介绍 ndarray 是具有相同类型和大小的项目的多维容器, 它的数据存储效率和输入输出性能远远优于 python 中等价的数据结构\n1.01, 理解 ndarray 创建 ndarray: np.array(), np.ndarray(), 下面只介绍 3 维以下数组, 理解它们的结构\nimport numpy as np # 一维 a = np.array((2,3)) # 二维，2 行 3 列 b = np.ndarray((2,3)) a array([2, 3]) b array([[0., 0., 0.], [0., 0., 0.]]) a.dtype, b.dtype # 类型 (dtype('int32'), dtype('float64')) c = np.array((1,'2')) c array(['1', '2'], dtype='\u003cU11') type(c), type(c[0]) (numpy.ndarray, numpy.str_) 可见, ndarray 对象中的元素类型只有一种, 如上例，都统一成 Unicode, 元素位长是 11, 所以说 ndarray 是一个具有相同类型和大小的项目的多维容器\n一维就是一行，二维就像一个表格, 横着是一行, 竖着是一列\n# 三维 np.ndarray((3, 3, 3)) array([[[6.23042070e-307, 7.56587584e-307, 1.37961302e-306], [6.23053614e-307, 6.23053954e-307, 9.34609790e-307], [8.45593934e-307, 9.34600963e-307, 9.34598925e-307]], [[1.42418715e-306, 1.95819401e-306, 1.37961370e-306], [6.23054633e-307, 9.34598926e-307, 6.89804132e-307], [9.34598926e-307, 8.01091099e-307, 1.24610927e-306]], [[8.90094053e-307, 1.02361342e-306, 7.56593017e-307], [1.60219035e-306, 8.90111708e-307, 6.89806849e-307], [9.34601642e-307, 1.42410974e-306, 5.97819431e-322]]]) 三维类似一个 excel 文件里的多个表格\n1.02, ndarray 对象计算的优势 用实例来对比利用 ndarray 进行计算的优势\nimport random import time # 假设有如下列表和 array, 使其中每个数都变成它的平方 a1 = [random.random() for i in range(100000000)] # a2 = np.array(a1) t1 = time.time() b = [i**2 for i in a1] t2 = time.time() a2 = np.array(a1) c = a2**2 t3 = time.time() print(t2 - t1, t3 - t2, sep='\\n') 15.133688688278198 4.770834445953369 差距非常明显(如果 a2 在计算之前就已经是 ndarray 对象会更明显), numpy 有其自身机制(广播)实现快速计算\n1.03, ndarray 的数据类型和常量 ndarray 对象数据的数据类型有 bool, int, float, U(字符串), O(python 对象)等, 查看数据类型用 dtype\nimport numpy as np a = np.array([1, 'a', np.nan]) a.dtype, a[0].dtype, a[2].dtype (dtype('\u003cU32'), dtype('\u003cU1'), dtype('\u003cU3')) np.array(True).dtype dtype('bool') np.array(123456).dtype dtype('int32') np.array(3.1415926).dtype dtype('float64') np.array(list).dtype dtype('O') ndarray 对象数据的常量有 pi, e, nan (空值), inf (无穷大)等\nnp.pi 3.141592653589793 np.e 2.718281828459045 np.nan nan np.inf inf 2, ndarray 的属性 常用 ndarray 对象的属性\na = np.array([[1, 2, 3], [4, 5, 6]]) a array([[1, 2, 3], [4, 5, 6]]) 查看数组形状 (行, 列), 这在数据处理和计算时非常有用, 例如遍历出所有行或列\na.shape (2, 3) # 遍历所有列 for i in range(a.shape[1]): print(a[:, i]) [1 4] [2 5] [3 6] 查看数组维度\na.ndim 2 查看数组元素个数\na.size 6 查看数组类型\na.dtype dtype('int32') 查看数组元素的大小, 字节为单位\na.itemsize 4 数组转置, 就是行列互换\na.T array([[1, 4], [2, 5], [3, 6]]) 二, ndarray 对象的切片操作 1, 切片取值 ndarray 的切片操作和 python 类似, 一维切片 [起始:结束:步长], 二维的切片 [起始行:结束行:步长, 起始列:结束列:步长] 或 [[行, ...], [列, ...]]\na = np.arange(20) a.shape = (4, 5) a array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]) # 第一行的第 1, 3, 5 个数 a[0][0::2] array([0, 2, 4]) a[2, 3] 13 a[0:2, 1:5] array([[1, 2, 3, 4], [6, 7, 8, 9]]) a[0:3:2, 0:4:2] array([[ 0, 2], [10, 12]]) a[[1, 3], 0:3] array([[ 5, 6, 7], [15, 16, 17]]) 还可以通过逻辑运算取值\n# 取出数组中的数翻倍之后小于 15 的数 # 结果展开为 1 维 a[a * 2 \u003c 15] array([0, 1, 2, 3, 4, 5, 6, 7]) # \u0026 与 a[(a \u003c 5) \u0026 (a \u003e 1)] array([2, 3, 4]) # | 或 a[(a \u003c 3) | (a \u003e 15)] array([ 0, 1, 2, 16, 17, 18, 19]) # ~ 非 a[~ (a \u003e 3)] array([0, 1, 2, 3]) 2, 利用切片修改值 切片修改值, 其实就是将取到的值重新赋值\na[~ (a \u003e 3)] = 1 a array([[ 1, 1, 1, 1, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]) # 将 1 修改为 nan, nan 是 float 类型, # 保证类型一致性, 需要将 a 转为 float a = a.astype(float) a[a == 1] = np.nan a array([[nan, nan, nan, nan, 4.], [ 5., 6., 7., 8., 9.], [10., 11., 12., 13., 14.], [15., 16., 17., 18., 19.]]) # 任何 nan 都不等于 nan, # 利用此特性取 nan, 或非 nan 的数 a[a != a], a[a == a] (array([nan, nan, nan, nan]), array([ 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19.])) # 交换行, 交换列 a[[0, 3], :] = a[[3, 0], :] a[:, [4, 0]] = a[:, [0, 4]] a array([[19., 16., 17., 18., 15.], [ 9., 6., 7., 8., 5.], [14., 11., 12., 13., 10.], [ 4., nan, nan, nan, nan]]) 三, ndarray 对象的运算及其方法 1, ndarray 的运算 numpy 在运算时, 会通过广播机制, 将运算相对应到每个元素上:\n数和数组计算, 数会和数组中的每一个元素进行计算\n# 方法 reshape 用于设置数组的形状, 后面会说 import numpy as np a = np.arange(9).reshape((3, 3)) a array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) b = -a * 2 b array([[ 0, -2, -4], [ -6, -8, -10], [-12, -14, -16]]) 相同形状的多维数组之间的运算, 对应位置的元素进行计算\na + b array([[ 0, -1, -2], [-3, -4, -5], [-6, -7, -8]]) # 行相同 a[1] + (a + b) array([[ 3, 3, 3], [ 0, 0, 0], [-3, -3, -3]]) 二维一列的数组和多维数组之间的运算, 需要列元素个数相同, 然后一一对应并广播计算\n# 列相同 # a 的列取出来成了一维, 需要转为二维 a[:, 1].reshape((3, 1)) + (a + b) array([[ 1, 0, -1], [ 1, 0, -1], [ 1, 0, -1]]) 2, 常用 ndarray 对象的方法 就是直接用 ndarray 对象调用的方法\n2.01, 形状操作 flatten 或 ravel 将多维数组展开为一维, 不改变原数组\na array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) # 默认参数 'C' 以行展开, 'F' 以列展开 display(a.flatten()) display(a.flatten('F')) a.ravel('F') array([0, 1, 2, 3, 4, 5, 6, 7, 8]) array([0, 3, 6, 1, 4, 7, 2, 5, 8]) array([0, 3, 6, 1, 4, 7, 2, 5, 8]) reshape 修改数组的形状, 不改变原数组, 行列数相乘要等于元素总数; resize 就地修改原数组形状\n# 默认以行展开修改 import numpy as np b = np.arange(12).reshape((3, 4)) display(b) b.reshape((2, 6), order='F') array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) array([[ 0, 8, 5, 2, 10, 7], [ 4, 1, 9, 6, 3, 11]]) # 就地修改 b display(b) b.resize((4, 3)) b array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]]) 2.02, 转换类型 tolist 数组转列表\nb.tolist() [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]] astype 改变数组类型\nb.astype(float) array([[ 0., 1., 2.], [ 3., 4., 5.], [ 6., 7., 8.], [ 9., 10., 11.]]) 2.03, 修改, 排序及查找 fill 给原数组重新填值, 类型不变\nb[0].fill(2.01) b array([[ 2, 2, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]]) sort 就地排序, 参数 0 将列排序, 1 将行排序\na = np.array([[3, 0, 5], [8, 4, 6], [0, 7, 3]]) a.sort(0) a array([[0, 0, 3], [3, 4, 5], [8, 7, 6]]) a.argsort() # 返回排序后的索引位置 array([[0, 1, 2], [0, 1, 2], [2, 1, 0]], dtype=int64) nonzero 返回非零元素的索引, 行坐标一个数组, 列坐标一个数组\na.nonzero() (array([0, 1, 1, 1, 2, 2, 2], dtype=int64), array([2, 0, 1, 2, 0, 1, 2], dtype=int64)) 2.04, 计算 max 返回最大值, 给定轴将返回给定轴的最大值, argmax 返回索引, 与之对应的还有最小min 和 argmin\n# 参数 0 列的最大值, 参数 1 行的最大值 a = np.arange(1.01, 13.13, 1.01).reshape(3, 4) print(a) print(a.max(), a.max(axis=0), a.max(axis=1)) [[ 1.01 2.02 3.03 4.04] [ 5.05 6.06 7.07 8.08] [ 9.09 10.1 11.11 12.12]] 12.12 [ 9.09 10.1 11.11 12.12] [ 4.04 8.08 12.12] # 参数 0 行索引, 1 列索引 print(a.argmax(), a.argmax(0), a.argmax(1)) 11 [2 2 2 2] [3 3 3] ptp 返回极值或给定轴的极值(最大-最小)\na.ptp(), a.ptp(axis=0), a.ptp(axis=1) (11.11, array([8.08, 8.08, 8.08, 8.08]), array([3.03, 3.03, 3.03])) clip 返回指定值之间的数组, 小于或大于指定值的, 用指定值填充\na.clip(2, 6) array([[2. , 2.02, 3.03, 4.04], [5.05, 6. , 6. , 6. ], [6. , 6. , 6. , 6. ]]) round 四舍五入到指定位数\na.round(1) array([[ 1. , 2. , 3. , 4. ], [ 5. , 6.1, 7.1, 8.1], [ 9.1, 10.1, 11.1, 12.1]]) sum 求和, cumsum 累积求和\nprint(a.sum()) # 总和 print(a.sum(0)) # 列求和 print(a.sum(1)) # 行求和 78.78 [15.15 18.18 21.21 24.24] [10.1 26.26 42.42] print(a.cumsum()) # 全部累积 print(a.cumsum(0)) # 列累积 print(a.cumsum(1)) # 行累积 [ 1.01 3.03 6.06 10.1 15.15 21.21 28.28 36.36 45.45 55.55 66.66 78.78] [[ 1.01 2.02 3.03 4.04] [ 6.06 8.08 10.1 12.12] [15.15 18.18 21.21 24.24]] [[ 1.01 3.03 6.06 10.1 ] [ 5.05 11.11 18.18 26.26] [ 9.09 19.19 30.3 42.42]] 类似还有 mean 均值, var 方差, std 标准差, prod 乘积, cumprod 累积乘积, 不在一一举例\nall 数组所有元素都判断为 True, 返回 True, 而 any 只要任何一个 True 返回 True\na = np.array([1, 2]) b = np.array([0, 0]) a.all(), b.all(), a.any(), b.any() (True, False, True, False) 四, 创建或生成 ndarray 对象 1, 生成随机数 利用 numpy 生成随机数的模块 random, 创建数据来作例子非常有用. 先研究一下这个模块, 再研究通用函数\nimport numpy as np # random 生成 0 ~ 1 之间的随机数 display(1 + np.random.random(3)) np.random.random((2,3)) * 10 array([1.33317465, 1.03829035, 1.19401465]) array([[2.13175522, 1.41162992, 9.67005144], [0.03480687, 4.63431381, 5.88380759]]) # 同上, 传参方式不一样 display(np.random.rand(3)) np.random.rand(1, 3, 2) array([0.60852454, 0.70296852, 0.31611002]) array([[[0.76136557, 0.14321424], [0.01322461, 0.89676522], [0.71400795, 0.00755323]]]) # 返回指定范围内的随机整数 [a,b) 包含 a 不包含 b, 不指定 b 则 [0,a) display(np.random.randint(3, size=3)) np.random.randint(1, 4, (2, 3)) array([0, 2, 0]) array([[2, 2, 1], [3, 2, 3]]) # 生成的随机数服从标准正态分布 display(np.random.randn(3)) np.random.randn(3, 2) array([-1.46427887, 0.87862733, -0.98698207]) array([[ 0.51350851, -0.67478546], [ 0.543379 , 0.63665877], [-1.31200705, -0.30697352]]) 类似还有拉普拉斯分布 laplace, 逻辑分布 logistic, 正态分布 normal 等, 可以设置分布的参数\nnp.random.logistic(5, 2, (2, 3)) array([[2.40647744, 5.62327677, 5.8642342 ], [4.10741882, 7.65751053, 4.99483744]]) # 打乱原数组元素, 二维时只能打乱行的顺序 a = np.arange(5) b = np.arange(9).reshape(3, 3) np.random.shuffle(a) np.random.shuffle(b) a, b (array([0, 2, 4, 1, 3]), array([[3, 4, 5], [6, 7, 8], [0, 1, 2]])) # 从一个一维数组里随机选择指定数量的元素, # 或随机生成 0 到指定整数(不包含)的随机数 # replace=True 元素可以重复选择(默认) display(np.random.choice(5, 5, replace=False)) np.random.choice(a, (2, 3)) array([4, 3, 1, 2, 0]) array([[3, 2, 2], [3, 0, 0]]) 2, 创建数组 np.empty((2, 3)) array([[2.40647744, 5.62327677, 5.8642342 ], [4.10741882, 7.65751053, 4.99483744]]) a = np.eye(3) a array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) np.ones((2, 3)) array([[1., 1., 1.], [1., 1., 1.]]) np.ones_like(a) array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) np.zeros((2, 3)) array([[0., 0., 0.], [0., 0., 0.]]) np.full((2, 3), 3) array([[3, 3, 3], [3, 3, 3]]) np.array(list) array(\u003cclass 'list'\u003e, dtype=object) np.arange(3) array([0, 1, 2]) np.linspace(1, 9, 3) array([1., 5., 9.]) np.logspace(1, 3, 3) array([ 10., 100., 1000.]) 五, 常用的通函数及 API numpy 调用, 用来操作 ndarray 对象的函数\n1, 修改数组形状 reshape 与 ndarray 对象的方法一样, 另有 resize 只能按行展开\na = np.random.choice(5, (2, 3)) display(a) np.reshape(a,(1, 6), 'F') array([[0, 2, 2], [4, 1, 2]]) array([[0, 4, 2, 1, 2, 2]]) np.resize(a, (1, 6)) array([[0, 2, 2, 4, 1, 2]]) ravel 展开为一维(ndarray 对象也有该方法)\nnp.ravel(a, 'F') array([0, 4, 2, 1, 2, 2]) 2, 组合数组 concatenate, hstack, vstack 连接数组\n# axis=0, 行方向连接(默认), axis=1, 列方向连接 b = np.random.choice(6, (2, 3)) np.concatenate((a, b), axis=1) array([[0, 2, 2, 2, 5, 5], [4, 1, 2, 2, 5, 2]]) np.hstack((a, b)) # 列方向连接 array([[0, 2, 2, 2, 5, 5], [4, 1, 2, 2, 5, 2]]) np.vstack((a, b)) # 行方向连接 array([[0, 2, 2], [4, 1, 2], [2, 5, 5], [2, 5, 2]]) stack 堆叠数组, 堆叠后维度增加 1\n# axis=0, 行方向堆叠(默认), axis=1, 列方向堆叠 np.stack((a[0], b[0])), np.stack((a[0], b[0]), axis=1) (array([[0, 2, 2], [2, 5, 5]]), array([[0, 2], [2, 5], [2, 5]])) 3, 拆分数组 split, hsplit, vsplit 将数组拆分, 返回为列表\nnp.split(a, 2), np.vsplit(a, 2), np.hsplit(a, 3) ([array([[0, 2, 2]]), array([[4, 1, 2]])], [array([[0, 2, 2]]), array([[4, 1, 2]])], [array([[0], [4]]), array([[2], [1]]), array([[2], [2]])]) 4, 添加, 删除元素 delete 删除指定索引的元素, 行或列\na, np.delete(a, 1) # 删除第 2 个元素 (array([[0, 2, 2], [4, 1, 2]]), array([0, 2, 4, 1, 2])) # 删除第 2 行, 或第 2 列 np.delete(a, 1, axis=0), np.delete(a, 1, axis=1) (array([[0, 2, 2]]), array([[0, 2], [4, 2]])) insert 在指定索引前插入元素, 行或列\nnp.insert(a, 1, 9) array([0, 9, 2, 2, 4, 1, 2]) np.insert(a, 1, 9, axis=0), np.insert(a, 1, [1, 2, 3], axis=0) (array([[0, 2, 2], [9, 9, 9], [4, 1, 2]]), array([[0, 2, 2], [1, 2, 3], [4, 1, 2]])) np.insert(a, 1, [1, 3], axis=1) array([[0, 1, 2, 2], [4, 3, 1, 2]]) append 在数组末尾(或行,列末尾)加入元素, 行或列(维数必须相同)\nnp.append(a, 2) array([0, 2, 2, 4, 1, 2, 2]) np.append(a, [[2, 2, 2]], axis=0), np.append(a, [[2], [2]], axis=1) (array([[0, 2, 2], [4, 1, 2], [2, 2, 2]]), array([[0, 2, 2, 2], [4, 1, 2, 2]])) unique 查找数组中的唯一值\na = np.random.choice(4, (2, 3)) display(a) np.unique(a,return_index=True, return_inverse=True, return_counts=True, axis=None) array([[3, 0, 3], [1, 3, 1]]) (array([0, 1, 3]), array([1, 3, 0], dtype=int64), array([2, 0, 2, 1, 2, 1], dtype=int64), array([1, 2, 3], dtype=int64)) 5, 重新排列元素 flip, fliplr, flipud 翻转数组\nnp.flip(a), np.flip(a, 0), np.flip(a, 1) (array([[1, 3, 1], [3, 0, 3]]), array([[1, 3, 1], [3, 0, 3]]), array([[3, 0, 3], [1, 3, 1]])) sort 排序数组元素\nnp.sort(a) array([[0, 3, 3], [1, 1, 3]]) roll 滚动数组元素\nnp.roll(a, 1), np.roll(a, 1, axis=0), np.roll(a, 1, axis=1) (array([[1, 3, 0], [3, 1, 3]]), array([[1, 3, 1], [3, 0, 3]]), array([[3, 3, 0], [1, 1, 3]])) 6, 常用数学运算函数 import numpy as np # 固定随机种子 np.random.seed(0) a = np.random.randint(1, 6, (3, 4)) b = np.arange(12).reshape((3, 4)) a, b (array([[5, 1, 4, 4], [4, 2, 4, 3], [5, 1, 1, 5]]), array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])) np.power(b, a) # b**a array([[ 0, 1, 16, 81], [ 256, 25, 1296, 343], [ 32768, 9, 10, 161051]], dtype=int32) np.divmod(b, a) # 商 和 余 (array([[ 0, 1, 0, 0], [ 1, 2, 1, 2], [ 1, 9, 10, 2]], dtype=int32), array([[0, 0, 2, 3], [0, 1, 2, 1], [3, 0, 0, 1]], dtype=int32)) np.fabs(-a), np.abs(-a) # 取绝对值 (array([[5., 1., 4., 4.], [4., 2., 4., 3.], [5., 1., 1., 5.]]), array([[5, 1, 4, 4], [4, 2, 4, 3], [5, 1, 1, 5]])) c = np.random.rand(3, 4) * 10 display(c) np.rint(c) # 舍入最接近的整数 array([[3.83441519, 7.91725038, 5.2889492 , 5.68044561], [9.25596638, 0.71036058, 0.871293 , 0.20218397], [8.32619846, 7.78156751, 8.70012148, 9.78618342]]) array([[ 4., 8., 5., 6.], [ 9., 1., 1., 0.], [ 8., 8., 9., 10.]]) np.exp(a).round(1) # np.e ** a array([[148.4, 2.7, 54.6, 54.6], [ 54.6, 7.4, 54.6, 20.1], [148.4, 2.7, 2.7, 148.4]]) b = np.exp2(a) # 2**a a, b (array([[5, 1, 4, 4], [4, 2, 4, 3], [5, 1, 1, 5]]), array([[32., 2., 16., 16.], [16., 4., 16., 8.], [32., 2., 2., 32.]])) np.log(a) np.log2(a) np.log10(a) np.sqrt(a) # 开根号 np.gcd(a, b.astype(int)) # 最大公约数 np.lcm(a, b.astype(int)) # 最小公倍数 array([[160, 2, 16, 16], [ 16, 4, 16, 24], [160, 2, 2, 160]]) np.sin(a) np.cos(a) np.tan(a) array([[-3.38051501, 1.55740772, 1.15782128, 1.15782128], [ 1.15782128, -2.18503986, 1.15782128, -0.14254654], [-3.38051501, 1.55740772, 1.55740772, -3.38051501]]) np.greater(a, b) # a \u003e b np.less(a, b) # a \u003c b a != b # np.not_equal(a, b) (a \u003e 2) | ~(b \u003c 5) # np.logical_or(a\u003e2, ~(b\u003c5)) array([[ True, False, True, True], [ True, False, True, True], [ True, False, False, True]]) # 两者取其大, 同 np.fmax(a*5, b) 对应还有 minimum, fmin np.maximum(a*5, b) array([[32., 5., 20., 20.], [20., 10., 20., 15.], [32., 5., 5., 32.]]) np.isinf(a) # 判断是否正负无穷大 np.isnan(a) # 判断是否 nan array([[False, False, False, False], [False, False, False, False], [False, False, False, False]]) np.modf(c) # 分别返回小数和整数部分 (array([[0.83441519, 0.91725038, 0.2889492 , 0.68044561], [0.25596638, 0.71036058, 0.871293 , 0.20218397], [0.32619846, 0.78156751, 0.70012148, 0.78618342]]), array([[3., 7., 5., 5.], [9., 0., 0., 0.], [8., 7., 8., 9.]])) np.fmod(b, a) # 返回余数 array([[2., 0., 0., 0.], [0., 0., 0., 2.], [2., 0., 0., 2.]]) c = np.random.rand(3, 4) * 10 display(c) np.floor(c) # 向下取整 np.ceil(c) # 向上取整 array([[7.99158564, 4.61479362, 7.80529176, 1.18274426], [6.39921021, 1.43353287, 9.44668917, 5.21848322], [4.1466194 , 2.64555612, 7.74233689, 4.56150332]]) array([[ 8., 5., 8., 2.], [ 7., 2., 10., 6.], [ 5., 3., 8., 5.]]) 7, 字符串操作 字符串的操作函数, 和 python 的操作函数相似, 只是 numpy 作用到整个数组上\na = np.array([['a', 'b', 'c'], [20, 19, 18]]) np.char.add(a, a) array([['aa', 'bb', 'cc'], ['2020', '1919', '1818']], dtype='\u003cU22') np.char.multiply(a, 3) array([['aaa', 'bbb', 'ccc'], ['202020', '191919', '181818']], dtype='\u003cU33') # 将每一个制表符替换成指定个数的空格 b = np.array('\\ta\\t\\tbc\\td') np.char.expandtabs(b, 1) array(' a bc d', dtype='\u003cU8') np.char.replace(a, '1', '2') # 替换 array([['a', 'b', 'c'], ['20', '29', '28']], dtype='\u003cU2') np.char.title(a) array([['A', 'B', 'C'], ['20', '19', '18']], dtype='\u003cU11') b = np.char.zfill(a, 4) b array([['000a', '000b', '000c'], ['0020', '0019', '0018']], dtype='\u003cU4') np.char.count(b, '0') # 0 出现的次数 array([[3, 3, 3], [3, 2, 2]]) np.char.str_len(a) # 字符串长度 array([[1, 1, 1], [2, 2, 2]]) 8, 索引与迭代 a = np.random.choice(4, (3, 4)) display(a) np.nonzero(a) # 非 0 索引 array([[2, 0, 0, 0], [1, 1, 2, 0], [0, 1, 3, 0]]) (array([0, 1, 1, 1, 2, 2], dtype=int64), array([0, 0, 1, 2, 1, 2], dtype=int64)) # 返回指定条件的元素的索引, 并可进行替换 # 不设条件, 和 nonzero 一样 np.where(a\u003e0) (array([0, 1, 1, 1, 2, 2], dtype=int64), array([0, 0, 1, 2, 1, 2], dtype=int64)) # 大于 0 都换成 a, 否则都换成 b np.where(a\u003e0, 'a', 'b') array([['a', 'b', 'b', 'b'], ['a', 'a', 'a', 'b'], ['b', 'a', 'a', 'b']], dtype='\u003cU1') np.nditer(a) # 将数组变成一个高效的迭代器 \u003cnumpy.nditer at 0x2b410944d50\u003e 9, 统计运算函数 # 下述与 ndarray 对象直接调用的方法一样 a = np.random.rand(3, 4) * 5 np.all(a) np.any(a) np.max(a) np.sum(a) np.mean(a) np.cumsum(a) np.var(a) np.std(a) np.clip(a, 1, 3) np.around(a, 2) # ndarray 对象的方法是 round # 等等 array([[3.41, 1.8 , 2.19, 3.49], [0.3 , 3.33, 3.35, 1.05], [0.64, 1.58, 1.82, 2.85]]) 任何数与 nan 计算都是 nan, 可以用相应的函数排除 nan\nb = np.array([1, np.nan, 3, 4]) np.sum(b), np.nansum(b) (nan, 8.0) np.nancumsum(b) array([1., 1., 4., 8.]) jupyter附件 numpy.ipynb (67 KB) ",
    "description": "",
    "tags": null,
    "title": "Numpy 基础快速了解和查询",
    "uri": "/numpy/"
  },
  {
    "content": "集合方法 set.issuperset()，Python 官方文档描述如下：\nhelp(set.issuperset) Help on method_descriptor:\rissuperset(...)\rReport whether this set contains another set.\r检查一个集合是否是另一个集合的超集。相当于 a \u003e= b（a，b 是两个集合），但方法中的参数可以是可迭代对象。\n{1,2}.issuperset({True:'1',2:'2'}) True\r{1,2,3} \u003e= {True,2} True\r对于真超集，使用 \u003e 进行检查：\n{1,2,3} \u003e {True,2} True\r{1,2} \u003e {True,2} False\r",
    "description": "",
    "tags": null,
    "title": "set.issuperset 是超集吗？",
    "uri": "/python/06_set/04_set.issuperset/"
  },
  {
    "content": "字符串方法 str.count()，Python 官方文档描述如下：\nhelp(str.count) Help on method_descriptor:\rcount(...)\rS.count(sub[, start[, end]]) -\u003e int\rReturn the number of non-overlapping occurrences of substring sub in\rstring S[start:end]. Optional arguments start and end are\rinterpreted as in slice notation.\r返回回子字符串 sub 在 [start, end] 范围内非重叠出现的次数。可选参数 start 与 end 会被解读为切片表示法。\n只给定 sub 一个参数的话，于是从第一个字符开始搜索到字符串结束；如果，随后给定了一个可选参数的话，那么它是 start，于是从 start 开始，搜索到字符串结束；如果 start 之后还有参数的话，那么它是 end；于是从 start 开始，搜索到 end - 1 结束（即不包含索引值为 end 的那个字符）。\n'python'.count('0') 0\r'pyyython'.count('yy') 1\r'pythonpythonn'.count('n',5) 3\r'pythonpythonn'.count('n',5,7) 1\r",
    "description": "",
    "tags": null,
    "title": "str.count 统计",
    "uri": "/python/02_string/04_str.count/"
  },
  {
    "content": "容器类的内置类型，通常对操作符定义了自己特有的的操作行为。\n* 操作符，除了数字运算的 乘，还可以用来将可迭代对象拆包。拆包之后置于元组，列表，集合中，或作为参数传递给函数： {*{'a':1, 'b':2}} {'a', 'b'}\rprint(*'abc', sep='-') a-b-c\r+，+=，*，*= 可用来对序列类型进行拼接，重复拼接或拼接并赋值（range 类型除外）。由于列表是可变对象，+= 和 *= 在操作列表时，是用来更新列表。具体详见 列表操作符。 'd-' + 'abc'*2 'd-abcabc'\ra = [1]*2 a += [2] a [1, 1, 2]\r操作符 **，| 和 |= 可以用来操作字典。具体详见 字典操作符。\n操作符 \u003e，\u003c，\u003e=，\u003c= 可对集合进行子集或超集比较；|，\u0026，-，^ 可求集合的并集，交集，差集，对称差集；|=，\u0026=，-=，^= 可用来更新集合。具体详见集合知识点。\n操作符 % 可以用来格式化字符串，而在格式化迷你语言中，定义了非常多的有特殊意义操作符。具体详见 str.format 格式化 和 字符串操作符。\n",
    "description": "",
    "tags": null,
    "title": "操作符特殊用法",
    "uri": "/python/09_operator/04_special/"
  },
  {
    "content": "导入操作使用 import 语句，详细的语法规则查看 import 导入语句。\nimport ... 只能导入模块： import random as r, pandas.core as pc r, pc (\u003cmodule 'random' from 'F:\\\\anaconda\\\\lib\\\\random.py'\u003e,\r\u003cmodule 'pandas.core' from 'F:\\\\anaconda\\\\lib\\\\site-packages\\\\pandas\\\\core\\\\__init__.py'\u003e)\r# 导入方法报错 import random.randint ---------------------------------------------------------------------------\rModuleNotFoundError Traceback (most recent call last)\r\u003cipython-input-2-8d4ecd1fe339\u003e in \u003cmodule\u003e\r1 # 导入方法报错\r----\u003e 2 import random.randint\rModuleNotFoundError: No module named 'random.randint'; 'random' is not a package\rfrom ... import ... 从模块中导入子模块，类，函数等： from pandas import core core \u003cmodule 'pandas.core' from 'F:\\\\anaconda\\\\lib\\\\site-packages\\\\pandas\\\\core\\\\__init__.py'\u003e\rfrom pandas import DataFrame as df df pandas.core.frame.DataFrame\rfrom random import randint randint \u003cbound method Random.randint of \u003crandom.Random object at 0x000001E44ED52020\u003e\u003e\rfrom math import pi pi 3.141592653589793\rfrom ... import * 将导入模块中所有的公有属性： 当前文件路径下，有一个 myfile 的包，包里有 space.py，mycode.py 和 __init__.py 等模块，__init__.py 内容为空，则 myfile 包里的模块都不是它的属性，无法导入\nimport myfile dir(myfile) ['__builtins__',\r'__cached__',\r'__doc__',\r'__file__',\r'__loader__',\r'__name__',\r'__package__',\r'__path__',\r'__spec__']\rfrom myfile import * mycode ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r~\\AppData\\Local\\Temp/ipykernel_21108/1508979804.py in \u003cmodule\u003e\r1 from myfile import *\r----\u003e 2 mycode\rNameError: name 'mycode' is not defined\r如果在文件 __init__.py 中我们定义了属性 __all__ ，从包 myfile 导入则只能导入该属性中的列出名称。\n# 修改 myfile/__init__.py __all__ = ['mycode','xue'] from myfile import * mycode 我是mycode模块中的代码\r\u003cmodule 'myfile.mycode' from 'D:\\\\Jupyter\\\\jupyter\\\\jupyter-python\\\\15_module\\\\myfile\\\\mycode.py'\u003e\r在文件 myfile/mycode.py 中，以下划线打头的属性名，从模块 mycode.mycode 导入时都不可导入。\n# myfile/mycode.py _a = '自学' def __f(): print(_a) msg1 = '我是mycode模块中的代码' print(msg1) if __name__ == '__main__': msg2 = '我是导入其他模块不会执行的代码' print(msg2) from myfile.mycode import * _a ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r~\\AppData\\Local\\Temp/ipykernel_9512/1217097939.py in \u003cmodule\u003e\r1 from myfile.mycode import *\r----\u003e 2 _a\rNameError: name '_a' is not defined\r__f ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r~\\AppData\\Local\\Temp/ipykernel_9512/3733874203.py in \u003cmodule\u003e\r----\u003e 1 __f\rNameError: name '__f' is not defined\r通常情况下不应使用这个功能，因为它在解释器中引入了一组未知的名称，而它们很可能会覆盖一些你已经定义过的名称。而且会导致代码的可读性很差。\n# 其他方式则可以导入 from myfile.mycode import __f print(__f) del __f \u003cfunction __f at 0x00000157E4BA53A0\u003e\r相对导入： 存在相对导入代码的模块，通常是不能直接执行的。因为直接执行，解释器认为该模块即为顶级模块，属性 __package__ 的值为 None。\nprint(__package__) None\r但可以使用 python -m 模块 命令直接执行。\n例如，当前文件路径下，文件 myfile/test.py 中相对导入的代码可以使用 python -m 模块 命令直接执行，因为该命令将属性 __package__ 重新设置为顶级模块的名称：\n# xue.py 模块在 myfile 包中，内容是 “msg = '自学是门手艺'” # myfile/test.py 的内容 from . import xue print(xue.msg) print(__package__) %run -m myfile.test 自学是门手艺\rmyfile\r模块导入之后，即可使用属性表示法调用模块中属性：\nimport random, math random.randint, math.pi (\u003cbound method Random.randint of \u003crandom.Random object at 0x000002811CF98C80\u003e\u003e,\r3.141592653589793)\r",
    "description": "",
    "tags": null,
    "title": "导入操作",
    "uri": "/python/15_module/05_import_code/"
  },
  {
    "content": "对象是 Python 中对数据的抽象。Python 程序中的所有数据都是由对象或对象间关系来表示的。\n例如计算 x + y 就有对象 x 和 y，+ 其实是调用了 __add__ 方法对象。\n[1,2] + [3,4] [1, 2, 3, 4]\rlist.__add__ \u003cslot wrapper '__add__' of 'list' objects\u003e\r[1,2].__add__([3,4]) [1, 2, 3, 4]\r每个对象都有各自的编号、类型和值。一个对象被创建后，它的编号就绝不会改变，可以将其理解为该对象在内存中的地址。\nid([1,2]), type([1,2]) # 实例对象 [1,2] 的编号 和 类型 (2229938322504, list)\rid(list), type(list) # 类对象 list 的编号 和 类型 (140736641645872, type)\r对象的值在 Python 中是一个相当抽象的概念：\n对象的值并没有一个规范的访问方法； 对象的值并不要求具有特定的构建方式，例如由其全部数据属性组成等； 比较运算符实现了一个特定的对象的值概念，可以认为正是通过实现对象比较，间接地定义了对象的值。 # 列表对象 [1,2] 和类对象 list # 是两个不同对象，值是不相等的 [1,2] == list False\r具有固定值的对象为不可变对象，例如数字，字符串，元组（包含的对象集不可变），相等的两个值，可能会也可能不会指向同一个对象，看具体实现。\n# 元组的对象集固定不可变 t = ([1,2],(3,4)) print(id(t[0]),id(t[1]),t) del t[0][:] print(id(t[0]),id(t[1]),t) 2229937078536 2229937013960 ([1, 2], (3, 4))\r2229937078536 2229937013960 ([], (3, 4))\r# 同一个对象 1 print(id(1)) print(id(1)) 140736642126656\r140736642126656\r# 两个不同对象 1000 print(id(1000)) print(id(1000)) 2229938479344\r2229938479248\r对象的编号保持不变，可以改变值的对象为可变对象。对于可变对象，分别创建两个相等的值，一定是不同对象。\n# 可变对象 a，值改变了还是 a a = [1,2] print(id(a), a) del a[:] print(id(a), a) 2229937082056 [1, 2]\r2229937082056 []\r# 类对象 A，增加属性 a 还是 A class A:pass print(id(A), A) A.a = 0 print(id(A), A) 2229917928424 \u003cclass '__main__.A'\u003e\r2229917928424 \u003cclass '__main__.A'\u003e\ra = [] b = [] print(id(a)) print(id(b)) a == b 2229937416840\r2229937416648\rTrue\r类或函数对象的哈希值基于其 id，创建两个看起来完全一样的类或函数，id 是不一样的，而可哈希对象必须具有相同的哈希值，比较结果才会相同。\ndef f():pass print(id(f)) a = f def f():pass print(id(f)) b = f a == b 2229938263992\r2229938264128\rFalse\r",
    "description": "",
    "tags": null,
    "title": "对象",
    "uri": "/python/16_class/04_object/"
  },
  {
    "content": "浮点数简单理解就是带小数点的数，通常使用 C 语音中的 double 来实现。有关你的程序运行所在计算机上浮点数的精度和内部表示法可在 sys.float_info 中查看。\nimport sys sys.float_info sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\r浮点数可以省略 . 前后的数；可以使用科学计数法；可以在数字之间插入下划线；可以以 0 开头。\n举例如下：\n# e 大小写均可 e-2 表示 10 的 -2 次方 0., .5, 0.1e-2, 3_1.1_4, 01.2e02 (0.0, 0.5, 0.001, 31.14, 120.0)\r整数除法除一定得到浮点数：\nTrue/3, 3/3 (0.3333333333333333, 1.0)\r整数和浮点数可以相互转换，浮点数转为整数，直接去掉小数部分：\nint(3.56), float(0) (3, 0.0)\r",
    "description": "",
    "tags": null,
    "title": "浮点数",
    "uri": "/python/01_numeric/04_float/"
  },
  {
    "content": "函数返回值通过 return 语句 来实现，调用函数时，返回 return 语句之后表达式的值，没有 return 语句或 return 语句之后为空的函数，调用函数默认返回 None。\ndef f(x): return x**2 f(2) 4\rdef f(): pass f() is None True\r函数执行到 return 语句，则结束当前函数的调用，可以通过条件判断，返回特定结果：\ndef f(x=None): if x == None: return 0 # 使用默认值调用函数，接下来的代码将不被执行 print(f'x={x}') if x != None: return f'x²={x**2}' f() 0\rf(2) x=2\r'x²=4'\rreturn 之后的表达式可以是多个表达式用逗号隔开（其实是一个元组），可用赋值语句分别接收返回值：\ndef f(x): return sum(x), max(x), min(x) f([1,2,3,4]) (10, 4, 1)\rsum_x, max_x, min_x = f([1,2,3,4]) sum_x, max_x, min_x (10, 4, 1)\r返回值可以是任何值。如果 return 之后的表达式中包含函数自身的调用，则该函数称为递归函数。详见 递归函数。\n# 返回函数自身 def f(x): print(x) return f f(1)(2)(3) 1\r2\r3\r\u003cfunction __main__.f(x)\u003e\r# 返回函数自身的调用 def f(x): if x == 0: return 0 else: print(x-1) return f(x-1) f(3) 2\r1\r0\r0\r",
    "description": "",
    "tags": null,
    "title": "函数返回值",
    "uri": "/python/12_function/04_return_value/"
  },
  {
    "content": "列表对象 list 是高级数据结构的一种，通过方括号括起、逗号分隔的一组值得到。类型是 list。\ntype([1,2,3]) list\r列表是可变序列，通常用于存放同类项目的集合。但没做限制，可以存放任意对象。\n[1,'a',int] [1, 'a', int]\r列表是可变的，分别创建两个值相同的列表，一定是不同的对象；而同一个列表对象中的元素是可以改变的：\na, b = [1,2], [1,2] a == b True\rid(a), id(b) (2004948061384, 2004947934152)\ra[0] = 'a' a, id(a) (['a', 2], 2004948061384)\r列表创建方法有：直接用一对方括号表示；列表推导式；或使用内建函数 list()。\n[], [1,2] ([], [1, 2])\r[i for i in range(3)] [0, 1, 2]\rlist('abc') ['a', 'b', 'c']\r列表的所有切片都将得到一个新列表，这意味着以下切片操作会返回列表的一个浅拷贝:\nlist_1 = [1,2,3] list_2 = list_1[:] id(list_1), id(list_2) (2004947038600, 2004948064968)\r然而，列表可以利用切片改变自身的内容，列表仍然是原来的列表：\nlist_1[:] = 'abc' list_1, id(list_1) (['a', 'b', 'c'], 2004947038600)\rjupyter附件 01_list.ipynb (5 KB) 02_list_comprehension.ipynb (7 KB) 03_list_indexes_and_slices.ipynb (5 KB) 04_list_operator.ipynb (5 KB) 05_list.append.ipynb (2 KB) 06_list.extend.ipynb (2 KB) 07_list.insert.ipynb (2 KB) 08_list.sort.ipynb (6 KB) 09_list.reverse.ipynb (2 KB) 10_list.pop.ipynb (3 KB) 11_list.remove.ipynb (3 KB) 12_list.count.ipynb (1 KB) 13_list.index.ipynb (3 KB) 14_list.copy.ipynb (2 KB) 15_list.clear.ipynb (2 KB) ",
    "description": "",
    "tags": null,
    "title": "列表",
    "uri": "/python/03_list/"
  },
  {
    "content": "列表可以使用 比较运算符，但比较运算符对数据通用，单独用一个知识点讲解。该知识点介绍有列表自己特性的操作符 + 和 *。\n操作符 + 操作符 +，可以让两个列表元素顺序不变地合并到一个新的列表中：\nlist_1 = [1,2] list_2 = [3,4] list_1 + list_2, list_2 + list_1 ([1, 2, 3, 4], [3, 4, 1, 2])\r操作符 + 还可以与赋值操作符 = 连用，将一个列表中的元素，加到另一个列表中（相当于 list.extend()），而不创建一个新列表：\nlist_1 = [1,2] list_2 = [3,4] print(id(list_1)) list_1 += list_2 id(list_1), list_1 2893532728008\r(2893532728008, [1, 2, 3, 4])\r操作符 * 操作符 *，可以将列表中的元素重复 n 次，得到一个新列表：\nlist_1 = [1,2] list_2 = list_1*2 print(id(list_1),id(list_2)) list_2 2893532600136 2893532727432\r[1, 2, 1, 2]\r**注意：**如果列表中有可变对象，重复 n 次后，可变对象是同一个对象的多次引用，改变一个，都会跟着改变。\nlist_1 = [[0]] list_2 = list_1*3 print(list_2) list_1[0][0] = 1 list_2 [[0], [0], [0]]\r[[1], [1], [1]]\r操作符 *，还可以与赋值操作符 = 连用，用一个列表的元素重复 n 次来扩充它自身，而不创建新列表：\n_list = [1,2] print(id(_list)) _list *= 2 id(_list), _list 2893532727624\r(2893532727624, [1, 2, 1, 2])\r当 n 小于 1 时，则得到空列表：\n[1,2,3]*0 []\r列表是可迭代对象，* 可以将列表拆包：\nprint(*[1,2,3]) 1 2 3\r",
    "description": "",
    "tags": null,
    "title": "列表操作符",
    "uri": "/python/03_list/04_list_operator/"
  },
  {
    "content": "1, 模型 模型是指对于某个(类)实际问题的求解或客观事物运行规律进行抽象后的一种形式化表达方式, 可以理解为一个函数(一种映射规则)\n任何模型都是由三个部分组成: 目标, 变量和关系. 建模时明确了模型的目标，才能进一步确定影响目标(因变量)的各关键变量(自变量)，进而确定变量之间的关系(函数关系)\n通过大量数据检验(训练)模型, 将模型(函数)的各个参数求解, 当参数确定之后, 便可利用模型对未知数据进行求值, 预测\n用于训练模型的样本数据中的每个属性称为特征, 用 x 表示, 样本中的每条数据经过模型计算得到的输出值称为标签(监督学习), 用 y 表示, 从而得到 y = f(x) 的函数关系\n2, 回归分析 在统计学中, 回归分析指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法\n回归分析按照涉及的变量的多少，分为一元回归分析和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析\n回归分析解释自变量 x 发生改变, 因变量 y 会如何改变\n拟合 , 插值 和 逼近 是数值分析的三大基础工具. 线性回归和非线性回归, 也叫线性拟合和非线性拟合, 拟合就是从整体上靠近已知点列，构造一种算法(模型或函数), 使得算法能够更加符合真实数据\n3, 简单线性回归 线性回归分析的自变量和因变量之间是线性关系, 只有一个自变量时称为 简单线性回归 , 多个自变量时称为 多元线性回归\n简单线性回归方程:\n$$\\hat{y}=w * x+b$$ $\\hat{y}$ 为因变量, x 为自变量, w 为比例关系, b 为截距, w 和 b 就是模型的参数. 例如房屋价格与房屋面积的正比例关系\n4, 多元线性回归 现实生活中自变量通常不止一个, 例如影响房屋价格的, 除了房屋面积, 还有交通, 地段, 新旧, 楼层等等因素. 不同的因素对房屋的价格影响力度(权重)不同, 因此使用多个因素来分析房屋的价格(各个因素与房屋价格近似线性关系), 可以得出多元线性回归方程:\n$\\hat{y}=w_{1} * x_{1}+w_{2} * x_{2}+w_{3} * x_{3}+\\cdots+w_{n} * x_{n}+b$ $x$: 影响因素, 特征\n$w$: 每个 x 的影响力度\n$n$: 特征个数\n$\\hat{y}$: 房屋的预测价格\n令:\n$x_{0}=1, w_{0}=b$ 设 $\\vec{w}$ 和 $\\vec{x}$ 为两个向量如下:\n$$\\vec{w}=\\left(w_{0}, w_{1}, w_{2}, w_{3}, \\ldots, w_{n}\\right)^{T}$$ $$\\vec{x}=\\left(x_{0}, x_{1}, x_{2}, x_{3}, \\ldots, x_{n}\\right)^{T}$$则方程可表示为:\n$$\\begin{aligned} \\hat{y} \u0026=w_{0} * x_{0}+w_{1} * x_{1}+w_{2} * x_{2}+w_{3} * x_{3}+\\ldots \\ldots+w_{n} * x_{n} \\ =\\sum_{j=0}^{n} w_{j} * x_{j} \\ =\\vec{w}^{T} \\cdot \\vec{x} \\end{aligned}$$接下来只需要计算出参数 $\\vec{w}^{T}$, 便可以建立模型\n5, 损失函数 损失函数, 用来衡量模型预测值与真实值之间的差异的函数, 也称目标函数或代价函数. 损失函数的值越小, 表示预测值与真实值之间的差异越小.\n因此, 求解上述模型的参数 $\\vec{w}^{T}$, 就是要建立一个关于模型参数的损失函数(以模型参数 $\\vec{w}^{T}$ 为自变量的函数), 然而 $\\vec{w}^{T}$ 的取值组合是无限的, 目标就是通过机器学习, 求出一组最佳组合, 使得损失函数的值最小\n在线性回归中, 使用平方损失函数(最小二乘法), 用 J(w) 表示:\n$$\\begin{array}{l} J(w)=\\frac{1}{2} \\sum_{i=1}^{m}\\left(y^{(i)}-\\hat{y}^{(i)}\\right)^{2} \\ =\\frac{1}{2} \\sum_{i=1}^{m}\\left(y^{(i)}-\\vec{w}^{T} \\vec{x}^{(i)}\\right)^{2} \\end{array}$$m: 样本(训练集)数据的条数\n$y^{(i)}$: 样本第 i 条数据的真实值\n$\\hat{y}^{(i)}$: 样本第 i 条数据的预测值\n$\\vec{x}^{(i)}$: 样本第 i 条数据的特征\nm, $y^{(i)}$ 和 $\\vec{x}^{(i)}$ 已知, 要使 J(w) 最小, 对 $\\vec{w}^{T}$ 求导并令导数等于 0 , 便可求得 $\\vec{w}^{T}$, 然后将样本(训练集)输入通过机器学习计算出具体的 $\\vec{w}^{T}$\n6, 回归模型评估 建立模型之后, 模型的效果如何, 需要进行评估, 对于回归模型, 可用如下指标来衡量:\nMSE :\n平均平方误差, 所有样本数据误差的平方和取均值:\n$$M S E=\\frac{1}{m} \\sum_{i=1}^{m}\\left(y^{(i)}-\\hat{y}^{(i)}\\right)^{2}$$RMSE :\n平均平方误差的平方根:\n$$R M S E=\\sqrt{M S E}=\\sqrt{\\frac{1}{m} \\sum_{i=1}^{m}\\left(y^{(i)}-\\hat{y}^{(i)}\\right)^{2}}$$MAE :\n平均绝对值误差, 所有样本数据误差的绝对值的和取均值:\n$$M A E=\\frac{1}{m} \\sum_{i=1}^{m}\\left|y^{(i)}-\\hat{y}^{(i)}\\right|$$上述指标越小越好, 小到什么程度, 不同的对象建立的模型不一样\nR² :\n决定系数，反应因变量的全部变异能通过回归关系被自变量解释的比例. 如 R²=0.8，则表示回归关系可以解释因变量 80% 的变异. 换句话说，如果我们能控制自变量不变，则因变量的变异程度会减少 80%\n在训练集中 R² 取值范围为 [0, 1], 在测试集(未知数据)中, R² 的取值范围为 [-∞, 1], R² 的值越大, 模型拟合越好\nR² 的计算公式:\n$$R^{2}=1-\\frac{R S S}{T S S}=1-\\frac{\\sum_{i=1}^{m}\\left(y^{(i)}-\\hat{y}^{(i)}\\right)^{2}}{\\sum_{i=1}^{m}\\left(y^{(i)}-\\bar{y}\\right)^{2}}$$ $\\bar{y}$: 样本(测试集)的平均值\n不管何种对象建立的模型, R² 都是越大模拟越好\n例一, 简单线性回归模型: 求鸢尾花花瓣长度和宽度的关系\nimport numpy as np # 导入用于线性回归的类 from sklearn.linear_model import LinearRegression # 切分训练集与测试集的模块 from sklearn.model_selection import train_test_split # 鸢尾花数据集 from sklearn.datasets import load_iris # 设置输出数据的精度为 2 (默认是8) np.set_printoptions(precision=2) # 获取花瓣长度 x, 宽度 y iris = load_iris() x, y = iris.data[:, 2].reshape(-1, 1), iris.data[:, 3] # 将数据拆分为训练集和测试集, 指定测试集占比 test_size # 指定随机种子 random_state(可以任意值但必须确定), 锁定拆分行为 x_train, x_test, y_train, y_test = train_test_split( x, y, test_size=0.25, random_state=5) # 使用训练集训练模型 lr = LinearRegression() lr.fit(x_train, y_train) # 求得模型参数 print('权重 w:', lr.coef_, '截距 b:', lr.intercept_) # 调用模型进行预测 y_hat = lr.predict(x_test) # 结果可视化 import matplotlib.pyplot as plt plt.rcParams['font.family'] = 'SimHei' plt.rcParams['axes.unicode_minus'] = False plt.rcParams['font.size'] = 10 plt.scatter(x_train, y_train, c='orange', label='训练集') plt.scatter(x_test, y_test, c='g', marker='D', label='测试集') plt.plot(x, lr.predict(x), 'r-') plt.legend() plt.xlabel('花瓣长度') plt.ylabel('花瓣宽度') plt.show() 权重 w: [0.42] 截距 b: -0.370615595909495 # 模型评估 from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score print('MSE:', mean_squared_error(y_test, y_hat)) print('RMSE:', np.sqrt(mean_squared_error(y_test, y_hat))) print('MAE:', mean_absolute_error(y_test, y_hat)) print('训练集R²:', r2_score(y_train, lr.predict(x_train))) # 可换成 lr.score(x_train, y_train) print('测试集R²:', r2_score(y_test, y_hat)) # 可换成 lr.score(x_test, y_test) MSE: 0.047866747643216113 RMSE: 0.21878470614559903 MAE: 0.1543808898175286 训练集R²: 0.9317841638431329 测试集R²: 0.9119955391492289 列二, 多元线性回归模型: 波士顿房价预测\nimport numpy as np from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split from sklearn.datasets import load_boston import pandas as pd boston = load_boston() x, y = boston.data, boston.target df = pd.DataFrame(np.concatenate([x, y.reshape(-1, 1)], axis=1), columns=boston.feature_names.tolist() + ['MEDV']) # 部分数据 df.head(3) CRIM\tZN\tINDUS\tCHAS\tNOX\tRM\tAGE\tDIS\tRAD\tTAX\tPTRATIO\tB\tLSTAT\tMEDV 0\t0.00632\t18.0\t2.31\t0.0\t0.538\t6.575\t65.2\t4.0900\t1.0\t296.0\t15.3\t396.90\t4.98\t24.0 1\t0.02731\t0.0\t7.07\t0.0\t0.469\t6.421\t78.9\t4.9671\t2.0\t242.0\t17.8\t396.90\t9.14\t21.6 2\t0.02729\t0.0\t7.07\t0.0\t0.469\t7.185\t61.1\t4.9671\t2.0\t242.0\t17.8\t392.83\t4.03\t34.7 x_train, x_test, y_train, y_test = train_test_split( x, y, test_size=0.25, random_state=5) lr = LinearRegression() lr.fit(x_train, y_train) print('权重:', lr.coef_) print('截距:', lr.intercept_) y_hat = lr.predict(x_test) print('训练集R²:', lr.score(x_train, y_train)) print('测试集R²:', lr.score(x_test, y_test)) # 假如获取了一间房屋的数据, 预测其房价 room_data = np.array([0.00732, 17.0, 1.31, 1.0, 0.638, 7.575, 62.2, 5.0900, 1.0, 296.0, 15.3, 396.90, 4.98]).reshape(1, -1) y_price = lr.predict(room_data) print('房屋价格:', y_price) 权重: [-1.53e-01 4.79e-02 -8.60e-03 2.58e+00 -1.46e+01 3.96e+00 -7.92e-03 -1.46e+00 3.45e-01 -1.25e-02 -9.19e-01 1.32e-02 -5.17e-01] 截距: 32.214120389743606 训练集R²: 0.7468034208269784 测试集R²: 0.7059096071098042 房屋价格: [33.62] 多元线性回归在空间中, 可表示为一个超平面去拟合空间中的数据点\n",
    "description": "",
    "tags": null,
    "title": "线性回归",
    "uri": "/statistics/statistics3/"
  },
  {
    "content": "序列类型有许多通用的操作，在各个知识点都有详细的介绍，下面将他们综合起来比较。\n序列类型都可以使用操作符 + 进行拼接，使用 += 拼接并赋值（range 除外），但对于可变序列类型，使用 += 是原地修改：\na = [1,2] print(id(a)) a += [3,4] id(a), a 2612604344328\r(2612604344328, [1, 2, 3, 4])\r'12'+'34', [1,2]+[3,4], (1,2)+(3,4) ('1234', [1, 2, 3, 4], (1, 2, 3, 4))\r序列类型都可以使用操作符 * 进行重复并拼接，使用 *= 拼接并赋值（range 除外），但对于可变序列类型，使用 *= 是原地修改：\n'1'*2, 2*[1], (1,)*2 ('11', [1, 1], (1, 1))\ra = [1] print(id(a)) a *= 2 id(a), a 2612603190024\r(2612603190024, [1, 1])\r序列类型都可以使用 * 进行拆包，拆包之后需要包含在列表，元组，集合中，或用于函数传参：\n[*(1,2)], (*[1,2],), {*range(1,3)} ([1, 2], (1, 2), {1, 2})\rprint(*'123') 1 2 3\r序列类型都可以使用索引或切片操作取值，但对于可变序列类型，还可以使用索引或切片操作进行内容的增、删、改：\na = '1234' b = [1,2,3,4] c = (1,2,3,4) d = range(1,5) a[0], b[0], c[0], d[0] ('1', 1, 1, 1)\ra[1:3], b[1:3], c[1:3], d[1:3] ('23', [2, 3], (2, 3), range(2, 4))\rb[1:3] = 'abc' b [1, 'a', 'b', 'c', 4]\r序列类型都有方法 index 和 count，但字符串和字节串的 count 方法可以指定范围（具体详见各知识点的方法）：\n'1234'.index('23'),\\ [1,2,3,4].index(2),\\ range(1,4).index(2) (1, 1, 1)\r'1231'.count('1',1,3),\\ (1,2,3,1).count(1) (0, 2)\r",
    "description": "",
    "tags": null,
    "title": "序列通用操作",
    "uri": "/python/05_sequence/04_common_operations/"
  },
  {
    "content": "元组可以使用 + 拼接，拼接后按原来的顺序排列：\n(4,5,6) + (1,2,3) (4, 5, 6, 1, 2, 3)\r1,2,3 + 4,5,6 (1, 2, 7, 5, 6)\r+ 操作符可以与 = 连用，拼接同时赋值，元组是不可变的，该操作是创建了一个新元组：\na = 1,2,3 print(id(a)) a += 4,5,6 id(a), a 2741588191344\r(2741587773864, (1, 2, 3, 4, 5, 6))\r元组还可使用 * 进行 n 次重复拼接：\n(1,)*3 (1, 1, 1)\r当 n 小于 1 时，得到空元组：\n(1,2,3)*0 ()\r元组中的元素如果是可变对象，* 重复拼接后，可变对象的性质同 列表操作符 知识点一样，仍然是同一个对象的多次引用：\na = ([],) b = a*3 # 在元组 a 的第一个元素中加入 1 a[0].append(1) b ([1], [1], [1])\r同列表一样可以用 *=，重复拼接并赋值：\na = 1, a *= 3 a (1, 1, 1)\r元组是可迭代对象，所以可以用 * 将元组拆包：\n{*(1,1,2,3)} {1, 2, 3}\r",
    "description": "",
    "tags": null,
    "title": "元组操作符",
    "uri": "/python/04_tuple/04_operator/"
  },
  {
    "content": "可以通过创建新的异常类来自定义代码执行错误引发的异常。许多标准模块定义了它们自己的异常，以报告它们定义的函数中可能出现的错误。\n异常通常应该直接或间接地从 Exception 类派生。定义的异常类，可以执行任何其他类可以执行的任何操作，但通常保持简单，只提供一些属性，这 些属性允许处理程序为异常提取有关错误的信息。\n在创建可能引发多个不同错误的模块时，通常的做法是为该模块定义的异常创建基类，并为不同错误条件创建特定异常类的子类。大多数异常都定义为名称以 Error 结尾，类似于标准异常的命名:\nclass Error(Exception): \"\"\"Base class for exceptions in this module.\"\"\" pass class InputError(Error): \"\"\"Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error \"\"\" def __init__(self, expression, message): self.expression = expression self.message = message class TransitionError(Error): \"\"\"Raised when an operation attempts a state transition that's not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed \"\"\" def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message raise InputError(3/1,'分母不能为 1') ---------------------------------------------------------------------------\rInputError Traceback (most recent call last)\r\u003cipython-input-2-d0c6938bc1c4\u003e in \u003cmodule\u003e\r29 self.message = message\r30 ---\u003e 31 raise InputError(3/1,'分母不能为 1')\rInputError: (3.0, '分母不能为 1')\r",
    "description": "",
    "tags": null,
    "title": "自定义异常",
    "uri": "/python/13_exception/04_user_defined/"
  },
  {
    "content": "内置函数 bin()，Python 官方文档描述如下：\nhelp(bin) Help on built-in function bin in module builtins:\rbin(number, /)\rReturn the binary representation of an integer.\r\u003e\u003e\u003e bin(2796202)\r'0b1010101010101010101010'\r返回给定整数的二进制表示形式的字符串。\nbin(123) '0b1111011'\r0b1111011 123\r",
    "description": "",
    "tags": null,
    "title": "bin() 整数的二进制形式",
    "uri": "/python/11_built-in_function/05_bin/"
  },
  {
    "content": "字典方法 dict.get()，Python 官方文档描述如下：\nhelp(dict.get) Help on method_descriptor:\rget(self, key, default=None, /)\rReturn the value for key if key is in the dictionary, else default.\r获取字典的项目，如果 key 存在于字典中则返回 key 的值，否则返回 default 指定的值，默认为 None。\nd = {'a':1, 'b':2} d.get('a') 1\rprint(d.get('c')) None\rd.get('c', 3) 3\r",
    "description": "",
    "tags": null,
    "title": "dict.get 获取某个键的值",
    "uri": "/python/07_dictionary/05_dict.get/"
  },
  {
    "content": "try 语句有另一个可选子句 finally，用于定义必须在所有情况下执行的清理操作（详见 try 语句）。\n例如，在 finally 子句中关闭打开的文件：\ndef read_file(): try: f = open('../11_built-in_function/test.txt', encoding='utf-8') return f.read() except OSError: print('不能打开') finally: print('执行清理操作') f.close() read_file() # 先执行关闭，在执行返回 执行清理操作\r'xue.cn\\n\\n自学是门手艺'\r如果 finally 子句中引发了新的异常，清理操作本身无效，则达不到清理目的：\ndef read_file(): try: f = open('../11_built-in_function/test.txt', encoding='utf-8') return f.read() except OSError: print('不能打开') finally: print(执行清理操作) # 清理操作引发异常 f.close() read_file() ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-13-af7cdb6d88f0\u003e in \u003cmodule\u003e\r10 f.close()\r11 ---\u003e 12 read_file() # 先执行关闭，在执行返回\r\u003cipython-input-13-af7cdb6d88f0\u003e in read_file()\r7 print('不能打开')\r8 finally:\r----\u003e 9 print(执行清理操作) # 清理操作引发异常\r10 f.close()\r11 NameError: name '执行清理操作' is not defined\r某些对象（例如文件对象）定义了在不再需要该对象时，要执行的标准清理操作，无论使用该对象的操作是成功还是失败，清理操作都会被执行。此时使用 with 语句允许像文件这样的对象能够以一种确保它们得到及时和正确的清理的方式使用。\nwith 语句相当于将引发异常情况下的清理操作放到了 except 子句中，正常情况下的清理操作放到了 finally 子句中。详情见 with 语句。\ndef read_file(): with open('../11_built-in_function/test.txt', encoding='utf-8') as f: return f.read() read_file() 'xue.cn\\n\\n自学是门手艺'\r",
    "description": "",
    "tags": null,
    "title": "finally 清理操作",
    "uri": "/python/13_exception/05_finally/"
  },
  {
    "content": "列表方法 list.append()，Python 官方文档描述如下：\nhelp(list.append) Help on method_descriptor:\rappend(self, object, /)\rAppend object to the end of the list.\r在列表的末尾添加一个元素。相当于 a[len(a):] = [x]（a 是一个列表）。添加的元素可以是任何对象。\n_list = [1,2] _list.append('abc') _list.append(list.append) _list [1, 2, 'abc', \u003cmethod 'append' of 'list' objects\u003e]\r该方法是一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 None), 直接对原列表进行修改：\n_list = [] a = _list.append('') print(a) None\r",
    "description": "",
    "tags": null,
    "title": "list.append 添加一个元素",
    "uri": "/python/03_list/05_list.append/"
  },
  {
    "content": "官方文档\nPandas 是 Python 的核心数据分析支持库, 基于 NumPy 创建, 它使 python 成为强大而高效的数据分析环境\n一, 数据结构 pandas 的数据结构是基于 numpy 的, 因此其有着 numpy 的基因, 许多操作和大部分函数与 numpy 类似\npandas 的数据结构其实是 numpy 数组数据对象 array 的容器, 在 pandas 中有了索引结构, 可以利用索引来取 array 或 array 中的元素\npandas 中最重要的数据结构是 Series 和 DataFrame\n1, 创建 Series 和 DataFrame 创建时若不指定索引, 将自动生成(从 0 开始)\nSeries 是一维, 只有行索引, 而 DataFrame 有行和列索引\n创建方式灵活多变, 可以查看参数, 根据要求传参进行创建\nimport numpy as np import pandas as pd s = pd.Series(range(3)) s 0 0 1 1 2 2 dtype: int64 df = pd.DataFrame(range(3)) print(df) 0 0 0 1 1 2 2 s.values array([0, 1, 2], dtype=int64) df.values array([[0], [1], [2]], dtype=int64) 可见，pandas 的数据结构，是 numpy 的 array 对象的容器，着意味着 pandas 在处理数据时，可以使用 numpy 的所有函数和方法\ns = pd.Series(range(3), index=list('abc')) s a 0 b 1 c 2 dtype: int64 df = pd.DataFrame({'A': range(3), 'B': list('jkl')}, index=list('abc')) print(df) A B a 0 j b 1 k c 2 l dict_1 = {'a': 0, 'b': 1, 'c': 2} dict_2 = {'a': range(3), 'b': list('jkl')} s = pd.Series(dict_1) s a 0 b 1 c 2 dtype: int64 df1 = pd.DataFrame(dict_1, index=['A']) print(df1) a b c A 0 1 2 df2 = pd.DataFrame(dict_2) print(df2) a b 0 0 j 1 1 k 2 2 l # df2 每一列是一个类型的 array 对象 df2[\"a\"].values, df2[\"b\"].values (array([0, 1, 2], dtype=int64), array(['j', 'k', 'l'], dtype=object)) 2, Series 和 DataFrame 的常用属性 大部分属性和 numpy 一样\ns = pd.Series(1, index=list('abc')) s a 1 b 1 c 1 dtype: int64 dict_3 = {'a': range(3), 'b': list('jkl')} df = pd.DataFrame(dict_3) print(df) a b 0 0 j 1 1 k 2 2 l # 查看形状, 形状不包括 索引 s.shape, df.shape ((3,), (3, 2)) # 获取索引 s.index, df.index, df.columns (Index(['a', 'b', 'c'], dtype='object'), RangeIndex(start=0, stop=3, step=1), Index(['a', 'b'], dtype='object')) # 查看元素个数 s.size, df.size (3, 6) # 查看数据类型 s.dtype, df.dtypes (dtype('int64'), a int64 b object dtype: object) # 查看值 s.values, df.values, df['a'].values (array([1, 1, 1], dtype=int64), array([[0, 'j'], [1, 'k'], [2, 'l']], dtype=object), array([0, 1, 2], dtype=int64)) 3, Series 和 DataFrame 结构理解 从上述可以看出, pandas 数据结构的值, 是一个 array 对象. 对于 df, 每一列的值取出来也是一个 array 对象, 并且每一列可以是不同的数据类型\n需要注意的是, DataFrame 每一列取出来, 整体是一个 Series , 因此 DataFrame 又可以看成 Series 的容器\ns = pd.Series(1, index=list('abc')) dict_3 = {'a': range(3), 'b': list('jkl')} df = pd.DataFrame(dict_3) type(s), type(df['a']), type(df) (pandas.core.series.Series, pandas.core.series.Series, pandas.core.frame.DataFrame) Series 和 DataFrame 可以有多层索引\ns.index = [['a', 'b', 'c'], [1, 2, 3]] s a 1 1 b 2 1 c 3 1 dtype: int64 df.index = [['a', 'b', 'c'], [1, 2, 3]] print(df) a b a 1 0 j b 2 1 k c 3 2 l 二, 数据结构操作, 处理与计算 1, 查看 Series 和 DataFrame 数据信息常用方法 a = np.random.randint(1, 9, (6, 2)) s = pd.Series(a[:, 0]) s 0 4 1 7 2 4 3 8 4 1 5 8 dtype: int32 df = pd.DataFrame(a) print(df) 0 1 0 4 4 1 7 4 2 4 8 3 8 3 4 1 3 5 8 1 # 查看前 5 行(默认) s.head() print(df.head()) 0 1 0 4 4 1 7 4 2 4 8 3 8 3 4 1 3 # 查看后 5 行(默认) s.tail() print(df.tail()) 0 1 1 7 4 2 4 8 3 8 3 4 1 3 5 8 1 # 查看详情, Series 没有该方法 df.info() \u003cclass 'pandas.core.frame.DataFrame'\u003e RangeIndex: 6 entries, 0 to 5 Data columns (total 2 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 0 6 non-null int32 1 1 6 non-null int32 dtypes: int32(2) memory usage: 176.0 bytes # 查看统计量 s.describe() print(df.describe()) 0 1 count 6.000000 6.000000 mean 5.333333 3.833333 std 2.804758 2.316607 min 1.000000 1.000000 25% 4.000000 3.000000 50% 5.500000 3.500000 75% 7.750000 4.000000 max 8.000000 8.000000 2, 数据的直接计算 Series 和 DataFrame 的数据可以像 numpy 的数组一样直接进行计算, 索引相同的行、列进行计算, 索引不同的 NaN 填充\na = np.random.randint(1, 9, (6, 2)) s = pd.Series(a[:, 0]) df = pd.DataFrame(a) print(df) 0 1 0 6 2 1 1 6 2 5 1 3 3 2 4 5 5 5 2 6 df1 = pd.DataFrame(a, columns=[1, 'b']) print(df1 * df) 0 1 b 0 NaN 12 NaN 1 NaN 6 NaN 2 NaN 5 NaN 3 NaN 6 NaN 4 NaN 25 NaN 5 NaN 12 NaN s 0 6 1 1 2 5 3 3 4 5 5 2 dtype: int32 s1 = pd.Series(a[:, 0], index=['a', 1, 2, 3, 4, 5]) s1 a 6 1 1 2 5 3 3 4 5 5 2 dtype: int32 s**2 + s1 0 NaN 1 2.0 2 30.0 3 12.0 4 30.0 5 6.0 a NaN dtype: float64 # 笛卡儿积展开 print(s + df) 0 1 2 3 4 5 0 12 3 NaN NaN NaN NaN 1 7 7 NaN NaN NaN NaN 2 11 2 NaN NaN NaN NaN 3 9 3 NaN NaN NaN NaN 4 11 6 NaN NaN NaN NaN 5 8 7 NaN NaN NaN NaN 3, Series 和 DataFrame 下标和索引切片操作 3.01, Series 和 DataFrame 下标切片取值 Series 和 DataFrame 下标切片取值有许多不同之处\ns1 = pd.Series(a[:, 0], index=['a', 1, 2, 3, 4, 5]) s1 a 6 1 1 2 5 3 3 4 5 5 2 dtype: int32 a = np.random.randint(1, 9, (6, 2)) df1 = pd.DataFrame(a, columns=[1, 'b']) print(df1) 1 b 0 6 5 1 3 8 2 8 7 3 1 5 4 7 4 5 6 3 # 此方法 DataFrame 只能取行, 不能取列 s1[1:3] 1 1 2 5 dtype: int32 print(df1[0:2]) 1 b 0 6 5 1 3 8 s1[[1, 4]] 1 1 4 5 dtype: int32 同 numpy 一样, 可以条件取值, 此方法常用来筛选和重新赋值等\ns1[s1\u003e4] a 6 2 5 4 5 dtype: int32 print(df1[df1\u003e5]) 1 b 0 6.0 NaN 1 NaN 8.0 2 8.0 7.0 3 NaN NaN 4 7.0 NaN 5 6.0 NaN print(df1[df1 == 4]) 1 b 0 NaN NaN 1 NaN NaN 2 NaN NaN 3 NaN NaN 4 NaN 4.0 5 NaN NaN 3.02, Series 和 DataFrame 索引切片取值 索引切片取值, 左右都包含\ns1 = pd.Series(a[:, 0], index=['a', 1, 2, 3, 4, 5]) s1 a 6 1 3 2 8 3 1 4 7 5 6 dtype: int32 a = np.random.randint(1, 9, (6, 2)) df1 = pd.DataFrame(a, columns=[1, 'b']) print(df1) 1 b 0 3 5 1 7 3 2 8 7 3 7 6 4 3 7 5 5 4 # 需要将索引转换类型 s1.index = s1.index.astype(str) df1.index = df1.index.astype(str) s1['a':'2'] a 6 1 3 2 8 dtype: int32 print(df1['1':'3']) 1 b 1 7 3 2 8 7 3 7 6 print(df1['1':'3'][[1]]) 1 1 7 2 8 3 7 df1['b'] 0 5 1 3 2 7 3 6 4 7 5 4 Name: b, dtype: int32 print(df1[['b', 1]]) b 1 0 5 3 1 3 7 2 7 8 3 6 7 4 7 3 5 4 5 3.03, 用 iloc 方法取值(推荐) 上述的取值太复杂麻烦, iloc 方法传入下标取值更方便且条理清晰. 存在多层索引时, iloc 按最内层索引取值\ns1 = pd.Series(a[:, 0], index=['a', 1, 2, 3, 4, 5]) s1 a 3 1 7 2 8 3 7 4 3 5 5 dtype: int32 a = np.random.randint(1, 9, (6, 2)) df1 = pd.DataFrame(a, columns=[1, 'b']) print(df1) 1 b 0 8 8 1 6 2 2 1 6 3 6 3 4 8 3 5 3 8 # 右不包含 s1.iloc[0:3] a 3 1 7 2 8 dtype: int32 print(df1.iloc[0:5:2]) 1 b 0 8 8 2 1 6 4 8 3 print(df1.iloc[[1, 4, 2], 0:]) 1 b 1 6 2 4 8 3 2 1 6 3.04, 用 loc 方法 loc 方法取值左右都包含, 传入索引标签取值\ns1 = pd.Series(a[:, 0], index=['a', 1, 2, 3, 4, 5]) s1 a 8 1 6 2 1 3 6 4 8 5 3 dtype: int32 a = np.random.randint(1, 9, (6, 2)) df1 = pd.DataFrame(a, columns=[1, 'b']) print(df1) 1 b 0 4 3 1 6 4 2 1 6 3 6 2 4 6 1 5 2 7 # 需要将索引转换类型 s1.index = s1.index.astype(str) df1.index = df1.index.astype(str) s1.loc['a':'2'] a 8 1 6 2 1 dtype: int32 df1.loc['1':'3', 'b'] 1 4 2 6 3 2 Name: b, dtype: int32 3.05, 利用切片修改数据 利用切片修改数据, 其实就是取值重新赋值\nimport numpy as np import pandas as pd df = pd.DataFrame(np.random.rand(5, 4), index=list('abcde'), columns=list('ABCD')) print(df[df\u003e0.5]) A B C D a 0.908869 NaN NaN 0.584259 b NaN NaN 0.940409 NaN c 0.947715 0.898426 0.745999 NaN d NaN 0.855820 NaN 0.742919 e NaN NaN NaN 0.593532 # 将大于 0.5 的数据换成 nan df[df\u003e0.5] = np.nan print(df) A B C D a NaN 0.019952 0.004443 NaN b 0.391594 0.406059 NaN 0.021655 c NaN NaN NaN 0.067905 d 0.238486 NaN 0.232429 NaN e 0.378054 0.422029 0.386046 NaN # 将 A 列全部改成 1 , 增加一列 E, 值为 0 df['A'] = 1 # 与 df.A = 1 等价 df['E'] = 0 print(df) A B C D E a 1 0.019952 0.004443 NaN 0 b 1 0.406059 NaN 0.021655 0 c 1 NaN NaN 0.067905 0 d 1 NaN 0.232429 NaN 0 e 1 0.422029 0.386046 NaN 0 # 行列值互换 df.loc[['a', 'c'], ['A', 'C']] = df.loc[['c', 'a'], ['C', 'A']].to_numpy() print(df) A B C D E a NaN 0.019952 1.000000 NaN 0 b 1.000000 0.406059 NaN 0.021655 0 c 0.004443 NaN 1.000000 0.067905 0 d 1.000000 NaN 0.232429 NaN 0 e 1.000000 0.422029 0.386046 NaN 0 # 只要 B 不为 nan 的数据 print(df[df['B'] == df['B']]) A B C D E a NaN 0.019952 1.000000 NaN 0 b 1.0 0.406059 NaN 0.021655 0 e 1.0 0.422029 0.386046 NaN 0 三, Series 和 DataFrame 的处理和计算函数 1, 索引 在 pandas 里, 索引非常重要, 一个行索引, 通常就是数据的一条记录(例如一个人的信息), 一个列索引就是数据的一个特征(例如某个人的性别, 年龄等), 通过索引能够更方便数据处理与计算\nimport numpy as np import pandas as pd s = pd.Series(np.random.rand(4), index=list('abcd')) s a 0.930171 b 0.263544 c 0.684870 d 0.702820 dtype: float64 df = pd.DataFrame(np.random.rand(4, 4), index=list('abcd'), columns=list('ABCD')) print(df) A B C D a 0.236401 0.972351 0.030862 0.438897 b 0.774498 0.670181 0.379171 0.941319 c 0.701424 0.732319 0.882208 0.527572 d 0.442419 0.597335 0.258880 0.420447 reindex 索引重排, 新增的索引 nan 填充, 缺少索引的数据舍弃\n# 新增 e 舍弃 d, 有许多参数可以调节 s1 = s.reindex(list('bcae')) s1 b 0.263544 c 0.684870 a 0.930171 e NaN dtype: float64 df2 = df.reindex(columns=list('BCAE')) print(df2) B C A E a 0.972351 0.030862 0.236401 NaN b 0.670181 0.379171 0.774498 NaN c 0.732319 0.882208 0.701424 NaN d 0.597335 0.258880 0.442419 NaN sort_index 索引排序\n# 默认 True 升序, 许多参数可调, DataFrame 只排行索引 s2 = s.sort_index(ascending=False) s2 d 0.702820 c 0.684870 b 0.263544 a 0.930171 dtype: float64 df2 = df.sort_index(ascending=False) print(df2) A B C D d 0.442419 0.597335 0.258880 0.420447 c 0.701424 0.732319 0.882208 0.527572 b 0.774498 0.670181 0.379171 0.941319 a 0.236401 0.972351 0.030862 0.438897 rename, set_index, reset_index 设置索引\n# 注意参数及传参方式 s3 = s.rename(index={'a': 'f'}) s3 f 0.930171 b 0.263544 c 0.684870 d 0.702820 dtype: float64 df3 = df.rename(lambda x: x + x) print(df3) A B C D aa 0.236401 0.972351 0.030862 0.438897 bb 0.774498 0.670181 0.379171 0.941319 cc 0.701424 0.732319 0.882208 0.527572 dd 0.442419 0.597335 0.258880 0.420447 # Series 没有此方法 df4 = df.set_index([['a','b','c','d'], [1, 2, 3, 4]]) print(df4) A B C D a 1 0.236401 0.972351 0.030862 0.438897 b 2 0.774498 0.670181 0.379171 0.941319 c 3 0.701424 0.732319 0.882208 0.527572 d 4 0.442419 0.597335 0.258880 0.420447 # 可以将某列设为索引, 默认不保留原列, 可设参数 drop 保留 df5 = df.set_index('A') print(df5) B C D A 0.236401 0.972351 0.030862 0.438897 0.774498 0.670181 0.379171 0.941319 0.701424 0.732319 0.882208 0.527572 0.442419 0.597335 0.258880 0.420447 # 将索引设为列(drop=True将其删除), 多层索引时可选某层 df6 = df4.reset_index(level=1) print(df6) level_1 A B C D a 1 0.236401 0.972351 0.030862 0.438897 b 2 0.774498 0.670181 0.379171 0.941319 c 3 0.701424 0.732319 0.882208 0.527572 d 4 0.442419 0.597335 0.258880 0.420447 df7 = df5.reset_index() print(df7) A B C D 0 0.236401 0.972351 0.030862 0.438897 1 0.774498 0.670181 0.379171 0.941319 2 0.701424 0.732319 0.882208 0.527572 3 0.442419 0.597335 0.258880 0.420447 # 索引可以设置名字, 设置索引还可以通过获取索引重新赋值 # DataFrame 还可以转置 df5.index.name 'A' df5.index = list('abcd') # 重设索引后, 索引名消失 print(df5) B C D a 0.972351 0.030862 0.438897 b 0.670181 0.379171 0.941319 c 0.732319 0.882208 0.527572 d 0.597335 0.258880 0.420447 print(df5.T) a b c d B 0.972351 0.670181 0.732319 0.597335 C 0.030862 0.379171 0.882208 0.258880 D 0.438897 0.941319 0.527572 0.420447 多层索引\nar = [['a', 'b', 'c'], [1, 2, 3]] tup = list(zip(*ar)) pd.MultiIndex.from_tuples(tup) MultiIndex([('a', 1), ('b', 2), ('c', 3)], ) index = pd.MultiIndex.from_product(ar) s = pd.Series(range(9), index=index) s a 1 0 2 1 3 2 b 1 3 2 4 3 5 c 1 6 2 7 3 8 dtype: int64 pd.MultiIndex.from_frame(pd.DataFrame(np.random.randint(1, 9, (2, 3)))) MultiIndex([(6, 5, 3), (8, 1, 3)], names=[0, 1, 2]) 2, 增删与合并数据 import numpy as np import pandas as pd df = pd.DataFrame(np.random.randint(1, 9, (4, 5))) print(df) 0 1 2 3 4 0 4 8 5 3 7 1 7 3 5 2 4 2 3 2 5 7 2 3 1 2 4 8 7 insert 在指定位置前插入数据\n# Series 没有该方法 df.insert(2, 'A', 1) print(df) 0 1 A 2 3 4 0 4 8 1 5 3 7 1 7 3 1 5 2 4 2 3 2 1 5 7 2 3 1 2 1 4 8 7 append 在数据最后增加数据\ndf1 = pd.DataFrame(np.random.rand(4, 4), index=list('abcd'), columns=list('ABCD')) print(df1) A B C D a 0.748362 0.049567 0.603201 0.383037 b 0.658722 0.225040 0.107199 0.416646 c 0.024967 0.161487 0.338823 0.889825 d 0.584625 0.582264 0.228898 0.817555 # Series 只能传 Series df.iloc[0].append(pd.Series(8)) 0 4 1 8 A 1 2 5 3 3 4 7 0 8 dtype: int64 # DataFrame 可以在行后面增加, 也可在列后面新增 print(df.append([1])) 0 1 A 2 3 4 0 4 8.0 1.0 5.0 3.0 7.0 1 7 3.0 1.0 5.0 2.0 4.0 2 3 2.0 1.0 5.0 7.0 2.0 3 1 2.0 1.0 4.0 8.0 7.0 0 1 NaN NaN NaN NaN NaN print(df.append(df1, ignore_index=True)) 0 1 A 2 3 4 B C D 0 4.0 8.0 1.000000 5.0 3.0 7.0 NaN NaN NaN 1 7.0 3.0 1.000000 5.0 2.0 4.0 NaN NaN NaN 2 3.0 2.0 1.000000 5.0 7.0 2.0 NaN NaN NaN 3 1.0 2.0 1.000000 4.0 8.0 7.0 NaN NaN NaN 4 NaN NaN 0.748362 NaN NaN NaN 0.049567 0.603201 0.383037 5 NaN NaN 0.658722 NaN NaN NaN 0.225040 0.107199 0.416646 6 NaN NaN 0.024967 NaN NaN NaN 0.161487 0.338823 0.889825 7 NaN NaN 0.584625 NaN NaN NaN 0.582264 0.228898 0.817555 drop 删除指定数据\ndf['A'].drop(1), df.drop(1, axis=1) (0 1 2 1 3 1 Name: A, dtype: int64, 0 A 2 3 4 0 4 1 5 3 7 1 7 1 5 2 4 2 3 1 5 7 2 3 1 1 4 8 7) concat 主要用于行索引的合并\nprint(df) 0 1 A 2 3 4 0 4 8 1 5 3 7 1 7 3 1 5 2 4 2 3 2 1 5 7 2 3 1 2 1 4 8 7 print(df1) A B C D a 0.748362 0.049567 0.603201 0.383037 b 0.658722 0.225040 0.107199 0.416646 c 0.024967 0.161487 0.338823 0.889825 d 0.584625 0.582264 0.228898 0.817555 # 默认按列索引合并, 保留合并后的全部索引, 缺失用 nan 填充 # join 参数可控制合并的方式: inner 只留下都有的索引 print(pd.concat([df, df1])) 0 1 A 2 3 4 B C D 0 4.0 8.0 1.000000 5.0 3.0 7.0 NaN NaN NaN 1 7.0 3.0 1.000000 5.0 2.0 4.0 NaN NaN NaN 2 3.0 2.0 1.000000 5.0 7.0 2.0 NaN NaN NaN 3 1.0 2.0 1.000000 4.0 8.0 7.0 NaN NaN NaN a NaN NaN 0.748362 NaN NaN NaN 0.049567 0.603201 0.383037 b NaN NaN 0.658722 NaN NaN NaN 0.225040 0.107199 0.416646 c NaN NaN 0.024967 NaN NaN NaN 0.161487 0.338823 0.889825 d NaN NaN 0.584625 NaN NaN NaN 0.582264 0.228898 0.817555 df2 = pd.DataFrame(np.random.rand(5, 4), index=list('abcde'), columns=list('BCDE')) print(df2) B C D E a 0.061604 0.505149 0.247496 0.474912 b 0.431163 0.828570 0.302236 0.695153 c 0.238852 0.998520 0.516351 0.665134 d 0.383425 0.684282 0.857654 0.621860 e 0.186235 0.006509 0.612608 0.875893 print(pd.concat([df1, df2], join='inner')) B C D a 0.049567 0.603201 0.383037 b 0.225040 0.107199 0.416646 c 0.161487 0.338823 0.889825 d 0.582264 0.228898 0.817555 a 0.061604 0.505149 0.247496 b 0.431163 0.828570 0.302236 c 0.238852 0.998520 0.516351 d 0.383425 0.684282 0.857654 e 0.186235 0.006509 0.612608 join 主要用于行索引的合并\n# 默认以左边(df1)为基准, 相同列名需要加以区分 # how 参数: outer 全保留, inner 只保留共同部分 print(df1.join(df2, lsuffix='_1', rsuffix='_2')) A B_1 C_1 D_1 B_2 C_2 D_2 \\ a 0.748362 0.049567 0.603201 0.383037 0.061604 0.505149 0.247496 b 0.658722 0.225040 0.107199 0.416646 0.431163 0.828570 0.302236 c 0.024967 0.161487 0.338823 0.889825 0.238852 0.998520 0.516351 d 0.584625 0.582264 0.228898 0.817555 0.383425 0.684282 0.857654 E a 0.474912 b 0.695153 c 0.665134 d 0.621860 print(df1.join(df2, how='outer', lsuffix='_1', rsuffix='_2')) A B_1 C_1 D_1 B_2 C_2 D_2 \\ a 0.748362 0.049567 0.603201 0.383037 0.061604 0.505149 0.247496 b 0.658722 0.225040 0.107199 0.416646 0.431163 0.828570 0.302236 c 0.024967 0.161487 0.338823 0.889825 0.238852 0.998520 0.516351 d 0.584625 0.582264 0.228898 0.817555 0.383425 0.684282 0.857654 e NaN NaN NaN NaN 0.186235 0.006509 0.612608 E a 0.474912 b 0.695153 c 0.665134 d 0.621860 e 0.875893 merge 合并\ndf1 = pd.DataFrame({'K': ['K0', 'K1', 'K2', 'K3'], 'A': ['A0', 'A1', 'M2', 'M3'], 'B': ['B0', 'B1', 'B2', 'B3']}) print(df1) K A B 0 K0 A0 B0 1 K1 A1 B1 2 K2 M2 B2 3 K3 M3 B3 df2 = pd.DataFrame({'K': ['K0', 'K1', 'K4', 'K5'], 'C': ['C0', 'C1', 'M2', 'M3'], 'D': ['D0', 'D1', 'D2', 'D3']}) print(df2) K C D 0 K0 C0 D0 1 K1 C1 D1 2 K4 M2 D2 3 K5 M3 D3 # 默认 inner, 全部列都保留, # 但只保留两者都有的列(K),且列内容相同(K0,K1)的 行, 行索引都舍弃 print(pd.merge(df1, df2)) K A B C D 0 K0 A0 B0 C0 D0 1 K1 A1 B1 C1 D1 # 可以选择以某一个为基准, 需要合并的列内容, 以及保留某一个的索引 print(pd.merge(df1, df2, how='left')) # 以 df1 为准, 匹配不上的保留 df1 K A B C D 0 K0 A0 B0 C0 D0 1 K1 A1 B1 C1 D1 2 K2 M2 B2 NaN NaN 3 K3 M3 B3 NaN NaN # df1 的 A 列与 df2 的 C 列有内容相同需要合并 print(pd.merge(df1, df2, left_on='A', right_on='C')) K_x A B K_y C D 0 K2 M2 B2 K4 M2 D2 1 K3 M3 B3 K5 M3 D3 3, 数据选择与处理 import numpy as np import pandas as pd np.random.seed(0) df = pd.DataFrame(np.random.randint(1, 9, (6, 6)), index=list('abcdef'), columns=list('ABCDEF')) print(df) A B C D E F a 5 8 6 1 4 4 b 4 8 2 4 6 3 c 5 8 7 1 1 5 d 3 2 7 8 8 7 e 1 2 6 2 6 1 f 2 5 4 1 4 6 sample 随机选择数据\n# 可以指定数量, 也可以按比例选 df.iloc[0].sample(2) # Series 也可 E 4 B 8 Name: a, dtype: int32 print(df.sample(3)) A B C D E F a 5 8 6 1 4 4 b 4 8 2 4 6 3 c 5 8 7 1 1 5 print(df.sample(frac=0.5, axis=1)) F C D a 4 6 1 b 3 2 4 c 5 7 1 d 7 7 8 e 1 6 2 f 6 4 1 where 按条件选择数据, 且可替换, 替换的是条件之外的数据\ndf.A.where(df.A\u003e3) # Series 也可 a 5.0 b 4.0 c 5.0 d NaN e NaN f NaN Name: A, dtype: float64 df1 = df.where(df\u003e1) print(df1) A B C D E F a 5.0 8 6 NaN 4.0 4.0 b 4.0 8 2 4.0 6.0 3.0 c 5.0 8 7 NaN NaN 5.0 d 3.0 2 7 8.0 8.0 7.0 e NaN 2 6 2.0 6.0 NaN f 2.0 5 4 NaN 4.0 6.0 print(df.where(df==1, lambda x: x*x)) A B C D E F a 25 64 36 1 16 16 b 16 64 4 16 36 9 c 25 64 49 1 1 25 d 9 4 49 64 64 49 e 1 4 36 4 36 1 f 4 25 16 1 16 36 isin 生成布尔数组来选择数据\nvalues = [3, 5, 7, 'a', 'c'] df.C.isin(values) a False b False c True d True e False f False Name: C, dtype: bool df.A[df.C.isin(values)] c 5 d 3 Name: A, dtype: int32 print(df[df.isin(values)]) A B C D E F a 5.0 NaN NaN NaN NaN NaN b NaN NaN NaN NaN NaN 3.0 c 5.0 NaN 7.0 NaN NaN 5.0 d 3.0 NaN 7.0 NaN NaN 7.0 e NaN NaN NaN NaN NaN NaN f NaN 5.0 NaN NaN NaN NaN print(df[df.index.isin(values)]) A B C D E F a 5 8 6 1 4 4 c 5 8 7 1 1 5 isna( isnull ) 和 notna ( notnull ) 生成布尔数组\n# 可以 pd 调用, 也可 DataFrame 或 Series 调用 pd.isna(df1.D) a True b False c True d False e False f True Name: D, dtype: bool df1.D.isnull() a True b False c True d False e False f True Name: D, dtype: bool print(df1.isna()) A B C D E F a False False False True False False b False False False False False False c False False False True True False d False False False False False False e True False False False False True f False False False True False False dropna 删除 nan, fillna 将 nan 填充\nprint(df1) A B C D E F a 5.0 8 6 NaN 4.0 4.0 b 4.0 8 2 4.0 6.0 3.0 c 5.0 8 7 NaN NaN 5.0 d 3.0 2 7 8.0 8.0 7.0 e NaN 2 6 2.0 6.0 NaN f 2.0 5 4 NaN 4.0 6.0 # 默认有 nan 的行就删除, 参数 all: 全部 nan 才删除 df1.A.dropna() # Series 也可 a 5.0 b 4.0 c 5.0 d 3.0 f 2.0 Name: A, dtype: float64 print(df1.dropna()) A B C D E F b 4.0 8 2 4.0 6.0 3.0 d 3.0 2 7 8.0 8.0 7.0 print(df1.dropna(axis=1, how='all')) A B C D E F a 5.0 8 6 NaN 4.0 4.0 b 4.0 8 2 4.0 6.0 3.0 c 5.0 8 7 NaN NaN 5.0 d 3.0 2 7 8.0 8.0 7.0 e NaN 2 6 2.0 6.0 NaN f 2.0 5 4 NaN 4.0 6.0 # 给定填充值, 默认全部填充, # 可以指定填充数, 填充方式 df1.A.fillna(0) # Series 也可 a 5.0 b 4.0 c 5.0 d 3.0 e 0.0 f 2.0 Name: A, dtype: float64 print(df1.fillna(0)) A B C D E F a 5.0 8 6 0.0 4.0 4.0 b 4.0 8 2 4.0 6.0 3.0 c 5.0 8 7 0.0 0.0 5.0 d 3.0 2 7 8.0 8.0 7.0 e 0.0 2 6 2.0 6.0 0.0 f 2.0 5 4 0.0 4.0 6.0 print(df1.fillna(0, limit=1)) # 每一列填充一个 A B C D E F a 5.0 8 6 0.0 4.0 4.0 b 4.0 8 2 4.0 6.0 3.0 c 5.0 8 7 NaN 0.0 5.0 d 3.0 2 7 8.0 8.0 7.0 e 0.0 2 6 2.0 6.0 0.0 f 2.0 5 4 NaN 4.0 6.0 # ffill 前面值填充, bfill 后面值填充 print(df1.fillna(method='ffill')) A B C D E F a 5.0 8 6 NaN 4.0 4.0 b 4.0 8 2 4.0 6.0 3.0 c 5.0 8 7 4.0 6.0 5.0 d 3.0 2 7 8.0 8.0 7.0 e 3.0 2 6 2.0 6.0 7.0 f 2.0 5 4 2.0 4.0 6.0 print(df1.fillna(method='bfill')) A B C D E F a 5.0 8 6 4.0 4.0 4.0 b 4.0 8 2 4.0 6.0 3.0 c 5.0 8 7 8.0 8.0 5.0 d 3.0 2 7 8.0 8.0 7.0 e 2.0 2 6 2.0 6.0 6.0 f 2.0 5 4 NaN 4.0 6.0 drop_duplicates 去重\ndf.iloc[0] = df.iloc[1] print(df) A B C D E F a 4 8 2 4 6 3 b 4 8 2 4 6 3 c 5 8 7 1 1 5 d 3 2 7 8 8 7 e 1 2 6 2 6 1 f 2 5 4 1 4 6 # 默认保留第 1 条数据 df.A.drop_duplicates() # Series 也可 a 4 c 5 d 3 e 1 f 2 Name: A, dtype: int32 print(df.drop_duplicates()) A B C D E F a 4 8 2 4 6 3 c 5 8 7 1 1 5 d 3 2 7 8 8 7 e 1 2 6 2 6 1 f 2 5 4 1 4 6 nlargest 选择某列(某几列)值最大的几条数据, 对应还有 nsmallest\nprint(df.nlargest(3, 'A')) A B C D E F c 5 8 7 1 1 5 a 4 8 2 4 6 3 b 4 8 2 4 6 3 print(df.nsmallest(3, 'A')) A B C D E F e 1 2 6 2 6 1 f 2 5 4 1 4 6 d 3 2 7 8 8 7 print(df.nlargest(3, ['C', 'D'])) A B C D E F d 3 2 7 8 8 7 c 5 8 7 1 1 5 e 1 2 6 2 6 1 filter 按索引查找数据, 可正则模糊查找\nprint(df.filter(['A', 'B'])) A B a 4 8 b 4 8 c 5 8 d 3 2 e 1 2 f 2 5 print(df.filter(like='a', axis=0)) A B C D E F a 4 8 2 4 6 3 print(df.filter(regex='c', axis=0)) A B C D E F c 5 8 7 1 1 5 assign 用于新增辅助列\nprint(df.assign(A1=df['A']/df['F'])) A B C D E F A1 a 4 8 2 4 6 3 1.333333 b 4 8 2 4 6 3 1.333333 c 5 8 7 1 1 5 1.000000 d 3 2 7 8 8 7 0.428571 e 1 2 6 2 6 1 1.000000 f 2 5 4 1 4 6 0.333333 print(df.assign(A1=lambda x:x.A/x.F)) A B C D E F A1 a 4 8 2 4 6 3 1.333333 b 4 8 2 4 6 3 1.333333 c 5 8 7 1 1 5 1.000000 d 3 2 7 8 8 7 0.428571 e 1 2 6 2 6 1 1.000000 f 2 5 4 1 4 6 0.333333 clip 将过大或过小的数据去掉, 并填充指定值\n# 小于指定值的填充为指定值小者, 大于的反之 print(df.clip(2, 6)) A B C D E F a 4 6 2 4 6 3 b 4 6 2 4 6 3 c 5 6 6 2 2 5 d 3 2 6 6 6 6 e 2 2 6 2 6 2 f 2 5 4 2 4 6 print(df.clip(df.A, df.A + 2, axis=0)) A B C D E F a 4 6 4 4 6 4 b 4 6 4 4 6 4 c 5 7 7 5 5 5 d 3 3 5 5 5 5 e 1 2 3 2 3 1 f 2 4 4 2 4 4 4, 数据分组聚合计算 聚合计算和 numpy 函数基本一样, 例如 sum, count, median, min, max, mean, var, std 等, 比较容易\n更为重要的, 是将数据按需分组后再聚合运算\nimport numpy as np import pandas as pd np.random.seed(0) df = pd.DataFrame(np.random.randint(1, 9, (6, 6)), index=list('abcdef'), columns=list('ABCDEF')) df.A.where(df.A\u003e3, 'M', inplace=True) df.A.where(df.A=='M', 'N', inplace=True) df.B.where(df.B\u003e3, 'J', inplace=True) df.B.where(df.B=='J', 'K', inplace=True) df.C.where(df.C\u003c5, np.nan, inplace=True) print(df) A B C D E F a N K NaN 1 4 4 b N K 2.0 4 6 3 c N K NaN 1 1 5 d M J NaN 8 8 7 e M J NaN 2 6 1 f M K 4.0 1 4 6 # 默认按列加和, 将 nan 转换为 0 来计算 df.sum() A NNNMMM B KKKJJK C 6.0 D 17 E 29 F 26 dtype: object df.sum(axis=1, numeric_only=True) a 9.0 b 15.0 c 7.0 d 23.0 e 9.0 f 15.0 dtype: float64 # 按行统计忽略 nan df.count(axis=1) a 5 b 6 c 5 d 5 e 5 f 6 dtype: int64 print(df.set_index([\"A\", \"B\"]).groupby(level=\"A\").count()) C D E F A M 1 3 3 3 N 1 3 3 3 print(df.set_index([\"A\", \"B\"]).groupby(level=\"B\").count()) C D E F B J 0 2 2 2 K 2 4 4 4 value_counts 统计 Series 中每个值出现次数\n# Series 的值统计, 也即是 DataFrame 的每一列中每个值的数量统计 df.A.value_counts() N 3 M 3 Name: A, dtype: int64 df.C.value_counts() 2.0 1 4.0 1 Name: C, dtype: int64 # 可以统计索引, 可按百分比显示, 可以分组统计 df.set_index('A').index.value_counts(normalize=True) N 0.5 M 0.5 Name: A, dtype: float64 df.D.value_counts(bins=2) (0.992, 4.5] 5 (4.5, 8.0] 1 Name: D, dtype: int64 nunique 去重计数, 统计每一行或列不同值的数量\ndf.nunique() A 2 B 2 C 2 D 4 E 4 F 6 dtype: int64 quantile 计算分位数\nprint(df.quantile([0.3, 0.6])) C D E F 0.3 2.6 1.0 4.0 3.5 0.6 3.2 2.0 6.0 5.0 cut 与 qcut 数据分箱\n# 将某一列中的值分别分到一个范围中, 默认左不包含右包含 # 这对分组非常有用, 例如年龄分段 c = pd.cut(df.D, bins=[0, 3, 8], labels=['0到3', '3到8']) c a 0到3 b 3到8 c 0到3 d 3到8 e 0到3 f 0到3 Name: D, dtype: category Categories (2, object): ['0到3' \u003c '3到8'] # 根据数值的频率来选择间隔, 使每个分段里值的个数相同 pd.qcut(df.D, q=2) a (0.999, 1.5] b (1.5, 8.0] c (0.999, 1.5] d (1.5, 8.0] e (1.5, 8.0] f (0.999, 1.5] Name: D, dtype: category Categories (2, interval[float64, right]): [(0.999, 1.5] \u003c (1.5, 8.0]] pd.qcut(df.D, q=2).value_counts() (0.999, 1.5] 3 (1.5, 8.0] 3 Name: D, dtype: int64 rank 用来给数据排名, 例如销售额, 成绩等\n# 有多种排名方式可供选择, 举一例: 给 D 列排名 df['排名'] = df.D.rank(method='dense', ascending=False) print(df) A B C D E F 排名 a N K NaN 1 4 4 4.0 b N K 2.0 4 6 3 2.0 c N K NaN 1 1 5 4.0 d M J NaN 8 8 7 1.0 e M J NaN 2 6 1 3.0 f M K 4.0 1 4 6 4.0 sort_values 数据排序\ndf.sort_values('排名', inplace=True) print(df) A B C D E F 排名 d M J NaN 8 8 7 1.0 b N K 2.0 4 6 3 2.0 e M J NaN 2 6 1 3.0 a N K NaN 1 4 4 4.0 c N K NaN 1 1 5 4.0 f M K 4.0 1 4 6 4.0 shift 数据移动, 索引不变\nprint(df.shift(2)) A B C D E F 排名 d NaN NaN NaN NaN NaN NaN NaN b NaN NaN NaN NaN NaN NaN NaN e M J NaN 8.0 8.0 7.0 1.0 a N K 2.0 4.0 6.0 3.0 2.0 c M J NaN 2.0 6.0 1.0 3.0 f N K NaN 1.0 4.0 4.0 4.0 print(df.shift(-1, axis=1)) A B C D E F 排名 d J NaN 8 8 7 1.0 NaN b K 2.0 4 6 3 2.0 NaN e J NaN 2 6 1 3.0 NaN a K NaN 1 4 4 4.0 NaN c K NaN 1 1 5 4.0 NaN f K 4.0 1 4 6 4.0 NaN agg 和 apply 传入函数进行高级聚合运算, 已存在的函数用字符串形式传入, 自定义函数传入函数名\ndf.agg('sum') A MNMNNM B JKJKKK C 6.0 D 17 E 29 F 26 排名 18.0 dtype: object print(df.agg(['max', 'min'])) A B C D E F 排名 max N K 4.0 8 8 7 4.0 min M J 2.0 1 1 1 1.0 print(df.apply(['max', 'min'])) A B C D E F 排名 max N K 4.0 8 8 7 4.0 min M J 2.0 1 1 1 1.0 🔺🔺 groupby 按指定的列(行)中不同值分组, 与前面的聚合函数组合出无限的变化, 满足各种需求\n# 分组后是一个迭代器, 可以查看分组, 获取分组 df.groupby('A') \u003cpandas.core.groupby.generic.DataFrameGroupBy object at 0x0000021E8A8295B0\u003e df.groupby('A').groups {'M': ['d', 'e', 'f'], 'N': ['b', 'a', 'c']} print(df.groupby('A').get_group('M')) A B C D E F 排名 d M J NaN 8 8 7 1.0 e M J NaN 2 6 1 3.0 f M K 4.0 1 4 6 4.0 # 分别取出 M 和 N 中 F 列任意排名的数据 def get_second(x, m, n): return x[x[m].rank(method='dense', ascending=False)==n] # 通过修改 n 参数取出任意排名 print(df.groupby('A').apply(get_second, m='F', n=3.0)) A B C D E F 排名 A M e M J NaN 2 6 1 3.0 N b N K 2.0 4 6 3 2.0 # 将上述 cut 分箱得到的数据用来分组统计 print(df.groupby(c).count()) A B C D E F 排名 D 0到3 4 4 1 4 4 4 4 3到8 2 2 1 2 2 2 2 # 对不同的列作不同的分组聚合运算 print(df.groupby('A').agg({'E': ['mean', 'max'], 'F': 'sum'})) E F mean max sum A M 6.000000 8 14 N 3.666667 6 12 5, 数据透视与窗口函数 import numpy as np import pandas as pd np.random.seed(0) df = pd.DataFrame(np.random.randint(1, 20, (4, 5))) df.columns = list('ABCDE') print(df) A B C D E 0 13 16 1 4 4 1 8 10 19 5 7 2 13 2 7 8 15 3 18 6 14 9 10 melt 将列索引展开成数据\n# 默认全部展开 df1 = pd.melt(df, id_vars=['A', 'B'], var_name='F', value_name='G') print(df1) A B F G 0 13 16 C 1 1 8 10 C 19 2 13 2 C 7 3 18 6 C 14 4 13 16 D 4 5 8 10 D 5 6 13 2 D 8 7 18 6 D 9 8 13 16 E 4 9 8 10 E 7 10 13 2 E 15 11 18 6 E 10 print(pd.melt(df, id_vars=['A', 'B'], value_vars=['C'])) A B variable value 0 13 16 C 1 1 8 10 C 19 2 13 2 C 7 3 18 6 C 14 pivot 将行值展开成为列索引\nprint(df1.pivot(columns='F', values=['A', 'B'])) A B F C D E C D E 0 13.0 NaN NaN 16.0 NaN NaN 1 8.0 NaN NaN 10.0 NaN NaN 2 13.0 NaN NaN 2.0 NaN NaN 3 18.0 NaN NaN 6.0 NaN NaN 4 NaN 13.0 NaN NaN 16.0 NaN 5 NaN 8.0 NaN NaN 10.0 NaN 6 NaN 13.0 NaN NaN 2.0 NaN 7 NaN 18.0 NaN NaN 6.0 NaN 8 NaN NaN 13.0 NaN NaN 16.0 9 NaN NaN 8.0 NaN NaN 10.0 10 NaN NaN 13.0 NaN NaN 2.0 11 NaN NaN 18.0 NaN NaN 6.0 pivot_table 与 groupby + 聚合函数 类似, 可以对表格进行各种需求的透视\ndf1.index = list('LMNLMNLMNLMN') df1.reset_index(inplace=True) df1.rename(columns={'index': 'Q'}, inplace=True) print(df1) Q A B F G 0 L 13 16 C 1 1 M 8 10 C 19 2 N 13 2 C 7 3 L 18 6 C 14 4 M 13 16 D 4 5 N 8 10 D 5 6 L 13 2 D 8 7 M 18 6 D 9 8 N 13 16 E 4 9 L 8 10 E 7 10 M 13 2 E 15 11 N 18 6 E 10 print(df1.pivot_table(index=['Q', 'F'], aggfunc='mean')) A B G Q F L C 15.5 11 7.5 D 13.0 2 8.0 E 8.0 10 7.0 M C 8.0 10 19.0 D 15.5 11 6.5 E 13.0 2 15.0 N C 13.0 2 7.0 D 8.0 10 5.0 E 15.5 11 7.0 print(df1.pivot_table(index='Q', columns='F', values='A', aggfunc=['mean', 'sum'])) mean sum F C D E C D E Q L 15.5 13.0 8.0 31 13 8 M 8.0 15.5 13.0 8 31 13 N 13.0 8.0 15.5 13 8 31 rolling 将数据依次移动指定尺寸的窗口并进行聚合运算\ndf1.rolling(3) Rolling [window=3,center=False,axis=0,method=single] print(df1) Q A B F G 0 L 13 16 C 1 1 M 8 10 C 19 2 N 13 2 C 7 3 L 18 6 C 14 4 M 13 16 D 4 5 N 8 10 D 5 6 L 13 2 D 8 7 M 18 6 D 9 8 N 13 16 E 4 9 L 8 10 E 7 10 M 13 2 E 15 11 N 18 6 E 10 # 移动 3 条数据加和一次作为一条新数据, # 前面默认 nan 填充 print(df1.rolling(3).sum()) A B G 0 NaN NaN NaN 1 NaN NaN NaN 2 34.0 28.0 27.0 3 39.0 18.0 40.0 4 44.0 24.0 25.0 5 39.0 32.0 23.0 6 34.0 28.0 17.0 7 39.0 18.0 22.0 8 44.0 24.0 21.0 9 39.0 32.0 20.0 10 34.0 28.0 26.0 11 39.0 18.0 32.0 # 可以设置最小观察值(必须小于移动尺寸) # 可以用高级函数聚合运算 print(df1.rolling(len(df1), min_periods=1).sum()) A B G 0 13.0 16.0 1.0 1 21.0 26.0 20.0 2 34.0 28.0 27.0 3 52.0 34.0 41.0 4 65.0 50.0 45.0 5 73.0 60.0 50.0 6 86.0 62.0 58.0 7 104.0 68.0 67.0 8 117.0 84.0 71.0 9 125.0 94.0 78.0 10 138.0 96.0 93.0 11 156.0 102.0 103.0 print(df1.rolling(2).agg(['sum', np.max])) A B G sum amax sum amax sum amax 0 NaN NaN NaN NaN NaN NaN 1 21.0 13.0 26.0 16.0 20.0 19.0 2 21.0 13.0 12.0 10.0 26.0 19.0 3 31.0 18.0 8.0 6.0 21.0 14.0 4 31.0 18.0 22.0 16.0 18.0 14.0 5 21.0 13.0 26.0 16.0 9.0 5.0 6 21.0 13.0 12.0 10.0 13.0 8.0 7 31.0 18.0 8.0 6.0 17.0 9.0 8 31.0 18.0 22.0 16.0 13.0 9.0 9 21.0 13.0 26.0 16.0 11.0 7.0 10 21.0 13.0 12.0 10.0 22.0 15.0 11 31.0 18.0 8.0 6.0 25.0 15.0 def f(x): return x.iloc[0] * x.iloc[1] print(df1[['A', 'G']]) A G 0 13 1 1 8 19 2 13 7 3 18 14 4 13 4 5 8 5 6 13 8 7 18 9 8 13 4 9 8 7 10 13 15 11 18 10 print(df1.rolling(2)['A', 'G'].apply(f)) A G 0 NaN NaN 1 104.0 19.0 2 104.0 133.0 3 234.0 98.0 4 234.0 56.0 5 104.0 20.0 6 104.0 40.0 7 234.0 72.0 8 234.0 36.0 9 104.0 28.0 10 104.0 105.0 11 234.0 150.0 6, 文本字符串处理 文本字符串处理方法基本上和 python 内建字符串方法同名, 这些方法自动忽略 nan 进行处理\n方法较多, 常用的举几个例子:\ns = pd.Series(['A_1', 'B_2', 'C_3', np.nan], index=['A_a', 'B_b', 'C_c', 'D']) s A_a A_1 B_b B_2 C_c C_3 D NaN dtype: object # 取值 s.str[0] A_a A B_b B C_c C D NaN dtype: object s.str[:2] A_a A_ B_b B_ C_c C_ D NaN dtype: object s.index.str[2] Index(['a', 'b', 'c', nan], dtype='object') # 拆分 s.str.split('_') A_a [A, 1] B_b [B, 2] C_c [C, 3] D NaN dtype: object s.str.split('_').str.get(0) A_a A B_b B C_c C D NaN dtype: object s.str.split('_').str[1] A_a 1 B_b 2 C_c 3 D NaN dtype: object s A_a A_1 B_b B_2 C_c C_3 D NaN dtype: object print(s.str.split('_', expand=True)) 0 1 A_a A 1 B_b B 2 C_c C 3 D NaN NaN # 替换, 默认正则匹配, 可传入函数高级匹配 s.str.replace('_', '') A_a A1 B_b B2 C_c C3 D NaN dtype: object s.index.str.replace('_', '') Index(['Aa', 'Bb', 'Cc', 'D'], dtype='object') # 拼接 s1 = s.str.split('_').str[0] s1 A_a A B_b B C_c C D NaN dtype: object s1.str.cat() 'ABC' s1.str.cat(sep='_') 'A_B_C' s1.str.cat(sep='_', na_rep='_') 'A_B_C__' s1.str.cat(['1', '2', '3', '4'], na_rep='_') A_a A1 B_b B2 C_c C3 D _4 dtype: object # 提取 s A_a A_1 B_b B_2 C_c C_3 D NaN dtype: object print(s.str.extract(r'([ABC])_(\\d)')) 0 1 A_a A 1 B_b B 2 C_c C 3 D NaN NaN 三, 时间序列 时间序列对数据分析很重要, 很多数据都和时间发生的先后顺序相关\ndate_range 生成时间序列\nimport numpy as np import pandas as pd pd.date_range(start='20200701', end='20200705') DatetimeIndex(['2020-07-01', '2020-07-02', '2020-07-03', '2020-07-04', '2020-07-05'], dtype='datetime64[ns]', freq='D') # 可以指定生成个数与频率等 pd.date_range(start='6/1/2020', periods=5, freq='10D') DatetimeIndex(['2020-06-01', '2020-06-11', '2020-06-21', '2020-07-01', '2020-07-11'], dtype='datetime64[ns]', freq='10D') to_datetime 转换时间格式\n1970年 1 月 1 日 00:00:00 UTC+00:00 时区的时刻称为 epoch time，记为 0，当前时间就是相对于 epoch time 的秒数\n# 获取本地当前时间 from datetime import datetime print(datetime.now()) d = datetime.now().timestamp() print(datetime.fromtimestamp(d)) d 2022-08-20 19:48:43.236534 2022-08-20 19:48:43.237531 1660996123.237531 # 数字形式的时间, 用 to_datetime 转换为时间格式后与上述有差别, # 是由于时区的原因, 转换时区即可一样 print(pd.to_datetime(d, utc=True, unit='s')) d = pd.Series(d) pd.to_datetime(d, utc=True, unit='s').dt.tz_convert('Asia/Shanghai') 2022-08-20 11:48:43.237530880+00:00 0 2022-08-20 19:48:43.237530880+08:00 dtype: datetime64[ns, Asia/Shanghai] # 各种日期格式的转换 print(pd.to_datetime(['07-17-2020', '11-07-2020'], dayfirst=True)) print(pd.to_datetime('2020年7月17日', format='%Y年%m月%d日')) pd.to_datetime(['jul 17, 2020', '2020-07-17', '20200717', '2020/07/17', '2020.07.17', np.nan]) DatetimeIndex(['2020-07-17', '2020-07-11'], dtype='datetime64[ns]', freq=None) 2020-07-17 00:00:00 DatetimeIndex(['2020-07-17', '2020-07-17', '2020-07-17', '2020-07-17', '2020-07-17', 'NaT'], dtype='datetime64[ns]', freq=None) # 可以跳过非时间, 可以转换 DataFrame 但索引名是固定的名称 print(pd.to_datetime(['2020.07.17', '日期'], errors='coerce')) df = pd.DataFrame({'year': [2019, 2020], 'month': [6, 7], 'day': [4, 5]}) pd.to_datetime(df) DatetimeIndex(['2020-07-17', 'NaT'], dtype='datetime64[ns]', freq=None) 0 2019-06-04 1 2020-07-05 dtype: datetime64[ns] df = pd.DataFrame(np.random.randint(0, 10, (5, 2)), index=pd.date_range('20180717', periods=5, freq='200D')) print(df) 0 1 2018-07-17 4 3 2019-02-02 0 3 2019-08-21 5 0 2020-03-08 2 3 2020-09-24 8 1 时间索引取值, between_time 取时间段\nprint(df['2018':'2019']) 0 1 2018-07-17 4 3 2019-02-02 0 3 2019-08-21 5 0 print(df['2019-01':'2020-01']) 0 1 2019-02-02 0 3 2019-08-21 5 0 df.index = pd.date_range('20200717', periods=5, freq='2H') print(df) 0 1 2020-07-17 00:00:00 4 3 2020-07-17 02:00:00 0 3 2020-07-17 04:00:00 5 0 2020-07-17 06:00:00 2 3 2020-07-17 08:00:00 8 1 print(df.between_time('3:00', '7:00')) 0 1 2020-07-17 04:00:00 5 0 2020-07-17 06:00:00 2 3 时间序列作为数据的操作\ndf.index = pd.date_range('20180717', periods=5, freq='100D') df.index.name = '日期' df.reset_index(inplace=True) print(df) 日期 0 1 0 2018-07-17 4 3 1 2018-10-25 0 3 2 2019-02-02 5 0 3 2019-05-13 2 3 4 2019-08-21 8 1 df.日期.dt.day 0 17 1 25 2 2 3 13 4 21 Name: 日期, dtype: int64 df['月份'] = df['日期'].dt.month print(df) 日期 0 1 月份 0 2018-07-17 4 3 7 1 2018-10-25 0 3 10 2 2019-02-02 5 0 2 3 2019-05-13 2 3 5 4 2019-08-21 8 1 8 print(df[df.日期.dt.month \u003e= 5]) 日期 0 1 月份 0 2018-07-17 4 3 7 1 2018-10-25 0 3 10 3 2019-05-13 2 3 5 4 2019-08-21 8 1 8 print(df[df.月份 \u003e= 5]) 日期 0 1 月份 0 2018-07-17 4 3 7 1 2018-10-25 0 3 10 3 2019-05-13 2 3 5 4 2019-08-21 8 1 8 d = df.日期.astype(str).str.split('-', expand=True) print(d) 0 1 2 0 2018 07 17 1 2018 10 25 2 2019 02 02 3 2019 05 13 4 2019 08 21 print(df[d[0] =='2018']) 日期 0 1 月份 0 2018-07-17 4 3 7 1 2018-10-25 0 3 10 四, 数据的导入导出与可视化 1, pandas 可以导入导出多种格式的数据: read_csv, to_csv\nread_json, to_json\nread_html, to_html\nread_excel, to_excel\nread_hdf, to_hdf\n等等\n# 默认读取第一个 sheet, 默认第一行为列索引 df = pd.read_excel(r'./sheet.xlsx', sheet_name=0, header=0) print(df) 名次 战队名 说明 0 1 FPX 四包二战术 1 2 G2 个人能力强 2 3 IG 喜欢打架 3 4 SKT Faker状态低迷 4 5 GRF 上单是短板 5 6 DWG 下路弱 6 7 FNC 欧洲强队 7 8 SPY AD强 8 9 RNG 四保一 9 10 TL 北美强队 # 可以设置将某列作为行索引, 某列作为列索引 df1 = pd.read_excel(r'./sheet.xlsx', sheet_name=1) print(df1) 名次 上单 0 1 GIMGOOM 1 2 WUNDER 2 3 KHAN 3 4 FLANDER 4 5 THESHY 5 6 NUGURI 6 7 BWIPO 7 8 IPMPACT 8 9 LICORICE 9 10 HUNI df2 = pd.read_excel(r'./sheet.xlsx', sheet_name=1, header=1, index_col=0) print(df2) GIMGOOM 1 2 WUNDER 3 KHAN 4 FLANDER 5 THESHY 6 NUGURI 7 BWIPO 8 IPMPACT 9 LICORICE 10 HUNI # 有时需要根据文件调节编码和引擎参数 df = pd.read_csv(r'./ratings_chinses.csv', engine=None, encoding='gbk') print(df) 数量 收获 评分 0 1 1 4 1 2 3 4 2 3 6 4 3 4 47 5 4 5 50 5 .. ... ... .. 105 106 47 5 106 107 50 3 107 108 70 5 108 109 101 4 109 110 110 5 [110 rows x 3 columns] 2, 可视化 import matplotlib.pyplot as plt plt.rcParams['font.family'] = 'Microsoft YaHei' plt.rcParams['font.size'] = 12 df.收获.plot() df['评分'].plot(kind='hist') df.plot(x='数量', y='评分') df.评分.plot.box() jupyter附件 sheet.xlsx (34 KB) ratings_chinses.csv (1 KB) pandas.ipynb (436 KB) ",
    "description": "",
    "tags": null,
    "title": "Pandas 基础快速了解和查询",
    "uri": "/pandas/"
  },
  {
    "content": "集合方法 set.union()，Python 官方文档描述如下：\nhelp(set.union) Help on method_descriptor:\runion(...)\rReturn the union of sets as a new set.\r(i.e. all elements that are in either set.)\r该方法接收任意的位置参数，返回一个所有集合的元素组成的新集合。相当于 a | b | … （a，b 是集合），但方法中的参数可以是可迭代对象。\n{1}.union([2],(3,4)) {1, 2, 3, 4}\r{1} | {2} | {3,4} {1, 2, 3, 4}\r",
    "description": "",
    "tags": null,
    "title": "set.union 并集",
    "uri": "/python/06_set/05_set.union/"
  },
  {
    "content": "字符串方法 str.replace()，Python 官方文档描述如下：\nhelp(str.replace) Help on method_descriptor:\rreplace(self, old, new, count=-1, /)\rReturn a copy with all occurrences of substring old replaced by new.\rcount\rMaximum number of occurrences to replace.\r-1 (the default value) means replace all occurrences.\rIf the optional argument count is given, only the first count occurrences are\rreplaced.\r返回字符串的副本，其中出现的所有子字符串 old 都将被替换为 new。如果给出了可选参数 count，则只替换前 count 次出现。\n'python python'.replace('p','C') 'Cython Cython'\r'python python'.replace('py','Cpy',1) 'Cpython python'\r如果 old 为空字符串，则在每个字符之间（包括前后）插入 new：\n'python python'.replace('','C') 'CpCyCtChCoCnC CpCyCtChCoCnC'\r如果 new 为空字符串，则相当于去除了 old：\n'python python'.replace('p','') 'ython ython'\r",
    "description": "",
    "tags": null,
    "title": "str.replace 替换",
    "uri": "/python/02_string/05_str.replace/"
  },
  {
    "content": "while 语句用于在表达式保持为真的情况下重复地执行。语法如下：\nwhile assignment_expression:\rsuite\relse: # 可选子句\rsuite 对于简单语句可以写为一行，但不推荐。\n这将重复地检验表达式，如果其值为真就执行其下的代码；表达式值为假则如果 else 子句存在就会被执行并终止循环。\ni = 0 while i \u003c 3: print(i); i += 1 0\r1\r2\ri = 0 while i \u003c 3: print(i) i += 1 else: # i 为 3 时执行 print(f'i={i}') print('end') 0\r1\r2\ri=3\rend\r",
    "description": "",
    "tags": null,
    "title": "while",
    "uri": "/python/10_statement/05_while/"
  },
  {
    "content": "函数 return 语句的表达式中包含函数自身的调用，则称该函数为递归函数。\n递归函数必须设定退出条件，并且调用过程能够逐步达到退出条件，否则将引发 RecursionError。\n例如定义一个计算阶乘的函数：\n上述函数的退出条件是 x == 0，并且 return 语句中函数调用的参数是 x-1，第一层调用函数的参数 x 为 5，return 语句进入第二层调用，就变成了 x-1 为 4，依此类推，最终以 0 调用函数，达到了退出条件，但是值还没有最终返回，以退出条件下的返回值层层向上返回，最终得到结果。详情查看 递归函数。\ndef f(x): if x == 0: return 1 else: return f(x-1)*x f(5) 120\r",
    "description": "",
    "tags": null,
    "title": "递归函数",
    "uri": "/python/12_function/05_recursion/"
  },
  {
    "content": "复数包含实部和虚部（带 j 或 J 的部分），分别以一个浮点数表示。在一个数字后面加上 j 或 J，则得到一个实部为零的复数。\n-1j (-0-1j)\r1 + 0j (1+0j)\r看起来实部和虚部并不是以浮点数表示，可以使用 .real 和 .imag，从一个复数中提取这两个部分查看。\n(1 + 0j).real, (1 + 0j).imag (1.0, 0.0)\r-1j.real, -1j.imag (-0.0, -1.0)\r实部和虚部都是以浮点数表示，所以复数可以使用浮点数的所有表示法：\n0.J, .5J, 0.1e-2J, 3_1.1_4J, 01.2e02J (0j, 0.5j, 0.001j, 31.14j, 120j)\r对复数取绝对值，就是计算它的模——实部和虚部平方的和开根号：\nabs(3+4j), (3**2 + 4**2)**0.5 (5.0, 5.0)\r",
    "description": "",
    "tags": null,
    "title": "复数",
    "uri": "/python/01_numeric/05_complex/"
  },
  {
    "content": "逻辑回归和线性回归有类似之处, 都是利用线性加权计算的模型, 但逻辑回归是分类算法, 例如对是否患癌症进行预测, 因变量就是 是 和 否 , 两个类别, 自变量可以是年龄, 性别, 饮食, 作息, 病菌感染等, 自变量既可以是数值变量, 也可以是类别变量\n1, 逻辑回归二分类推导 和线性回归类似, 设自变量为 x, 每个自变量的权重为 w, 令:\n$$\\begin{array}{l} z=w_{1} x_{1}+w_{2} x_{2}+\\cdots+w_{n} x_{n}+b \\ =\\sum_{j=1}^{n} w_{j} x_{j}+b \\ =\\sum_{j=0}^{n} w_{j} x_{j} \\ =\\vec{w}^{T} \\cdot \\vec{x} \\end{array}$$z 是一个连续值, 取值范围(-∞, +∞), 为了实现分类, 一般设置阈值 z = 0, 当 z \u003e 0 时, 将样本判定为一个类别(正例), 该类别设为 1, 当 z ≤ 0 时, 判定为另一个类别(负例), 该类别设为 0, 再设因变量为 y, 从而逻辑回归方程可表示为:\n$y=1, z\u003e0$ $y=0, z \\leq 0$ 上述方程虽然实现了分类, 但提供的信息有限, 因此引入 sigmoid函数 (也叫 Logistic函数), 将 z 映射到 (0, 1) 区间，可以实现二分类的同时, 还能体现将样本分为某个类的可能性, 这个可能性设为 p:\n$$p=\\operatorname{sigmoid}(z)=\\frac{1}{1+e^{-z}}$$sigmoid 函数图像如下:\n于是, 逻辑回归方程又可表示为:\n$y=1, p\u003e0.5$ $y=0, 1-p \\geq 0.5$ 从而可见, 通过比较 p 和 1-p 哪个更大(z 的阈值不取 0 时做出调整即可), 预测结果就是对应的一类\n2, 逻辑回归的损失函数 通过上述推导过程可知, 要得到逻辑回归模型, 最终就是要求得参数 $\\vec{w}^{T}$, 于是将 p 和 1-p 统一, 构造一个损失函数来求 $\\vec{w}^{T}$:\n$$p(y=1 | x ; w)=s(z)$$ $$p(y=0 | x ; w)=1-s(z)$$合并:\n$$p(y | x ; w)=s(z)^{y}(1-s(z))^{1-y}$$上式表示一个样本的概率, 我们要求解能够使所有样本联合概率密度最大的 $\\vec{w}^{T}$ 值, 根据极大似然估计, 所有样本的联合概率密度函数(似然函数)为:\n$$\\begin{array}{l} L(w)=\\prod_{i=1}^{m} p\\left(y^{(i)} | x^{(i)} ; w\\right) \\ =\\prod_{i=1}^{m} s\\left(z^{(i)}\\right)^{y^{(i)}}\\left(1-s\\left(z^{(i)}\\right)\\right)^{1-y^{(i)}} \\end{array}$$取对数, 让累积乘积变累积求和:\n$$\\begin{array}{l} \\ln L(w)=\\ln \\left(\\prod_{i=1}^{m} s\\left(z^{(i)}\\right)^{y^{(i)}}\\left(1-s\\left(z^{(i)}\\right)^{1-y^{(i)}}\\right)\\right) \\ =\\sum_{i=1}^{m}\\left(y^{(i)} \\ln s\\left(z^{(i)}\\right)+\\left(1-y^{(i)}\\right) \\ln \\left(1-s\\left(z^{(i)}\\right)\\right)\\right) \\end{array}$$要求上式最大值, 取反变成求最小值, 就作为逻辑回归的损失函数(交叉熵损失函数):\n$$J(w)=-\\sum_{i=1}^{m}\\left(y^{(i)} \\ln s\\left(z^{(i)}\\right)+\\left(1-y^{(i)}\\right) \\ln \\left(1-s\\left(z^{(i)}\\right)\\right)\\right)$$利用梯度下降法最终求得 $\\vec{w}^{T}$ (省略)\n例, 对鸢尾花实现二分类并分析:\nfrom sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.datasets import load_iris import warnings warnings.filterwarnings('ignore') iris = load_iris() x, y = iris.data, iris.target # 鸢尾花数据集有 3 个类别, 4 个特性, 取两个类别, 两个特性 x = x[y!=0, 2:] y = y[y!=0] # 拆分训练集与测试集 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25, random_state=2) # 训练分类模型 lr = LogisticRegression() lr.fit(x_train, y_train) # 测试 y_hat = lr.predict(x_test) print('权重:', lr.coef_) print('偏置:', lr.intercept_) print('真实值:', y_test) print('预测值:', y_hat) 权重: [[2.54536368 2.15257324]] 偏置: [-16.08741502] 真实值: [2 1 2 1 1 1 1 1 1 1 2 2 2 1 1 1 1 1 2 2 1 1 2 1 2] 预测值: [2 1 1 1 1 1 1 2 1 1 2 2 2 1 1 1 1 1 2 2 1 1 2 1 2] # 样本的真实类别可视化 import matplotlib.pyplot as plt plt.rcParams['font.family'] = 'SimHei' # 取出两种鸢尾花的特征 c1 = x[y==1] c2 = x[y==2] # 绘制样本分布 plt.scatter(x=c1[:, 0], y=c1[:, 1], c='g', label='类别1') plt.scatter(x=c2[:, 0], y=c2[:, 1], c='r', label='类别2') plt.xlabel('花瓣长度') plt.ylabel('花瓣宽度') plt.title('鸢尾花样本分布') plt.legend() plt.show() # 将预测类别和真实类别可视化对比 plt.figure(figsize=(6, 2.2)) plt.plot(y_test, marker='o', ls='', ms=10, c='r', label='真实类别') plt.plot(y_hat, marker='x', ls='', ms=10, c='g', label='预测类别') plt.xlabel('样本序号') plt.ylabel('类别') plt.title('预测结果') plt.legend() plt.show() # 因预测样本所属类别时, 通过比较概率得到结果, # 我们可将结果对应的概率可视化 import numpy as np # 获取预测的概率值 probability = lr.predict_proba(x_test) print('概率:', probability[:5], sep='\\n') index = np.arange(len(x_test)) pro_0 = probability[:, 0] pro_1 = probability[:, 1] # 设置预测结果标签, 对和错 tick_label = np.where(y_test==y_hat, '对', '错') # 绘制堆叠图 plt.figure(figsize=(8, 2)) plt.bar(index, height=pro_0, color='g', label='类别1的概率') plt.bar(index, height=pro_1, color='r', bottom=pro_0, label='类别2的概率', tick_label=tick_label) plt.xlabel('预测结果') plt.ylabel('各类别的概率') plt.title('分类概率') plt.legend() plt.show() 概率: [[0.46933862 0.53066138] [0.98282882 0.01717118] [0.72589695 0.27410305] [0.91245661 0.08754339] [0.80288412 0.19711588]] # 绘制决策边界 # 决策边界: 不同类别的分界线 from matplotlib.colors import ListedColormap # 定义绘制函数 def plot_decision_boundary(model, x, y): color = ['r', 'g', 'b'] marker = ['o', 'v', 'x'] class_label = np.unique(y) cmap = ListedColormap(color[:len(class_label)]) x1_min, x2_min = np.min(x, axis=0) x1_max, x2_max = np.max(x, axis=0) x1 = np.arange(x1_min - 1, x1_max + 1, 0.02) x2 = np.arange(x2_min - 1, x2_max + 1, 0.02) x1, x2 = np.meshgrid(x1, x2) z = model.predict(np.array([x1.ravel(), x2.ravel()]).T).reshape(x1.shape) plt.contourf(x1, x2, z, cmap=cmap, alpha=0.5) for i, class_ in enumerate(class_label): plt.scatter(x=x[y==class_, 0], y=x[y==class_, 1], c=cmap.colors[i], label=class_, marker=marker[i]) plt.legend() plt.show() # 绘制模型在训练集上的决策边界 plot_decision_boundary(lr, x_train, y_train) 拓展 :\n逻辑回归实现多分类\niris = load_iris() x, y = iris.data, iris.target x = x[:, 2:] x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25, random_state=2) lr = LogisticRegression() lr.fit(x_train, y_train) # 测试分类 y_hat = lr.predict(x_test) # 可视化结果 plt.rcParams['axes.unicode_minus']=False plot_decision_boundary(lr, x_test, y_test) ",
    "description": "",
    "tags": null,
    "title": "逻辑回归",
    "uri": "/statistics/statistics4/"
  },
  {
    "content": "名称（标识符）用于指代对象。当名称被绑定到一个对象时，对该名称求值将返回相应对象。当名称未被绑定时，尝试对其求值将引发 NameError 异常。Python 的保留字或称关键字是特殊的名称，不可被用作普通名称，例如不可用做变量名，函数名，模块名。\n# 将 1 绑定名称 a a = 1 a 1\r# 将自定义类对象绑定到名称 A class A: pass A __main__.A\r# 将模块 random 绑定到名称 r import random as r r \u003cmodule 'random' from 'F:\\\\anaconda\\\\lib\\\\random.py'\u003e\r# 迭代的每一项循环绑定到名称 i for i in 'xue': display(i) i 'x'\r'u'\r'e'\r'e'\r# 未绑定的名称 m m ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-4-2469ef96c490\u003e in \u003cmodule\u003e\r1 # 未绑定的名称 m\r----\u003e 2 m\rNameError: name 'm' is not defined\rhelp('keywords') # 保留字 Here is a list of the Python keywords. Enter any keyword to get more help.\rFalse class from or\rNone continue global pass\rTrue def if raise\rand del import return\ras elif in try\rassert else is while\rasync except lambda with\rawait finally nonlocal yield\rbreak for not False = 0 File \"\u003cipython-input-9-223dbc74e028\u003e\", line 1\rFalse = 0\r^\rSyntaxError: cannot assign to False\r检查一个名称是否有效可用字符串方法 str.isidentifier()：\n'for'.isidentifier() True\r'my_name'.isidentifier() True\r'函数'.isidentifier() True\r普通名称命名规则：\n可以使用大部分非标点符号的 Unicode 字符，但请使用 ASCII 范围内 (U+0001..U+007F) 的字符； 习惯使用大写和小写字母 A 至 Z，下划线 _ 以及数字 0 至 9，但不可以数字打头； 长度没有限制，对大小写敏感。 数字一 = 1 数字一 1\rdef 函数(): pass 函数 \u003cfunction __main__.函数()\u003e\r命名模式以下划线字符打头和结尾，有特殊含义的名称（* 代表任意数量可用名称字符）:\n_* 不会被 from module import * 导入。特殊标识符 _ 在交互式解释器中被用来存放最近一次求值结果；它保存在 builtins 模块中。当不处于交互模式时，_ 无特殊含义也没有预定义。\n__*__ 系统定义的名称，这些名称是由解释器及其实现（包括标准库）定义的特殊属性和方法名称。未来的 Python 版本中还将定义更多此类名称。任何情况下任何不遵循文档所显式指明的 __*__ 名称使用方式都可能导致无警告的错误。\n__* 类的私有名称。这种名称在类定义中使用时，会以一种混合形式重写以避免在基类及派生类的 “私有” 属性之间出现名称冲突。例如，出现在一个名为 Ham 的类中的名称 __spam 会被转换为 _Ham__spam。如果类名仅由下划线组成，则不会进行转换。\nb = 100 b 100\r_ 100\rdir(object) ['__class__',\r'__delattr__',\r'__dir__',\r'__doc__',\r'__eq__',\r'__format__',\r'__ge__',\r'__getattribute__',\r'__gt__',\r'__hash__',\r'__init__',\r'__init_subclass__',\r'__le__',\r'__lt__',\r'__ne__',\r'__new__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__setattr__',\r'__sizeof__',\r'__str__',\r'__subclasshook__']\rclass B: __b = 0 dir(B) ['_B__b',\r'__class__',\r'__delattr__',\r'__dict__',\r'__dir__',\r'__doc__',\r'__eq__',\r'__format__',\r'__ge__',\r'__getattribute__',\r'__gt__',\r'__hash__',\r'__init__',\r'__init_subclass__',\r'__le__',\r'__lt__',\r'__module__',\r'__ne__',\r'__new__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__setattr__',\r'__sizeof__',\r'__str__',\r'__subclasshook__',\r'__weakref__']\rdel 语句可删除名称绑定：\nc = 3 print(f'c={c}') del c c c=3\r---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-23-5ba97d2f3254\u003e in \u003cmodule\u003e\r2 print(f'c={c}')\r3 del c\r----\u003e 4 c\rNameError: name 'c' is not defined\r",
    "description": "",
    "tags": null,
    "title": "名称",
    "uri": "/python/16_class/05_name/"
  },
  {
    "content": "元组是不可变序列，通常用一对小括号包围元素，元素之间逗号隔开。元组的元素可以是任何对象。元组类型是 tuple：\ntype((1,2,['1','2'])) tuple\r空元组用一对圆括号表示：\n() ()\r单元组后面必须有一个逗号:\n(1,) (1,)\r除了空元组，括号可以省略，因为决定生成元组的其实是逗号而不是圆括号，圆括号是可选的，但元组是更大的表达式的一部分或会产生语法歧义的情况，括号不能省略：\n1, (1,)\r1, 1+1, ('单元组',) (1, 2, ('单元组',))\r内置函数 tuple() 用来构造元组：\ntuple(), tuple('123') ((), ('1', '2', '3'))\r当元组中包含可变对象（例如列表）时，元组本身不可变（不能增、删、改元组本身的元素），但包含的可变对象仍然具有它的可变性质及其操作，此时的元组不能再作为集合的元素或字典的键：\na = ([1,2],3,3) print(id(a)) del a[0][:] id(a), a 2207053762176\r(2207053762176, ([], 3, 3))\r{a} ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-14-29dfa031a339\u003e in \u003cmodule\u003e\r----\u003e 1 {a}\rTypeError: unhashable type: 'list'\rjupyter附件 01_tuple.ipynb (4 KB) 02_tuple.count.ipynb (1 KB) 03_tuple.index.ipynb (3 KB) 04_operator.ipynb (4 KB) ",
    "description": "",
    "tags": null,
    "title": "元组概述",
    "uri": "/python/04_tuple/"
  },
  {
    "content": "内置函数（类） bool，Python 官方文档描述如下：\nhelp(bool) Help on class bool in module builtins:\rclass bool(int)\r| bool(x) -\u003e bool\r| | Returns True when the argument x is true, False otherwise.\r| The builtins True and False are the only two instances of the class bool.\r| The class bool is a subclass of the class int, and cannot be subclassed.\r| | Method resolution order:\r| bool\r| int\r| object\r| 返回对象 x 的布尔值。省略 x 则返回 False。对象的真值、假值规则如下：\n一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 __bool__() 方法且返回 False 或是定义了 __len__() 方法且返回零。\n下面基本完整地列出了会被视为假值的内置对象:\n被定义为假值的常量: None 和 False。 任何数值类型的零: 0, 0.0, 0j, Decimal(0), Fraction(0, 1) 空的序列和多项集: ‘’, (), [], {}, set(), range(0) type(bool) type\rbool() False\rbool(None) False\rbool('0') True\rbool(' ') True\r",
    "description": "",
    "tags": null,
    "title": "bool 返回对象的布尔值",
    "uri": "/python/11_built-in_function/06_bool/"
  },
  {
    "content": "break 在语法上只会出现于 for 或 while 循环所嵌套的代码。\n它会终结最近的外层循环，如果循环有可选的 else 子句，也会跳过该子句。\n如果一个 for 循环被 break 所终结，该循环的控制变量会保持其当前值。\n当 break 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然后再真正离开该循环。\nfor i in range(6): for j in range(6): if i**2 == j: print(f'i={i},j={j}') print(f'i={i},j={j}') i=0,j=0\ri=1,j=1\ri=2,j=4\ri=5,j=5\rfor i in range(6): for j in range(6): if i**2 == j: print(f'i={i},j={j}') break print(f'i={i},j={j}') i=0,j=0\ri=5,j=0\rfor i in range(6): for j in range(6): if i**2 == j: print(f'i={i},j={j}') break # 控制内层循环 else: # 不会执行 print(f'i={i},j={j}') i=0,j=0\rfor i in range(6): for j in range(6): if i**2 == j: print(f'i={i},j={j}') break else: # 属于外层循环，会执行 print(f'i={i},j={j}') i=0,j=0\ri=5,j=0\rfor i in range(5): try: print(f'3/i={3/i}') except ZeroDivisionError as e: print(e) finally: print(f'i={i}') division by zero\ri=0\r3/i=3.0\ri=1\r3/i=1.5\ri=2\r3/i=1.0\ri=3\r3/i=0.75\ri=4\r# 引发异常直接跳过 break # 无异常则继续执行完 finally 才终止循环 for i in range(5): try: print(f'3/i={3/i}') break except ZeroDivisionError as e: print(e) finally: print(f'i={i}') division by zero\ri=0\r3/i=3.0\ri=1\r",
    "description": "",
    "tags": null,
    "title": "break",
    "uri": "/python/10_statement/06_break/"
  },
  {
    "content": "字典方法 dict.copy()，Python 官方文档描述如下：\nhelp(dict.copy) Help on method_descriptor:\rcopy(...)\rD.copy() -\u003e a shallow copy of D\r返回字典的一个浅拷贝。字典是可变对象，浅拷贝将创建一个新字典，但如果字典中某个 键值对 的值是可变对象，则是同一个对象的多次引用。\nd = {'a':[1,2], 'b':3} print(id(d), d) d1 = d.copy() print(id(d1), d1) 2276967660712 {'a': [1, 2], 'b': 3}\r2276967660784 {'a': [1, 2], 'b': 3}\r# 同一个对象的多次引用 id(d['a']), id(d1['a']) (2276966678024, 2276966678024)\r# 改变一个都会改变 d['a'].extend('34') print(d) print(d1) {'a': [1, 2, '3', '4'], 'b': 3}\r{'a': [1, 2, '3', '4'], 'b': 3}\r",
    "description": "",
    "tags": null,
    "title": "dict.copy 浅拷贝",
    "uri": "/python/07_dictionary/06_dict.copy/"
  },
  {
    "content": "列表方法 list.extend()，Python 官方文档描述如下：\nhelp(list.extend) Help on method_descriptor:\rextend(self, iterable, /)\rExtend list by appending elements from the iterable.\r使用可迭代对象中的所有元素来扩展列表。相当于 a[len(a):] = iterable（a 是一个列表）。\n_list = [1,2] _list.extend('abc') _list [1, 2, 'a', 'b', 'c']\r_list.extend(range(2)) _list [1, 2, 'a', 'b', 'c', 0, 1]\r该方法是一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 None), 直接对原列表进行修改：\n_list = [1,2] a = _list.extend('abc') print(a) None\r",
    "description": "",
    "tags": null,
    "title": "list.extend 加入可迭代对象中元素",
    "uri": "/python/03_list/06_list.extend/"
  },
  {
    "content": "matpotlib官网\n1, 以一个例子开始 matpotlib 绘图非常灵活, 方法和参数繁多, 同样的效果, 可以有很多实现方法, 因此常常让人很混乱和困惑, 理解了绘图的层级结构, 使用起来更得心应手:\n下面将其分四个层级来作说明: 画布 Figure, 绘图对象 Axes, 坐标和图像, 以及图像调整和辅助描述\n# 导入库 import matplotlib.pyplot as plt ''' 设置 rc 参数: 可以用来修改图形的各种默认属性 包括窗体大小, 线条宽度, 颜色, 符号, 字体等等 ''' plt.rcParams['font.family'] = 'Microsoft YaHei' # 字体 plt.rcParams['font.size'] = 18 # 全体字体大小 plt.rcParams['legend.fontsize'] = 12 # 图例标签字体大小 plt.rcParams['axes.unicode_minus'] = False # 正常显示符号 # 创建画布对象 Figure, 可以设置大小等 fig = plt.figure() # 用 add_subplot()在画布上面创建绘图对象 Axes, 默认创建一个 # 也可以用 subplots() 直接将 Figure 和 Axes 一起创建 ax = fig.add_subplot() # 在绘图对象 ax 上绘图, 并设置标签 x = range(-9, 10) y = [n**3 for n in x] ax.plot(x, y, label='曲线') # 绘制点 P(5, 125) ax.scatter(5, 125) # 绘制曲线过 P 点的切线 y1 = [3*(5**2)*(m - 5) + 125 for m in x] ax.plot(x, y1, label='切线') # 一次性设置 ax 的多个属性 ax.set(title='y=x**3', # ax 标题 xlabel='x', # x轴标题 ylabel='y', # y轴标题 xlim=(-10,10), # x轴范围 ylim=(-500, 600), # y轴范围 xticks=range(-10, 11, 2), # x轴刻度和标签 yticks=range(-500, 600, 100) # y轴刻度和标签 ) # 上述属性设置方法, 都可以改为如下方法: # ax.set_title() 或 plt.title() # 注释标注 P 点, (4, 160) 为 P 的坐标 ax.text(4, 160, 'P') # 设置轴标签字体和倾斜度 ax.tick_params(labelsize=12, labelrotation=20) # 去除非 x, y 轴的包围线 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') # 显示每个图的标签 plt.legend(fontsize=15) # 显示 plt.show() 通过上例, 能够对 matplotlib 绘图有初步了解:\n先有一个画布”桌子”, 然后在上面放”画纸”, 有了”画纸”, 就可以开始画图, 然后按照需求去选”笔”, 布局, 着色, 顺便”作诗落款”注释一下\n2, 绘制多个绘图对象 Axes import math fig = plt.figure(figsize=(20, 12), dpi=120) # '222'表示第 2 行, 第 2 列的第 2 个位置 ax1 = fig.add_subplot(222) ax1.plot(range(8), [x**2 for x in range(8)]) # 可以逗号隔开 ax2 = fig.add_subplot(2,2,3) ax2.plot(range(8), [math.sin(x) for x in range(8)]) ax3 = fig.add_subplot(221) # gca() 获取当前绘图对象, 最后绘制的那个 # 如果没有, 将创建一个新的 pg = plt.gca() # 设置属性 pg.set(title='最后绘制的图', xlabel='x轴') pg.set_ylabel('y轴', rotation=0) # 设置 y 轴标签水平显示 pg.plot(range(10), range(10)) # 将 y 轴移动到 x=4 处 pg.spines['left'].set_position(('data', 4)) # 添加网格线, 设置颜色, 透明度 pg.grid(color='r', linestyle='-.', alpha=0.5) plt.show() 有了层次结构的了解, 就可以更潇洒地直接使用 plt 绘图了, 用 plt 直接绘图, 如果不创建画布, 画布 和 绘图对象 自动生成\n下面用常用的图形风格举例(参数非常多, 不做详细介绍):\n3, 折线图 折线图一般用来反映数据的变化情况和趋势\n上面例子中绘制的都是折线图, 下面 将折线图映射成一排排点, 比较数据的分散程度:\nimport numpy as np # 创建两组数据 x1 = np.random.randint(0, 20, size=500) x2 = np.random.randint(2, 10, size=500) # 映射成两排点 plt.figure(figsize=(15, 4)) plt.ylim(-0.5, 1.5) plt.plot(x1, np.zeros(len(x1)), ls='', # 线条设为空 marker='o', # 数据点的样式 ms=10, # 点的大小 label='x1') plt.plot(x2, np.ones(len(x2)), ls='', marker='o', ms=10, label='x2') # 绘出两组数据均值所在位置 plt.axvline(x1.mean(), 0.1, 0.4, # 竖线的范围, 取值为 0~1 之间 ls='--', # 线条样式 label='x1均值') plt.axvline(x2.mean(), 0.6, 0.9, ls='-.', color='r', label='x2均值') # 划出 x2 的范围线 plt.hlines(0.8, x2.min(), x2.max()) plt.legend(fontsize=18) plt.show() 4, 散点图 散点图一般用来反映数据之间关联性(类别和分布规律)\n# 创建数据 y = np.random.randn(2, 100) # 第一个类别 plt.scatter(y[0], y[1], label='第一类') # 第二个类别 plt.scatter(y[0] + 1, y[1] + 3, label='第二类') plt.legend() plt.show() 5, 柱状图 柱状图一般用来比较数据的统计量, 对数据进行直观的比较\n# 接下来 5 天下雨的概率 prob = [0.81, 0.22, 0.63, 0.18, 0.74] # x 轴标签 x = ['第一天', '第二天', '第三天', '第四天', '第五天'] # 绘图并将图赋值给 rects rects = plt.bar(x, prob, width=0.5) # 设置 x 轴标签字体和倾斜度; y 轴范围 plt.xticks(fontsize=12, rotation=45) plt.ylim(0, 1) # 在柱状图上添加概率标注 for rect in rects: height = rect.get_height() plt.text(rect.get_x(), height + 0.01, str(height)) plt.show() # 还可以横向绘制 rects = plt.barh(x, prob, height=0.5) plt.yticks(fontsize=12, rotation=45) plt.xlim(0, 1) # 在柱状图上添加概率标注 for rect in rects: width = rect.get_width() plt.text(width, rect.get_y() + 0.5/2, str(width), va='center') plt.show() # 假设概率大于 0.5 就是下雨, 展示下雨和不下雨, 同时展示概率 # 接下来 5 天下雨的概率 prob1 = [0.81, 0.22, 0.63, 0.18, 0.74] # 不下雨的概率 prob2 = 1 - np.array(prob) # 设置 x 轴标签 x = ['第一天', '第二天', '第三天', '第四天', '第五天'] m = ['下雨' if i \u003e 0.5 else '不下' for i in prob1] n = [x[i] + m[i] for i in range(len(x))] # 绘图 plt.bar(n, prob1, label='下雨的概率') plt.bar(n, prob2, label='不下雨的概率', bottom=prob1) plt.ylim(0, 1) plt.xticks(fontsize=12, rotation=45) plt.legend(fontsize=10, loc='best', bbox_to_anchor=(0.7, 1)) plt.show() 6, 直方图 直方图用来直观地反映数据的总体分布情况\n# 创建数据 np.random.seed(0) data = np.random.normal(30, 5, size=1000) # 30 是数据的均值, 5 是标准差 # 绘制直方图 plt.hist(data, 40, # 组数 density=True # 每组以占比显示 ) # 绘制概率密度曲线 x = np.arange(int(data.min()), int(data.max())) f = lambda x, mu, sigma: np.exp(-((x - mu)**2) / (2 * sigma**2) ) / (sigma * np.sqrt(2 * np.pi)) y = f(x, 30, 5) plt.plot(x, y, ls='-', color='r') plt.show() 上图可以利用基于 matpoltlib 的库 seaborn 绘制更方便:\nimport seaborn as sns sns.displot(data) plt.show() 7, 饼图 饼图用来直观地反映各个类别占比\nplt.rcParams['font.size'] = 14 fig = plt.figure(figsize=(5, 6)) # 准备数据 x = [60, 45, 21, 12, 8, 2] # 每个类别数量 labels = [f'{i}类' for i in range(1, len(x) + 1)] # 类别名 explode = [0.02] * len(x) # 每一块离中心的距离 plt.pie(x, explode=explode, labels=labels, colors=None, # 颜色不配置, 使用默认 autopct='%.1f%%', # 设置百分比标签 pctdistance=0.7, # 设置百分比标签离中心的距离 shadow=False, # 设置阴影 labeldistance=1.05, # 设置类别标签离中心的距离 startangle=180, # 设置绘制起始位置 radius=1.1, # 设置饼图大小 counterclock=False, # 设置顺逆时针 ) plt.legend(fontsize=16, loc='best', bbox_to_anchor=(1, 1)) plt.show() 拓展: 绘制三维立体图\nfrom mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import cm ax = plt.figure().add_subplot(projection='3d') X, Y, Z = axes3d.get_test_data(0.05) ax.contour(X, Y, Z, cmap=cm.coolwarm) # Plot contour curves plt.show() jupyter附件 matplotlib.ipynb (345 KB) ",
    "description": "",
    "tags": null,
    "title": "Matpotlib 快速入门",
    "uri": "/matplotlib/"
  },
  {
    "content": "集合方法 set.intersection()，Python 官方文档描述如下：\nhelp(set.intersection) Help on method_descriptor:\rintersection(...)\rReturn the intersection of two sets as a new set.\r(i.e. all elements that are in both sets.)\r该方法接收任意的位置参数，返回一个所有集合中共有的元素组成的新集合。相当于 a \u0026 b \u0026 … （a，b 是集合），但方法中的参数可以是可迭代对象。\n{1,2,3}.intersection({3,4},[1,5,3]) {3}\r{1,2,3} \u0026 {3,4} \u0026 {1,5,3} {3}\r",
    "description": "",
    "tags": null,
    "title": "set.intersection 交集",
    "uri": "/python/06_set/06_set.intersection/"
  },
  {
    "content": "字符串方法 str.expandtabs()，Python 官方文档描述如下：\nhelp(str.expandtabs) Help on method_descriptor:\rexpandtabs(self, /, tabsize=8)\rReturn a copy where all tab characters are expanded using spaces.\rIf tabsize is not given, a tab size of 8 characters is assumed.\r返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。每 tabsize 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。\n要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。如果字符为制表符 (\\t)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。（制表符本身不会被复制。）\n如果字符为换行符 (\\n) 或回车符 (\\r)，它会被复制并将当前列重设为零。任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。\n'01\\t012\\t0123\\t01234'.expandtabs() '01 012 0123 01234'\r'01\\t012\\t0123\\t01234'.expandtabs(4) '01 012 0123 01234'\r'\\n\\t01\\r2\\t0123\\t01234'.expandtabs(4) '\\n 01\\r2 0123 01234'\r",
    "description": "",
    "tags": null,
    "title": "str.expandtabs 替换制表符",
    "uri": "/python/02_string/06_str.expandtabs/"
  },
  {
    "content": "Python 中绑定对象的名称即为变量。\n人们称呼模块、类、函数和方法对象的名称时，习惯直接指代对象本身，而不是把它们当作变量，例如 random，int，print 等，当将它们绑定到另外的名称时，才称新名称为变量（或化名）。\n# 函数名称 f 绑定自定义函数对象 def f(x, func): print(func(x)) a = '1231' # 变量 a b = [int,list,set] # 变量 b c = f # 名称 f 起别名 c for i in b: # 变量 b 中的项循环赋值给变量 i c(a,i) 1231\r['1', '2', '3', '1']\r{'3', '1', '2'}\r如果名称绑定在一个代码块中，则为该代码块的局部变量，除非声明为 nonlocal 或 global。\n如果名称绑定在模块层级，则为全局变量。(模块代码块的变量既为局部变量又为全局变量。)\n如果变量在一个代码块中被使用但不是在其中定义，则为自由变量。\n# 第一个代码块中全局变量 n n = 100 # 第二个代码块 # random 模块中的全局变量 randint， # 在此为局部变量，引用后赋值给全局变量 r import random r = random.randint # 第三个代码块中 x 为局部变量 # n 和 r 不在该代码块中定义，在该代码块为自由变量 def f(x): print(r(x,n)) f(1) 22\r如果代码块中定义了一个局部变量，则其作用域包含该代码块。如果定义发生于函数代码块中，则其作用域会扩展到该函数所包含的任何代码块，除非有某个被包含代码块引入了对该名称的不同绑定。\nm = 0 n = 1 # 全局变量 n def f(): n = 2 # 局部变量 n print(m,n) f() 0 2\r改变变量作用域，详见 global 语句 和 nonlocal 语句。\n类变量和实例变量：\n在类中定义，仅在类层级修改的变量为类变量，实例也可访问类变量； 以 self.name 命名的变量为实例变量，类不能访问。 class A: a = 1 # 类变量 def __init__(self): self.a = 100 # 实例变量 self.b = 2 a = A() A.a, a.a, a.b (1, 100, 2)\rA.b # 类 A 不能访问它的实例的变量 b ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-11-f92f3bcfde9d\u003e in \u003cmodule\u003e\r----\u003e 1 A.b # 类 A 不能访问它的实例的变量 b\rAttributeError: type object 'A' has no attribute 'b'\r",
    "description": "",
    "tags": null,
    "title": "变量",
    "uri": "/python/16_class/06_variable/"
  },
  {
    "content": "在完成模型训练之后，需要对模型的效果进行评估，根据评估结果继续调整模型的参数, 特征或者算法，以达到满意的结果\n1, 混淆矩阵 将 真正例(TP), 假正例(FP), 真负例(TN), 假负例(FN) 统计于一个方阵中, 观察比较, 评价模型好坏, 矩阵如下:\n混淆矩阵统计数量, 评价不直观也有限, 基于混淆矩阵又延伸出 正确率, 精准率, 召回率, F1(调和平均值), ROC曲线和AUC等\n2, 评估指标分析 正确率:\n$$\\text { 正确率 }=\\frac{T P+T N}{T P+T N+F P+F N}$$正确率, 表示总体(包括正负)预测正确的比率, 在模型对正例和负例的预测准确度差异较大时, 难以评价模型的好坏, 例如正例较多, 负例较少, 正例全部预测对了, 负例只预测对几个, 正确率却可能较高\n精准率:\n$$\\text { 精准率 }=\\frac{T P}{T P+F P}$$精准率, 表示所有预测为正例的结果中 预测正确的正例 的占比, 精准率越高, 说明正例预测正确概率越高, 因此精准率更关注”一击必中”, 比如通过预测找出上涨的概率很高的一支股票\n召回率:\n$$\\text { 召回率 }=\\frac{T P}{T P+F N}$$召回率, 表示所有真实的正例中, 预测正确的正例 的占比, 召回率越高, 说明正例被”召回”的越多, 因此召回率更关注”宁错一千, 不放一个”, 例如通过预测尽可能将新冠肺炎患者全部隔离观察\n调和平均值 F1 :\n$$F 1=\\frac{2 * \\text {精准率} * \\text {召回率}}{\\text {精准率}+\\text {召回率}}$$F1 将综合了精准率和召回率, F1越高, 说明模型预测效果越好, F1 能够直接评估模型的好坏\nROC曲线:\nROC (Receiver Operating Characteristic) 曲线, 用图像来描述分类模型的性能好坏. 图像纵轴为 真 正例率(TPR), 横轴为 假 正例率(FPR):\n$$\\begin{array}{l} T P R=\\text { 召回率 }=\\frac{T P}{T P+F N} \\ F P R=\\frac{F P}{F P+T N} \\end{array}$$上述两式通过取分类模型的不同阈值, 从而计算出不同的值, 绘制出曲线, 曲线必过 (0,0) 和 (1, 1) 两个点, TPR 增长得越快, 曲线越往上凸, 模型的分类性能就越好. 如果 ROC 曲线为对角线, 可将模型理解为随机猜测; 如果 ROC 曲线在 0 点 真 正例率就达到了 1, 此时模型最完美\nAUC:\nAUC (Area Under the Curve), 是 ROC 曲线下面的面积, 因为有时通过 ROC 曲线看不出哪个分类模型性能好, 而 AUC 比较数值就不存在这样的问题\n以鸢尾花数据集做如下练习:\nimport numpy as np from sklearn.datasets import load_iris from sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.metrics import confusion_matrix import matplotlib.pyplot as plt import warnings plt.rcParams[\"font.family\"] = \"SimHei\" plt.rcParams[\"axes.unicode_minus\"] = False plt.rcParams[\"font.size\"] = 12 warnings.filterwarnings(\"ignore\") iris = load_iris() x, y = iris.data, iris.target x = x[y!=0, 2:] y = y[y!=0] x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25, random_state=2) lr = LogisticRegression() lr.fit(x_train, y_train) y_hat = lr.predict(x_test) # 传入真实值与预测值, 创建混淆矩阵 matrix = confusion_matrix(y_true=y_test, y_pred=y_hat) print(matrix) y_hat[y_hat==1].sum() [[15 1] [ 1 8]] 16 # 将混淆矩阵可视化 mat = plt.matshow(matrix, cmap=plt.cm.Blues, alpha=0.5) label = [\"负例\", \"正例\"] # 获取当前的绘图对象 ax = plt.gca() # 设置属性, 设类别 1 为负例 ax.set( xticks=np.arange(matrix.shape[1]), yticks=np.arange(matrix.shape[0]), xticklabels=label, yticklabels=label, title=\"混淆矩阵可视化\\n\", ylabel=\"真实值\", xlabel=\"预测值\") # 设置统计值的位置 for i in range(matrix.shape[0]): for j in range(matrix.shape[1]): plt.text(x=j, y=i, s=matrix[i, j], va=\"center\", ha=\"center\") plt.show() # 计算各个评估指标 from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score print(\"正确率：\", accuracy_score(y_test, y_hat)) # 默认以 1 为正例, 我们将 2 设为正例 print(\"精准率：\", precision_score(y_test, y_hat, pos_label=2)) print(\"召回率：\", recall_score(y_test, y_hat, pos_label=2)) print(\"F1：\", f1_score(y_test, y_hat, pos_label=2)) # 也可以用逻辑回归模型对象的score方法计算正确率 print(\"score方法计算正确率：\", lr.score(x_test, y_test)) 正确率： 0.92 精准率： 0.8888888888888888 召回率： 0.8888888888888888 F1： 0.8888888888888888 score方法计算正确率： 0.92 # 还可以用 classification_report 方法直接计算各个指标 from sklearn.metrics import classification_report print(classification_report(y_true=y_test, y_pred=y_hat)) precision recall f1-score support 1 0.94 0.94 0.94 16 2 0.89 0.89 0.89 9 accuracy 0.92 25 macro avg 0.91 0.91 0.91 25 weighted avg 0.92 0.92 0.92 25 # 绘制 ROC曲线 和计算 AUC from sklearn.metrics import roc_curve, auc, roc_auc_score iris = load_iris() x, y = iris.data, iris.target x = x[y!=0, 2:] y = y[y!=0] x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25, random_state=2) # 设置模型参数(有默认值可以不设), 并进行训练 # 不同的参数训练结果不一样, 需要注意参数之间关系 lr = LogisticRegression(multi_class=\"ovr\", solver=\"liblinear\") # lr = LogisticRegression(multi_class=\"multinomial\") lr.fit(x_train, y_train) # 获取样本的概率 probo = lr.predict_proba(x_test) print('类别 2 的概率:', probo[:, 1][:5]) # 将概率值传入 roc_curve 方法, 从概率中选择若干个值作为阈值 # 同时根据阈值判定正负例, 返回 fpr, tpr 和 阈值 thresholds fpr, tpr, thresholds = roc_curve(y_true=y_test, y_score=probo[:, 1], pos_label=2) # 阈值中的第一个值是第二个值 +1 得到, 为了让让曲线过 0 点 print('阈值:', thresholds) # 计算 AUC print('用auc计算:', auc(fpr, tpr)) print('用roc_auc_score计算:', roc_auc_score(y_true=y_test, y_score=probo[:, 1])) 类别 2 的概率: [0.4663913 0.28570842 0.60050037 0.3758227 0.48450719] 阈值: [1.69092453 0.69092453 0.60050037 0.54308778 0.50384451 0.49358343 0.48450719 0.47242245 0.4663913 0.42043757 0.39590375 0.39413886 0.3843811 0.24698327] 用auc计算: 0.8819444444444444 用roc_auc_score计算: 0.8819444444444444 # 绘制 ROC 曲线 plt.figure(figsize=(6, 2)) plt.plot(fpr, tpr, marker=\"o\", label=\"ROC曲线\") plt.plot([0,1], [0,1], lw=2, ls=\"--\", label=\"随机猜测\") plt.plot([0, 0, 1], [0, 1, 1], lw=2, ls=\"-.\", label=\"完美预测\") plt.xlim(-0.01, 1.02) plt.ylim(-0.01, 1.02) plt.xticks(np.arange(0, 1.1, 0.2)) plt.yticks(np.arange(0, 1.1, 0.2)) plt.xlabel(\"FPR\") plt.ylabel(\"TPR\") plt.grid() plt.title(f\"ROC曲线, AUC值为:{auc(fpr, tpr):.2f}\") plt.legend() plt.show() ",
    "description": "",
    "tags": null,
    "title": "分类模型评估",
    "uri": "/statistics/statistics5/"
  },
  {
    "content": "关键字 def 引入一个函数定义。构成函数体的语句从下一行开始，并且必须缩进。\n函数体的第一个语句可以是字符串文字（可选的），这个字符串文字即是函数的文档字符串。有些工具使用文档字符串自动生成在线或印刷文档，或者让用户以交互式的形式浏览代码。在你编写的代码中包含文档字符串是一种很好的做法，所以要养成习惯。\n文档字符串的内容和格式的约定：\n第一行应该是函数目的的简要概述。为简洁起见，它不应显式声明对象的名称或类型，因为这些可通过其他方式获得（除非名称恰好是描述函数操作的动词）。这一行应以大写字母开头，以句点结尾。\n如果文档字符串中有更多行，则第二行应为空白，从而在视觉上将摘要与其余描述分开。后面几行应该是一个或多个段落，描述对象的调用约定，它的副作用等。\n可以使用函数的 __doc__ 属性或 help() 函数查看函数文档。\nhelp(my_function) Help on function my_function in module __main__:\rmy_function()\rDo nothing, but document it.\rdef my_function(): 'Do nothing, but document it.' pass my_function.__doc__ 'Do nothing, but document it.'\r# 多行的函数文档 def my_func(): \"\"\"Do nothing, but document it. No, really, it doesn't do anything. \"\"\" pass print(my_func.__doc__) Do nothing, but document it.\rNo, really, it doesn't do anything.\rhelp(my_func) Help on function my_func in module __main__:\rmy_func()\rDo nothing, but document it.\rNo, really, it doesn't do anything.\rprint(print.__doc__) print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\rPrints the values to a stream, or to sys.stdout by default.\rOptional keyword arguments:\rfile: a file-like object (stream); defaults to the current sys.stdout.\rsep: string inserted between values, default a space.\rend: string appended after the last value, default a newline.\rflush: whether to forcibly flush the stream.\r",
    "description": "",
    "tags": null,
    "title": "函数文档",
    "uri": "/python/12_function/06_doc/"
  },
  {
    "content": "所有数字类型都支持下列运算（复数不支持 // 和 %）：\nx + y, x 和 y 的和 x - y, x 和 y 的差 x * y, x 和 y 的乘积 x / y, x 和 y 的商 x // y, x 和 y 的商数 x % y, x / y 的余数 -x, x 取反 +x, x 不变 x ** y, x 的 y 次幂 Python 完全支持数字的混合运算：当一个二元算术运算符的操作数有不同数值类型时，“较窄” 类型的操作数会拓宽到另一个操作数的类型。其中整数比浮点数窄，浮点数比复数窄。但整数除以整数得到浮点数。\n运算示例如下：\nTrue + 1 + 3.14 5.140000000000001\rTrue + 1 + 3.14 + 0j (5.140000000000001+0j)\r3/3, 3/1j (1.0, -3j)\r6//2, 6//2.0 (3, 3.0)\r6%4, 6%3.0 (2, 0.0)\r3**2, 3**2.0, 3**0j (9, 9.0, (1+0j))\r优先级升序排列如下：\n+, - 加和减 *, /, //, % 乘，除，整除，取余 +x, -x 正，负 ** 乘方 幂运算符 ** 绑定的紧密程度低于在其右侧的算术:\n1 + -20 * 4**-1 -4.0\r为了易读，应该多使用小括号：\n1 + (-20) * 4**(-1) -4.0\r",
    "description": "",
    "tags": null,
    "title": "数字运算",
    "uri": "/python/01_numeric/06_number_operations/"
  },
  {
    "content": "序列类型有列表，元组，range，字符串，字节串等。之所以称为序列类型，因为它们中的元素是按顺序排列的，可以使用下标索引或切片取值。\na = [1,2,3] b = 1,2,3 c = range(1,4) d = '123' e = b'123' a[0],b[0],c[0],d[0],e[0] (1, 1, 1, '1', 49)\rchr(49) # 字节串索引取到的是 Unicode 码位值 '1'\r序列类型又分为可变和不可变两种，列表是可变序列类型，元组，range，字符串，字节串是不可变序列类型。不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 hash() 内置函数的支持。\n这种支持允许不可变类型，例如元组被用作字典的键，以及存储在集合中。\n尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 TypeError。\nhash((1,2)), hash('12') (-3550055125485641917, -480100434937186025)\r{(1,2), '12'} {(1, 2), '12'}\r{([1,2],3),4} ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-10-b847264454c5\u003e in \u003cmodule\u003e\r----\u003e 1 {([1,2],3),4}\rTypeError: unhashable type: 'list'\r可变序列类型，可以就地进行元素的增、删、改，而不可变序列类型不可以，有时看起来像，但其实是创建了新对象：\na, b = [1,2], (1,2) print(id(a),id(b)) a += [3] # 将元素 3 加入列表中，相当于 a.extend([3]) b += (3,) # 将元组 b 与元组 (3,) 拼接赋值给 b print(a,b) print(id(a), id(b)) 2058115879744 2058115232576\r[1, 2, 3] (1, 2, 3)\r2058115879744 2058115884416\rjupyter附件 01_sequence.ipynb (4 KB) 02_range.ipynb (4 KB) 03_index_slice.ipynb (5 KB) 04_common_operations.ipynb (6 KB) ",
    "description": "",
    "tags": null,
    "title": "序列类型概述",
    "uri": "/python/05_sequence/"
  },
  {
    "content": "内置函数（类）bytes，Python 官方文档描述如下：\nhelp(bytes) Help on class bytes in module builtins:\rclass bytes(object)\r| bytes(iterable_of_ints) -\u003e bytes\r| bytes(string, encoding[, errors]) -\u003e bytes\r| bytes(bytes_or_buffer) -\u003e immutable copy of bytes_or_buffer\r| bytes(int) -\u003e bytes object of size given by the parameter initialized with null bytes\r| bytes() -\u003e empty bytes object\r| | Construct an immutable array of bytes from:\r| - an iterable yielding integers in range(256)\r| - a text string encoded using the specified encoding\r| - any object implementing the buffer API.\r| - an integer\r| | Methods defined here:\r| 返回一个新的二进制序列 bytes 对象。参数可以是：\n0~255 的整数组成的可迭代类型 字符串，并指定编码格式 encoding 与缓冲区接口一致的对象 整数 或者不传参数 type(bytes) type\rbytes([1,2,3]) b'\\x01\\x02\\x03'\rbytes('嗨', 'utf-8') b'\\xe5\\x97\\xa8'\rbytes(3) b'\\x00\\x00\\x00'\rbytes() b''\r",
    "description": "",
    "tags": null,
    "title": "bytes 创建 bytes 对象",
    "uri": "/python/11_built-in_function/07_bytes/"
  },
  {
    "content": "continue 在语法上只会出现于 for 或 while 循环所嵌套的代码中。\n它会继续执行最近的外层循环的下一个轮次，或者在没有下一轮次时转往 else 子句执行。\n当 continue 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然后再真正开始循环的下一个轮次。\nfor i in range(3): for j in range(3): if j == 1: print(f'i={i},j={j}') continue i=0,j=1\ri=1,j=1\ri=2,j=1\rfor i in range(3): for j in range(3): if j == 2: print(f'i={i},j={j}') continue else: # 属于内层循环，每次内层循环结束都执行 print('end') i=0,j=2\rend\ri=1,j=2\rend\ri=2,j=2\rend\rfor i in range(3): for j in range(3): if j == 2: print(f'i={i},j={j}') continue else: # 属于外层循环，外层循环结束才执行 print('end') i=0,j=2\ri=1,j=2\ri=2,j=2\rend\r# 引发异常直接跳过 continue # 无异常则继续执行完 finally 才继续下一次循环 for i in range(3): try: print(f'3/i={3/i}') continue except ZeroDivisionError as e: print(e) finally: print(f'i={i}') print(i) # 无异常时被跳过 else: print('end') division by zero\ri=0\r0\r3/i=3.0\ri=1\r3/i=1.5\ri=2\rend\r",
    "description": "",
    "tags": null,
    "title": "continue",
    "uri": "/python/10_statement/07_continue/"
  },
  {
    "content": "字典方法 dict.pop()，Python 官方文档描述如下：\nhelp(dict.pop) Help on method_descriptor:\rpop(...)\rD.pop(k[,d]) -\u003e v, remove specified key and return the corresponding value.\rIf key is not found, d is returned if given, otherwise KeyError is raised\r如果字典的键 k 存在，则移除 k 对应的 键值对，并返回 值；\n如果 k 不存在，但指定了可选参数 d，则返回 d；\n如果 k 不存在且未指定 d，则引发 KeyError。\nd = {'a':1, 'b':2} d.pop('a') 1\rd = {'a':1, 'b':2} d.pop('c', 3) 3\rd = {'a':1, 'b':2} d.pop('c') ---------------------------------------------------------------------------\rKeyError Traceback (most recent call last)\r\u003cipython-input-4-1e5ab2c0b86c\u003e in \u003cmodule\u003e\r1 d = {'a':1, 'b':2}\r----\u003e 2 d.pop('c')\rKeyError: 'c'\r",
    "description": "",
    "tags": null,
    "title": "dict.pop 删除元素并返回值",
    "uri": "/python/07_dictionary/07_dict.pop/"
  },
  {
    "content": "1, 关于 KNN KNN (K-Nearest Neighbor), 即 K 近邻算法, K 个最近的邻居. 当需要预测一个未知样本的时候, 就由与该样本最近的 K 个邻居来决定\nKNN 既可以用于分类, 也可用于回归. 用来分类时, 使用 K 个邻居中, 类别数量最多(或加权最多)者, 作为预测结果; 当用来回归分析时, 使用 K 个邻居的均值(或加权均值), 作为预测结果\nKNN 算法的原理是: 样本映射到多维空间时, 相似度较高的样本, 距离也会较接近, “近朱者赤近墨者黑”\n2, K 值 KNN 算法的 K 值是一个模型训练前就要人为指定的参数 超参数 , 不同于模型内部通过训练数据计算得到的参数. KNN 的超参数, 需要通常通过 交叉验证 的方式来选择最合适的参数组合\nK 值的选择非常重要, K 值较小时, 模型预测依赖附近的邻居, 敏感性高, 稳定性低, 容易导致过拟合; 反之, K 值较大, 敏感性低, 稳定性高, 容易欠拟合\nK 值在数据量小时, 可以通过遍历所有样本(穷举)的方式找出最近的 K 个邻居, 当数据量庞大时, 穷举耗费大量时间, 此时可以采用 KD树 来找 K 个邻居\n3, 交叉验证 KNN 的网格搜索交叉验证: 取不同的 K, 选择不同的距离或权重计算方式等, 将数据分为多个组, 一个组作为测试集, 其他部分作为训练集, 不断循环训练和测试, 对模型进行循环验证, 找出最佳参数组合\n4, 距离的度量方式 闵可夫斯基距离:\n设 n 维空间中两个点位 X 和 Y:\n$X=\\left(x_{1}, x_{2}, \\ldots \\ldots, x_{n}\\right)$ $Y=\\left(y_{1}, y_{2}, \\ldots \\ldots, y_{n}\\right)$ 则阁可夫斯基距离为:\n$D(X, Y)=\\left(\\sum_{i=1}^{n}\\left|x_{i}-y_{i}\\right|^{p}\\right)^{1 / p}$ 当 p 为 1 时, 又称 曼哈顿距离 ; 当 p 为 2 时, 称 欧几里得距离\n5, 权重 统一权重: K 个邻居权重相同, 不管近远都是 1/K\n距离加权权重: K 个邻居的权重, 与他们各自和待测样本的距离成反比, 同时要保证权重之和为 1. 例如 3 个邻居 a, b, c 距离待测样本的距离分别为 a, b 和 c, 则 a 的权重为:\n$$\\frac{\\frac{1}{a}}{\\frac{1}{a}+\\frac{1}{b}+\\frac{1}{c}}=\\frac{b c}{b c+a c+a b}$$b 和 c 同理\n6, 数据标准化 样本中的特征通常非常多，由于各特征的性质不同，通常具有不同的量纲(数量级). 当各特征间的量纲相差很大时，如果直接用原始特征值进行分析，就会突出数值较高的特征在综合分析中的作用，相对削弱数值较低特征的作用, 因此需要通过数据标准化, 将量纲统一, 才能客观地描述各个特征对模型的影响程度\n线性回归和逻辑回归, 都是通过每个特征与其权重的乘积相加来进行计算, 不进行数据标准化(不考虑正则化), 对每个特征的权重影响较大, 但对结果不会造成影响, 而 KNN 是基于距离计算的, 如果特征的量纲不同, 量纲较大的特征会占据主导地位, 导致忽略量纲较小的特征, 从而对模型性能造成较大影响\n7, 算法实现步骤 a, 确定超参数\n确定 K\n确定距离度量方式\n确定权重计算方式\n其他超参数\nb, 从训练集中选择距离待测样本最近的 K 个样本\nc, 根据 K 个样本对待测样本进行预测, 如果遇到多个样本距离相同的情况, 默认选取训练集中靠前的\n8, 流水线 Pipline 流水线可以将每个评估器视为一个步骤, 然后将多个步骤作为整体依次执行. 例如数据处理工作较多时, 可能涉及更多步骤, 例如多项式扩展, One-Hot 编码, 特征选择, 数据标准化, 交叉验证等, 分别执行过于繁琐, 我们可以将数据处理与模型训练各个步骤作为一个整体来执行\n流水线具有最后一个评估器的所有方法:\na, 当流水线对象调用 fit 方法时, 会从第一个评估器依次调用 fit_transform 方法, 然后到最后一个评估器调用 fit 方法\nb, 当流水线对象调用 其他 方法时, 会从第一个评估器依次调用 transform 方法, 然后到最后一个评估器调用 其他 方法\n9, 以鸢尾花为例, 对逻辑回归和 KNN 进行比较: from sklearn.model_selection import train_test_split from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import classification_report from sklearn.datasets import load_iris from sklearn.preprocessing import StandardScaler from sklearn.linear_model import LogisticRegression import matplotlib as mpl import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") import numpy as np mpl.rcParams[\"font.family\"] = \"SimHei\" mpl.rcParams[\"axes.unicode_minus\"] = False iris = load_iris() X = iris.data[:, :2] y = iris.target X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=0) # 数据标准化: StandardScaler 均值标准差标准化, MinMaxScaler 最大最小值标准化 ss = StandardScaler() X_train = ss.fit_transform(X_train) X_test = ss.transform(X_test) # 逻辑回归训练 lr = LogisticRegression() lr.fit(X_train,y_train) # KNN 训练 # n_neighbors: 邻居的数量 # weights：权重计算方式, 可选值为 uniform 统一权重, 与 distance 加权权重 knn = KNeighborsClassifier(n_neighbors=3, weights=\"uniform\") knn.fit(X_train, y_train) # 比较 AUC from sklearn.metrics import roc_curve, auc,roc_auc_score lr_fpr, lr_tpr, lr_thresholds = roc_curve(y_test, lr.predict_proba(X_test)[:,1], pos_label=1) lr_auc = auc(lr_fpr, lr_tpr) print('Logistic 算法: AUC = %.3f' % lr_auc) knn_fpr, knn_tpr, knn_thresholds = roc_curve(y_test, knn.predict_proba(X_test)[:,1], pos_label=1) knn_auc = auc(knn_fpr, knn_tpr) print('KNN 算法: AUC = %.3f' % knn_auc) Logistic 算法: AUC = 0.835 KNN 算法: AUC = 0.794 # 将 KNN 算法参数进行调优再来比较 from sklearn.model_selection import GridSearchCV # K 值取 1~10, 并定义需要的参数组合 knn = KNeighborsClassifier() grid = {'n_neighbors': range(1,11,1), 'weights': ['uniform','distance']} # 网格搜索交叉验证 # param_grid：需要检验的超参数组合 # scoring：模型评估标准, accuracy 正确率 # n_jobs：并发数量 # cv：交叉验证折数 # verbose：输出冗余信息 gs = GridSearchCV(estimator=knn, param_grid=grid, scoring='accuracy', n_jobs=-1, cv=5, verbose=0) gs.fit(X_train, y_train) gs_fpr, gs_tpr, gs_thresholds = roc_curve(y_test, gs.predict_proba(X_test)[:,1], pos_label=1) gs_auc = auc(gs_fpr, gs_tpr) print('KNN 算法: AUC = %.3f' % gs_auc) KNN 算法: AUC = 0.855 10, 以波士顿房价为例, 对线性回归和 KNN 进行比较: from sklearn.datasets import load_boston from sklearn.neighbors import KNeighborsRegressor from sklearn.linear_model import LinearRegression X, y = load_boston(return_X_y=True) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=0) knn = KNeighborsRegressor(n_neighbors=3, weights=\"distance\") knn.fit(X_train, y_train) print(\"KNN 算法 R²：\", knn.score(X_test, y_test)) lr = LinearRegression() lr.fit(X_train, y_train) print(\"线性回归算法 R²：\", lr.score(X_test, y_test)) KNN 算法 R²： 0.5158073940789912 线性回归算法 R²： 0.6354638433202129 # 对 KNN 数据标准化和参数调优之后再来比较 knn = KNeighborsRegressor() grid = {'n_neighbors': range(1,11,1), 'weights': ['uniform','distance']} gs = GridSearchCV(estimator=knn, param_grid=grid, scoring='r2', n_jobs=-1, cv=5, verbose=0) # 利用流水线处理 from sklearn.pipeline import Pipeline # 定义流水线的步骤: 类型为一个列表, 列表中的每个元素是元组类型 # 格式为：[(步骤名1，评估器1), (步骤名2， 评估器2), ……, (步骤名n, 评估器n) knn_steps = [(\"scaler\", StandardScaler()), (\"knn\", gs)] knn_p = Pipeline(knn_steps) # 可以设置流水线的参数. 所有可用的参数可以通过 get_params 获取 # 设置格式如下: (步骤名__参数) # p.set_params(knn__n_neighbors=3, knn__weights=\"uniform\") knn_p.fit(X_train, y_train) print(\"KNN 算法 R²：\", knn_p.score(X_test, y_test)) # 线性回归数据标准化 lr_steps = [(\"scaler\", StandardScaler()), (\"lr\", LinearRegression())] lr_p = Pipeline(lr_steps) lr_p.fit(X_train, y_train) print(\"线性回归算法 R²：\", lr_p.score(X_test, y_test)) KNN 算法 R²： 0.6441485149216897 线性回归算法 R²： 0.6354638433202131 ",
    "description": "",
    "tags": null,
    "title": "KNN 算法",
    "uri": "/statistics/statistics6/"
  },
  {
    "content": "列表方法 list.insert()，Python 官方文档描述如下：\nhelp(list.insert) Help on method_descriptor:\rinsert(self, index, object, /)\rInsert object before index.\r在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 a.insert(0, x) 插入列表头部，a.insert(len(a), x) 等同于 a.append(x)（a 是一个列表）。\n_list = [1,2,3] _list.insert(0,0) _list [0, 1, 2, 3]\r_list.insert(len(_list),[4]) _list [0, 1, 2, 3, [4]]\r该方法是一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 None), 直接对原列表进行修改：\n_list = [1,2,3] a = _list.insert(0,0) print(a) None\r",
    "description": "",
    "tags": null,
    "title": "list.insert 插入一个元素",
    "uri": "/python/03_list/07_list.insert/"
  },
  {
    "content": "集合方法 set.difference()，Python 官方文档描述如下：\nhelp(set.difference) Help on method_descriptor:\rdifference(...)\rReturn the difference of two or more sets as a new set.\r(i.e. all elements that are in this set but not the others.)\r该方法接收任意的位置参数，返回一个集合在其他所有集合中都不存在的元素组成的新集合。相当于 a - b - … （a，b 是集合），但方法的参数可以是可迭代对象。\n{1,2,3,4}.difference((2,1,5),{6,2,4}) {3}\r{1,2,3,4} - {2,1,5} - {6,2,4} {3}\r",
    "description": "",
    "tags": null,
    "title": "set.difference 差集",
    "uri": "/python/06_set/07_set.difference/"
  },
  {
    "content": "字符串方法 str.split()，Python 官方文档描述如下：\nhelp(str.split) Help on method_descriptor:\rsplit(self, /, sep=None, maxsplit=-1)\rReturn a list of the words in the string, using sep as the delimiter string.\rsep\rThe delimiter according which to split the string.\rNone (the default value) means split according to any whitespace,\rand discard empty strings from the result.\rmaxsplit\rMaximum number of splits to do.\r-1 (the default value) means no limit.\r返回一个由字符串内单词组成的列表，使用 sep 作为分隔字符串。如果给出了 sep，则连续的分隔符不会被组合在一起而是被视为分隔空字符串；如果给出了 maxsplit，则最多进行 maxsplit 次拆分（因此，列表最多会有 maxsplit+1 个元素）。如果 maxsplit 未指定或为 -1，则不限制拆分次数（进行所有可能的拆分）。\n'a.bc'.split('.') ['a', 'bc']\r'a.b.c'.split('.',maxsplit=1) ['a', 'b.c']\r'a.b..c'.split('.') ['a', 'b', '', 'c']\r'a.b..c'.split('..') ['a.b', 'c']\r''.split('.') ['']\r如果 sep 未指定或为 None，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，如果字符串包含前缀或后缀空格，其结果将不包含开头或末尾的空字符串。因此，使用 None 拆分空字符串或仅包含空格的字符串将返回 []。\n'a b c '.split() ['a', 'b', 'c']\r' \\n '.split() []\r''.split() []\r",
    "description": "",
    "tags": null,
    "title": "str.split 拆分",
    "uri": "/python/02_string/07_str.split/"
  },
  {
    "content": "函数名之后带一个圆括号，圆括号内，根据形参的类型（详见函数形参），给函数传递相应的实参，即可调用函数，执行函数体中的代码。\n函数调用传递的实参分为：位置参数和关键字参数。\n位置参数: 调用函数时，不带标识符（例如 name=）直接按形参位置传递给函数的参数。位置参数可使用 * 将可迭代对象的元素拆包传入函数，但元素个数不能多于可接收位置参数的形参个数，除非有接收多个位置参数的可变位置形参。 def f(a,b=None,*c,d=None): print(f'a={a},b={b},c={c},d={d}') f(*[1,2,3,4,5]) # d 只能接收关键字参数 a=1,b=2,c=(3, 4, 5),d=None\rdef f(a,b=None,*,c=None): print(f'a={a},b={b},c={c}') f(1,2) f(1,2,3) # c 只能接收关键字参数 a=1,b=2,c=None\r---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-2-9cc318bcfef7\u003e in \u003cmodule\u003e\r2 print(f'a={a},b={b},c={c}')\r3 f(1,2)\r----\u003e 4 f(1,2,3)\rTypeError: f() takes from 1 to 2 positional arguments but 3 were given\r关键字参数: 函数调用中前面带有标识符（例如 name=）传递给函数的参数。关键字参数可以使用 ** 将字典里的元素传入函数，但元素个数不能多于可接收关键字参数的形参个数。关键字参数的标识符或字典的键，必须与可接收关键字参数的形参的名称相同，除非有可接收任意关键字参数的可变关键字形参。 def f(a,/,b=None,*,c=None): print(f'a={a},b={b},c={c}') f(1,c=3,b=2) # a 仅限位置传参 f(a=1,c=3,b=2) a=1,b=2,c=3\r---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-7-3c39aaeac558\u003e in \u003cmodule\u003e\r3 4 f(1,c=3,b=2) # a 仅限位置传参\r----\u003e 5 f(a=1,c=3,b=2)\rTypeError: f() got some positional-only arguments passed as keyword arguments: 'a'\rdef f(a,/,b=None,**c): print(f'a={a},b={b},c={c}') # a 仅限位置，b 没有对应的名称，因此全部传给 c f(1,**{'a':1,'d':4,'c':3}) a=1,b=None,c={'a': 1, 'd': 4, 'c': 3}\r位置参数必须在关键字参数前面：\ndef f(a,b=None,**c): print(f'a={a},b={b},c={c}') f(b=2,1) File \"\u003cipython-input-13-59f3b615f9f3\u003e\", line 4\rf(b=2,1)\r^\rSyntaxError: positional argument follows keyword argument\r位置参数的位置不能传错，关键字参数的则可以任意位置：\ndef f(a,b=None,/,c=None,**d): print(f'a={a},b={b},c={c},d={d}') f(1,2,c=3,d=4) f(2,1,d=4,c=3,e=5) a=1,b=2,c=3,d={'d': 4}\ra=2,b=1,c=3,d={'d': 4, 'e': 5}\r标注并不影响传参规则，但按照标注传参是更明智的做法：\ndef f(a:int,b:str='b')-\u003e str: print(a*b) f(2,'hi') f(2,3) hihi\r6\r",
    "description": "",
    "tags": null,
    "title": "函数调用",
    "uri": "/python/12_function/07_function_call/"
  },
  {
    "content": "集合是由具有唯一性的可哈希对象（一个对象的哈希值如果在其生命周期内绝不改变）组成的无序多项集。\n目前有两种内置集合类型，set 和 frozenset，前者是可变类型，后者是不可变类型。\ntype({1}), type(frozenset()) (set, frozenset)\r因为一对花括号表示字典而非集合，所以创建空集合必须使用构造函数 set() 和 frozenset() 来表示。两个内置函数还可将可迭代对象转换为集合：\ntype({}), set(), frozenset() (dict, set(), frozenset())\rset('121'), frozenset('112') ({'1', '2'}, frozenset({'1', '2'}))\r构造 set 集合还可以直接使用一对花括号包含元素，元素之间用逗号隔开：\n{1,2,1} {1, 2}\r集合的元素必须是可哈希的，例如字符串，元组（不能包含不可哈希对象，例如元组里有列表）；也是唯一的，同时存在多个哈希值相等的元素，只保留一个。\nprint(hash(False),hash(0)) 0 0\r{'12', (1,2), False, 0} {(1, 2), '12', False}\rset 类型集合是可变类型，没有哈希值，不可作为集合的元素或字典的键，而 frozenset 类型的集合可以：\n{frozenset([1,2])} {frozenset({1, 2})}\r两种类型集合可进行比较，并集，交集，差集，对称差集操作：\n{1,2} == frozenset({1,2}) True\r{1,2} | frozenset({1,2,3}) {1, 2, 3}\rfrozenset({1,2,3}) ^ {1,2} frozenset({3})\rset 类型是可变的，还可进行元素增、删、改，等操作，而 frozenset 类型不可以：\na = set() print(id(a)) # a 增加元素 1 a.add(1) print(id(a),a) # 将一个集合并入 a a |= frozenset({1,2,3}) print(id(a),a) # 清空集合 a a.clear() print(id(a),a) 2029775797832\r2029775797832 {1}\r2029775797832 {1, 2, 3}\r2029775797832 set()\r集合是按哈希值对元素进行储存，而不是按顺序，因此集合没有索引和切片操作。搜索元素时，由于是通过哈希值匹配，集合比序列类型效率高。\n由于集合仅定义了部分排序（子集关系），比较大小的排序并无定义。\n{2,1,5} \u003e {2,5} True\ra = [{2,1,5},{9},{6},{2,5}] a.sort() a [{1, 2, 5}, {9}, {6}, {2, 5}]\rjupyter附件 01_set.ipynb (6 KB) 02_set.isdisjoint.ipynb (2 KB) 03_set.issubset.ipynb (3 KB) 04_set.issuperset.ipynb (2 KB) 05_set.union.ipynb (2 KB) 06_set.intersection.ipynb (2 KB) 07_set.difference.ipynb (2 KB) 08_set.symmetric_difference.ipynb (2 KB) 09_set.copy.ipynb (1 KB) 10_set.update.ipynb (2 KB) 11_set.intersection_update.ipynb (2 KB) 12_set.difference_update.ipynb (2 KB) 13_set.symmetric_difference_update.ipynb (2 KB) 14_set.add.ipynb (2 KB) 15_set.remove.ipynb (3 KB) 16_set.discard.ipynb (2 KB) 17_set.pop.ipynb (2 KB) 18_set.clear.ipynb (1 KB) ",
    "description": "",
    "tags": null,
    "title": "集合概述",
    "uri": "/python/06_set/"
  },
  {
    "content": "属性指关联到一个对象的值，可以使用点号表达式通过其名称来引用。\n可以使用 dir() 函数查看任意对象的属性。\n如果属性是可调用对象（例如类，函数，方法等），引用之后可直接调用，也可先赋值给变量再调用。\n# 查看 list 对象的属性 dir(list) ['__add__',\r'__class__',\r'__contains__',\r'__delattr__',\r'__delitem__',\r'__dir__',\r'__doc__',\r'__eq__',\r'__format__',\r'__ge__',\r'__getattribute__',\r'__getitem__',\r'__gt__',\r'__hash__',\r'__iadd__',\r'__imul__',\r'__init__',\r'__init_subclass__',\r'__iter__',\r'__le__',\r'__len__',\r'__lt__',\r'__mul__',\r'__ne__',\r'__new__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__reversed__',\r'__rmul__',\r'__setattr__',\r'__setitem__',\r'__sizeof__',\r'__str__',\r'__subclasshook__',\r'append',\r'clear',\r'copy',\r'count',\r'extend',\r'index',\r'insert',\r'pop',\r'remove',\r'reverse',\r'sort']\r# 通过名称 __add__ 引用属性 list.__add__ \u003cslot wrapper '__add__' of 'list' objects\u003e\r# 直接调用属性 list.__add__([1,2],[3,4]) [1, 2, 3, 4]\r# 赋值给变量再调用 la = list.__add__ la([1,2],[3,4]) [1, 2, 3, 4]\r有时也只将具体的值称为属性从而与抽象的值（类，函数，方法等对象的值）区分开来。犹如将一个人有身体和四肢的属性和这个人会唱歌跳舞的属性区分开来。\nimport pandas as pd pd.Series # pandas 模块的属性 Series 类 pandas.core.series.Series\rimport math math.pi # math 模块的属性圆周率 3.141592653589793\rclass A: a = 1 def f(self): print(self) a = A() A.a, a.a # 类 A 及其实例的数据属性 a (1, 1)\rA.f, a.f # 类 A 及其实例的方法属性 f (\u003cfunction __main__.A.f(self)\u003e,\r\u003cbound method A.f of \u003c__main__.A object at 0x000001B569DC0860\u003e\u003e)\r# 方法属性的等价调用 # 实例直接调用，第一个参数 self 就是它自身 a.f() # 类直接调用，则需要传入实例作为参数 A.f(a) \u003c__main__.A object at 0x000001B569DC0860\u003e\r\u003c__main__.A object at 0x000001B569DC0860\u003e\r属性名以一个下划线开头的属性应该视为 “私有” 属性，但可以直接访问。\n属性名以两个下划线开头，非两个下划线结尾的属性，在模块中视为 “私有” 属性，但可以直接访问；在类中属于私有属性，这种名称在类定义中使用时，会以一种混合形式重写以避免在基类及派生类的 “私有” 属性之间出现名称冲突。类的私有属性并非不可访问（使用重写名称可访问），全靠自觉。\nclass A: _a = 1 def __f(): pass dir(A) ['_A__f',\r'__class__',\r'__delattr__',\r'__dict__',\r'__dir__',\r'__doc__',\r'__eq__',\r'__format__',\r'__ge__',\r'__getattribute__',\r'__gt__',\r'__hash__',\r'__init__',\r'__init_subclass__',\r'__le__',\r'__lt__',\r'__module__',\r'__ne__',\r'__new__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__setattr__',\r'__sizeof__',\r'__str__',\r'__subclasshook__',\r'__weakref__',\r'_a']\rA._a 1\rA._A__f \u003cfunction __main__.A.__f()\u003e\r",
    "description": "",
    "tags": null,
    "title": "属性",
    "uri": "/python/16_class/07_attribute/"
  },
  {
    "content": "目录和附件\n描述统计 推断统计 线性回归 逻辑回归 分类模型评估 KNN 算法 朴素贝叶斯 决策树 K-Means 算法 jupyter附件 statistics1.ipynb (50 KB) statistics2.ipynb (47 KB) statistics3.ipynb (36 KB) statistics4.ipynb (70 KB) statistics5.ipynb (40 KB) statistics6.ipynb (11 KB) statistics7.ipynb (22 KB) statistics8.ipynb (94 KB) statistics9.ipynb (439 KB) ",
    "description": "",
    "tags": null,
    "title": "数理统计、机器学习入门",
    "uri": "/statistics/"
  },
  {
    "content": "内置函数 callable()，Python 官方文档描述如下：\nhelp(callable) Help on built-in function callable in module builtins:\rcallable(obj, /)\rReturn whether the object is callable (i.e., some kind of function).\rNote that classes are callable, as are instances of classes with a\r__call__() method.\r如果 obj 是可调用对象就返回 True，否则返回 False。如果返回 True，调用仍可能失败，但如果返回 False，则调用将肯定不会成功。\n函数、方法、类以及实现了 __call__() 方法的类的实例是可调用的。\ncallable(1) False\rcallable(int) True\rclass Myint(int): def __call__(self): pass num = Myint(1) num 1\rcallable(num) True\rcallable(lambda: 1) True\r",
    "description": "",
    "tags": null,
    "title": "callable() 是可调用对象？",
    "uri": "/python/11_built-in_function/08_callable/"
  },
  {
    "content": "del 语句用来删除名称的绑定，删除对象的属性引用 或 删除可抽取、切片的可变容器的元素。\n删除名称绑定：\n# 将值 (1,2) 绑定到名称 a, b, c a = b = c = (1,2) # 删除名称 b, c del b,c a (1, 2)\rb # 名称 b 已被删除 ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-27-9185c0ba25e7\u003e in \u003cmodule\u003e\r----\u003e 1 b # 名称 b 已被删除\rNameError: name 'b' is not defined\rclass A: x = y = 1 A.x, A.y (1, 1)\rdel A.y print(A.x) A.y # 属性名称 y 已被删除，不可引用值 1 1\r---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-29-8ed1b3e470b1\u003e in \u003cmodule\u003e\r1 del A.y\r2 print(A.x)\r----\u003e 3 A.y # 属性名称 y 已被删除，不可引用值 1\rAttributeError: type object 'A' has no attribute 'y'\r# 删除字典元素 d = {'a':1,'b':2} del d['a'] # 删除键为 'a' 的元素 print(d) d['a'] {'b': 2}\r---------------------------------------------------------------------------\rKeyError Traceback (most recent call last)\r\u003cipython-input-30-5d91a843f82e\u003e in \u003cmodule\u003e\r3 del d['a'] # 删除键为 'a' 的元素\r4 print(d)\r----\u003e 5 d['a']\rKeyError: 'a'\r# 删除列表切片 _list = [1,2,3,4] del _list[::2] _list [2, 4]\r# 删除列表切片 _list = [1,2,3,4] del _list[:] # 相当于 _list[:] = [] _list []\r",
    "description": "",
    "tags": null,
    "title": "del",
    "uri": "/python/10_statement/08_del/"
  },
  {
    "content": "字典方法 dict.popitem()，Python 官方文档描述如下：\nhelp(dict.popitem) Help on method_descriptor:\rpopitem(self, /)\rRemove and return a (key, value) pair as a 2-tuple.\rPairs are returned in LIFO (last-in, first-out) order.\rRaises KeyError if the dict is empty.\r按 后进先出 的原则，删除字典的元素，并以 (key, value) 元组返回。如果字典为空，则引发 KeyError。\nd = {2:2,1:1} d.popitem() (1, 1)\rd = {} d[1] = 1 d[3] = 3 d[2] = 2 d[3] = 30 # 更新并不改变元素插入顺序 d.popitem(),d.popitem(),d.popitem() ((2, 2), (3, 30), (1, 1))\rd = {} d.popitem() ---------------------------------------------------------------------------\rKeyError Traceback (most recent call last)\r\u003cipython-input-13-3d5a99fd0340\u003e in \u003cmodule\u003e\r1 d = {}\r----\u003e 2 d.popitem()\rKeyError: 'popitem(): dictionary is empty'\r",
    "description": "",
    "tags": null,
    "title": "dict.popitem 删除元素并返回键值对",
    "uri": "/python/07_dictionary/08_dict.popitem/"
  },
  {
    "content": "lambda 函数由 lambda 表达式创建，表达式的语法为：\nlambda parameters: expression 形参 parameters 是可选的，表达式 expression 会在函数调用时被求值并作为返回值返回。\n表达式必须显示地确定为一个表达式，而不能像 return 语句那样返回多个表达式（默认为一个元组）。\nlambda 表达式会创建一个没有名字的函数，函数不能包含语句或标注，可以像调用函数一样直接调用它。\n(lambda x,y: x**y)(2,3) 8\rlambda x,y: x**y \u003cfunction __main__.\u003clambda\u003e(x, y)\u003e\r# 返回值必须显示地确定为一个表达式 f = lambda x: sum(x),max(x),min(x) f([2,3,4]) ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-5-1652333b2bc4\u003e in \u003cmodule\u003e\r1 # 必须显示地确定为一个表达式\r----\u003e 2 f = lambda x: sum(x),max(x),min(x)\r3 f([2,3,4])\rNameError: name 'x' is not defined\rf = lambda x: (sum(x),max(x),min(x)) f([2,3,4]) (9, 4, 2)\rlambda 函数通常在以函数作为参数的高阶函数中使用，没有名称，用完即弃。\na = ['2 2', '2 1 ','2 3'] sorted(a,key=lambda x:''.join(x.split())) ['2 1 ', '2 2', '2 3']\rlist(map(lambda x:''.join(x.split()), a)) ['22', '21', '23']\r",
    "description": "",
    "tags": null,
    "title": "lambda 函数",
    "uri": "/python/12_function/08_lambda/"
  },
  {
    "content": "列表方法 list.sort()，Python 官方文档描述如下：\nhelp(list.sort) Help on method_descriptor:\rsort(self, /, *, key=None, reverse=False)\rSort the list in ascending order and return None.\rThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\rorder of two equal elements is maintained).\rIf a key function is given, apply it once to each list item and sort them,\rascending or descending, according to their function values.\rThe reverse flag can be set to sort in descending order.\r此方法会对列表进行原地排序，只使用 \u003c 来进行各项间比较。异常不会被屏蔽——如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。\n_list = [2,3,6,1,'5'] _list.sort() ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-2-87abda0b5baf\u003e in \u003cmodule\u003e\r1 _list = [2,3,6,1,'5']\r----\u003e 2 _list.sort()\rTypeError: '\u003c' not supported between instances of 'str' and 'int'\r_list [1, 2, 3, 6, '5']\rsort() 接受两个仅限以关键字形式传入的参数 (仅限关键字参数):\nkey 指定带有一个参数的函数，应用于列表中的每一个元素，按求值之后的大小，对原列表进行排序。默认值 None 表示直接对列表项排序。 _list = [-3,2,-5,1,4] _list.sort(key=abs) _list [1, 2, -3, 4, -5]\r_list.sort() _list [-5, -3, 1, 2, 4]\rreverse 为一个布尔值。如果设为 True，则每个列表元素将按反向顺序比较进行排序。 _list = [-3,2,-5,1,4] _list.sort(reverse=True) _list [4, 2, 1, -3, -5]\r当对较大的列表排序时，此方法会原地修改该序列以保证空间经济性。因此它并不会返回排序后的序列。\nsort() 方法确保是稳定的——如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的。\n_list = [1,'1.0',2,'1'] _list.sort(key=float) _list [1, '1.0', '1', 2]\r该方法是一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 None), 直接对原列表进行修改：\n_list = [5,1,4] a = _list.sort() print(a) None\r",
    "description": "",
    "tags": null,
    "title": "list.sort 对列表原地排序",
    "uri": "/python/03_list/08_list.sort/"
  },
  {
    "content": "集合方法 set.symmetric_difference()，Python 官方文档描述如下：\nhelp(set.symmetric_difference) Help on method_descriptor:\rsymmetric_difference(...)\rReturn the symmetric difference of two sets as a new set.\r(i.e. all elements that are in exactly one of the sets.)\r返回两个集合中非共同元素组成的新集合。相当于 a ^ b（a，b 是集合），但方法的参数可以是可迭代对象。\n{1,2,3}.symmetric_difference([2,3,4]) {1, 4}\r{1,2,3} ^ {2,3,4} {1, 4}\r",
    "description": "",
    "tags": null,
    "title": "set.symmetric_difference 对称差",
    "uri": "/python/06_set/08_set.symmetric_difference/"
  },
  {
    "content": "字符串方法 str.rsplit()，Python 官方文档描述如下：\nhelp(str.rsplit) Help on method_descriptor:\rrsplit(self, /, sep=None, maxsplit=-1)\rReturn a list of the words in the string, using sep as the delimiter string.\rsep\rThe delimiter according which to split the string.\rNone (the default value) means split according to any whitespace,\rand discard empty strings from the result.\rmaxsplit\rMaximum number of splits to do.\r-1 (the default value) means no limit.\rSplits are done starting at the end of the string and working to the front.\r返回一个由字符串内单词组成的列表，使用 sep 作为分隔字符串。如果给出了 maxsplit，则最多进行 maxsplit 次拆分，从 最右边开始。如果 sep 未指定或为 None，任何空白字符串都会被作为分隔符。除了从右边开始拆分，rsplit() 的其他行为都类似于 split()。\n'p\\nyth on '.rsplit() ['p', 'yth', 'on']\r'p\\nyth on'.rsplit('y') ['p\\n', 'th on']\r'p\\nyth on'.rsplit(maxsplit=1) ['p\\nyth', 'on']\r'p\\nyth on '.rsplit(maxsplit=2) ['p', 'yth', 'on']\r多个分隔符在一起，则会解读为拆分空字符串：\n'\\n\\np\\nyth on'.rsplit('\\n') ['', '', 'p', 'yth on']\r",
    "description": "",
    "tags": null,
    "title": "str.rsplit 拆分",
    "uri": "/python/02_string/08_str.rsplit/"
  },
  {
    "content": "方法指在类内部定义的函数。但并不严格要求一定要在类内部定义。\ndef f(self): pass class A: f = f A().f \u003cbound method f of \u003c__main__.A object at 0x00000290DC56E198\u003e\u003e\r下列方法看起来是模块中的函数，其实是模块中，类实例方法重新赋值的名称：\nfrom random import randint type(randint) method\rimport random # randint 完整路径 random.Random.randint # 例如重新赋值后即可直接调用 r = random.Random() randint = r.randint randint(0,3) 2\r普通方法（第一个参数通常命名为 self）如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个参数。\n# list 类的方法 append help('list.append') Help on method_descriptor in list:\rlist.append = append(self, object, /)\rAppend object to the end of the list.\r# list 的实例 [] 调用， # 方法将会获取实例对象 [] 作为其第一个参数 a = [] a.append(1) a [1]\r# 等价于 a = [] list.append(a,1) a [1]\r类方法（第一个参数通常命名为 cls）则无论是类或是实例调用，方法都将获取类对象作为其第一个参数。类方法定义详见 classmethod 封装函数为类方法。\nclass A: @classmethod def f(cls,x): print(cls,x) print(f'A = {A}') A.f('类方法') A().f('类方法') A = \u003cclass '__main__.A'\u003e\r\u003cclass '__main__.A'\u003e 类方法\r\u003cclass '__main__.A'\u003e 类方法\r静态方法则不会接收隐式的第一个参数。调用它需要正常传递参数。静态方法详见 staticmethod 封装函数为静态方法。\nclass A: @staticmethod def in_print(value): print(value) a = A() a.in_print('静态方法') A.in_print('静态方法') 静态方法\r静态方法\r特殊方法（也称魔术方法）：一种由 Python 隐式调用的方法，用来对某个类型执行特定操作例如相加等等。这种方法的名称的首尾都为双下划线。可以通过方法重载，对某个类型定义特定操作。\n# 1 + 2 操作其实是隐式调用了 __add__ 1 + 2 3\r(1).__add__(2) 3\r# 列表没有 “-” 操作符，自定义一个 class Mlist(list): def __sub__(self, other): return list(set(self) - set(other)) a = Mlist('123') b = Mlist('13') a, b, a - b (['1', '2', '3'], ['1', '3'], ['2'])\r",
    "description": "",
    "tags": null,
    "title": "方法",
    "uri": "/python/16_class/08_method/"
  },
  {
    "content": "1, 概率基础 样本空间 :\n在 随机试验 E 中, 实验的所有可能结果组成的集合, 称为 样本空间 S, 样本空间的每个元素, 即 E 的每个结果, 称 样本点\n随机事件 :\n进行随机试验时, 满足某种条件的样本点组成的集合, S 的子集, 称作 随机事件 , 只有一个样本点时, 称作 基本事件\n概率 :\n对于随机事件 A, 概率为:\n$P(A)=\\frac{A \\text { 中基本事件数 }}{S \\text { 中基本事件数 }}$ 条件概率 :\n定义事件 A 发生的前提下, 事件 B 发生的概率 P(B | A) 为条件概率:\n$$P(B \\mid A)=\\frac{P(A B)}{P(A)}$$由条件概率的定义可得, 事件 A 和 B 同时发生的概率 P(AB) 满足如下 乘法定理 :\n$$P(A B)=P(B \\mid A) P(A)$$独立性:\n定义 A 和 B 两个事件, 如果满足:\n$$P(A B)=P(A) P(B)$$则称事件 A, B 相互独立. 再结合乘法定理, 则有:\n$$P(B \\mid A) = P(B)$$全概率公式:\n设随机试验 E 的样本空间为 S, 若事件 $B_{1}$， $B_{2}$，…, $B_{n}$ 构成一个完备事件组(即它们两两相互独立，事件并集为 S), 且都有正概率，则对任意一个 E 的事件 A，有如下公式成立：\n$$P(A)=P\\left(A \\mid B_{1}\\right) P\\left(B_{1}\\right)+P\\left(A \\mid B_{2}\\right) P\\left(B_{2}\\right)+\\ldots \\ldots+P\\left(A \\mid B_{n}\\right) P\\left(B_{n}\\right)$$此公式即为全概率公式. 特别地，对于任意两随机事件 A 和 B，有如下成立：\n$$P(B)=P(B \\mid A) P(A)+P(B \\mid \\bar{A}) P(\\bar{A})$$贝叶斯公式:\n设随机试验 E 的样本空间为 S, 若事件 $B_{1}$， $B_{2}$，…, $B_{n}$ 构成一个完备事件组(即它们两两相互独立，事件并集为 S), 且都有正概率，则对任意一个 E 的正概率事件 A，有如下公式成立( i 为 1~n 的正整数)：\n$$P\\left(B_{i} \\mid A\\right)=\\frac{P\\left(A B_{i}\\right)}{P(A)}=\\frac{P\\left(A \\mid B_{i}\\right) P\\left(B_{i}\\right)}{P(A)} \\ =\\frac{P\\left(A \\mid B_{i}\\right) P\\left(B_{i}\\right)}{\\sum_{j=1}^{n} P\\left(A \\mid B_{j}\\right) P\\left(B_{j}\\right)}$$贝叶斯公式将求解 P(B | A) 的概率转换成求 P(A | B) 的概率, 在求解某个事件概率非常困难时, 转换一下更方便求解\n例: 从以往数据得出, 机器调整良好时生产的产品合格的概率是 98%, 机器故障时合格的概率是 55%, 每天开机时机器调整良好的概率为 95%. 求某日开机生产的第一件产品是合格品时, 机器调整良好的概率?\n解: 设事件 A 为产品合格, B 为机器调整良好, 则 $\\bar{B}$ 为机器故障\n$$P(B \\mid A)=\\frac{P(A \\mid B) P(B)}{P(A \\mid B) P(B)+P(A \\mid \\bar{B}) P(\\bar{B})} \\ =\\frac{0.98 \\times 0.95}{0.98 \\times 0.95+0.55 \\times 0.05} \\ =0.97$$先验概率和后验概率:\n由以往的数据得出的概率称为 先验概率 , 如上例中的已知概率\n得到某些信息后, 在先验概率的基础上进行修正而得到的概率, 称为 后验概率 , 如上例中求解的概率\n2, 朴素贝叶斯算法原理 朴素贝叶斯是基于概率的分类算法, 前提假设各个特征(自变量)之间是相互独立的, 设类别(因变量)为 Y, Y 包含 m 个类别( $y_{1},\\ldots, y_{m}$), 特征为 X, X 包含含有 n 个特征 ( $x_{1}, \\ldots, x_{n}$), 然后通过计算比较, 在特征 X 确定的前提下, 类别 Y 中每个类别的概率大小, 概率最大者即为预测结果\n设 Y 中任意一个类别为 y, 则:\n$$P(y \\mid X) = P\\left(y \\mid x_{1}, \\ldots, x_{n}\\right) \\ =\\frac{P(y) P\\left(x_{1}, \\ldots, x_{n} \\mid y\\right)}{P\\left(x_{1}, \\ldots, x_{n}\\right)} \\ =\\frac{P(y) P\\left(x_{1} \\mid y\\right) P\\left(x_{2} \\mid y\\right) \\ldots P\\left(x_{n} \\mid y\\right)}{P\\left(x_{1}, \\ldots, x_{n}\\right)} \\ =\\frac{P(y) \\prod_{i=1}^{n} P\\left(x_{i} \\mid y\\right)}{P\\left(x_{1}, \\ldots, x_{n}\\right)}$$上式分母为定值, 则:\n$$P\\left(y \\mid X \\right) \\propto P(y) \\prod_{i=1}^{n} P\\left(x_{i} \\mid y\\right)$$所以最终预测类别 $\\hat{y}$ 为分子部分值最大对应的类别:\n$$\\hat{y}=\\arg \\max_{y} P(y) \\prod_{i=1}^{n} P\\left(x_{i} \\mid y\\right)$$不同的朴素贝叶斯算法, 主要是对 $P\\left(x_{i} \\mid y\\right)$ 的分布假设不同, 进而采取不同的参数估计方式. 最终主要就是通过计算 $P\\left(x_{i} \\mid y\\right)$ 的概率来计算结果\n例: 预测第 11 条记录, 学生是否上课\n序号 天气 上课距离 成绩 课程 上课情况 1 晴 远 差 选修 逃课 2 晴 近 差 必修 上课 3 晴 近 好 必修 上课 4 阴 远 差 选修 逃课 5 阴 近 好 选修 上课 6 阴 近 好 必修 上课 7 雨 远 差 选修 逃课 8 雨 近 好 必修 上课 9 雨 近 差 必修 逃课 10 雨 远 好 选修 逃课 11 阴 近 差 选修 ? 12 晴 远 好 选修 ? 分别计算上课和逃课情况下, 各自的概率:\n$$P(y=\\text { 上课 }) \\prod_{i=1}^{n} P\\left(x_{i} \\mid y=\\text { 上课 }\\right) \\ =P(y=\\text { 上课 }) P\\left(x_{1}=\\text { 阴 } \\mid y=\\text { 上课 }\\right) P\\left(x_{2}=\\text { 近 } \\mid y=\\text { 上课 }\\right) \\ P\\left(x_{3}=\\text {差 } \\mid y=\\text { 上课 }\\right) P\\left(x_{4}=\\text { 选修 } \\mid y=\\text { 上课 }\\right) \\ =0.5 \\times 0.4 \\times 1 \\times 0.2 \\times 0.2 \\ =0.008$$ $$P(y=\\text { 逃课 }) \\prod_{i=1}^{n} P\\left(x_{i} \\mid y=\\text { 逃课 }\\right) \\ =P(y=\\text { 逃课 }) P\\left(x_{1}=\\text { 阴 } \\mid y=\\text { 逃课 }\\right) P\\left(x_{2}=\\text { 近 } \\mid y=\\text { 逃课 }\\right) \\ P\\left(x_{3}=\\text { 差 } \\mid y=\\text { 逃课 }\\right) P\\left(x_{4}=\\text { 选修 } \\mid y=\\text { 逃课 }\\right) \\ =0.5 \\times 0.2 \\times 0.2 \\times 0.8 \\times 0.8 \\ =0.0128$$可得预测结果为: 逃课\n3, 平滑改进 当我们预测上例中, 第 12 条记录所属的类别时, 因为样本不是总体, 会出现上课的前提下, 距离远的概率为 0, 造成计算结果也为 0, 影响了预测结果, 因此需要平滑改进:\n$$ P\\left(x_{i} \\mid y\\right)=\\frac{\\text { 类别 } y \\text { 中 } x_{i} \\text { 取某个值出现的次数 }+ \\alpha}{\\text { 类别别 } y \\text { 的总数 }+k * \\alpha} $$其中, k 为特征 $x_{i}$ 可能的取值数, α (α ≥ 0) 称为平滑系数, 当 α = 1 时, 称拉普拉斯平滑( Laplace smoothing)\n4, 算法优点 即使训练集数据较少, 也能实现不错的预测; 算法训练速度非常快\n因此算法假设特征之间是独立的, 可以单独考虑. 如果训练集有 N 个特征, 每个特征需要 M 个样本来训练, 则只需要训练 N*M 的样本数量, 而不是笛卡儿积的形式指数级增加\n常用的朴素贝叶斯有: 高斯朴素贝叶斯, 伯努利朴素贝叶斯, 多项式朴素贝叶斯\n5, 高斯朴素贝叶斯 适用于连续变量, 其假定各个特征 x 在各个类别 y 下服从正态分布:\n$$x_{i} \\sim N\\left(\\mu_{y}, \\sigma_{y}^{2}\\right)$$算法使用概率密度函数来计算 $P\\left(x_{i} \\mid y\\right)$ 的概率:\n$$P\\left(x_{i} \\mid y\\right)=\\frac{1}{\\sqrt{2 \\pi \\sigma_{y}^{2}}} \\exp \\left(-\\frac{\\left(x_{i}-\\mu_{y}\\right)^{2}}{2 \\sigma_{y}^{2}}\\right) $$ $\\mu_{y}$: 在类别为 y 的样本中, 特征 $x_{i}$ 的均值\n$\\sigma_{y}$: 在类别为 y 的样本中, 特征 $x_{i}$ 的标件差\nimport numpy as np import pandas as pd from sklearn.naive_bayes import GaussianNB np.random.seed(0) x = np.random.randint(0, 10, size=(8, 3)) y = np.array([0, 1, 0, 0, 0, 1, 1, 1]) data = pd.DataFrame(np.concatenate([x, y.reshape(-1, 1)], axis=1), columns=['x1', 'x2', 'x3', 'y']) display(data[:3]) gnb = GaussianNB() gnb.fit(x, y) print('类别标签:', gnb.classes_) print('每个类别的先验概率:', gnb.class_prior_) print('样本数量:', gnb.class_count_) print('每个类别下特征的均值:', gnb.theta_) print('每个类别下特征的方差:', gnb.sigma_) # 测试集 x_test = np.array([[5, 7, 2]]) print('预测结果:', gnb.predict(x_test)) print('预测结果概率:', gnb.predict_proba(x_test)) x1\tx2\tx3\ty 0\t5\t0\t3\t0 1\t3\t7\t9\t1 2\t3\t5\t2\t0 类别标签: [0 1] 每个类别的先验概率: [0.5 0.5] 样本数量: [4. 4.] 每个类别下特征的均值: [[5. 5. 3. ] [6.5 5.75 7.5 ]] 每个类别下特征的方差: [[3.50000001 9.50000001 3.50000001] [5.25000001 7.68750001 2.75000001]] 预测结果: [0] 预测结果概率: [[0.99567424 0.00432576]] 6, 伯努利朴素贝叶斯 设实验 E 只有两个可能的结果, A 与 $\\bar{A}$, 则称 E 为伯努利试验\n伯努利朴素贝叶斯, 适用于离散变量, 其假设各个特征 x 在各个类别 y 下服从 n 重伯努利分布(二项分布), 因伯努利试验仅有两个结果, 算法会首先对特征值进行二值化处理(假设二值化结果为 1 和 0 )\n$P\\left(x_{i} \\mid y\\right)$ 的概率为:\n$$P\\left(x_{i} \\mid y\\right)=P\\left(x_{i}=1 \\mid y\\right) x_{i}+\\left(1-P\\left(x_{i}=1 \\mid y\\right)\\right)\\left(1-x_{i}\\right)$$在训练集中, 会进行如下评估:\n$$ P\\left(x_{i}=1 \\mid y\\right)=\\frac{N_{y i}+\\alpha}{N_{y}+2 * \\alpha} \\ P\\left(x_{i}=0 \\mid y\\right)=1-P\\left(x_{i}=1 \\mid y\\right) $$ $N_{y i}$: 第 i 特征中, 属于类别 y, 数值为 1 的样本个数\n$N_{y}$: 属于类別 y 的所有样本个数\n$\\alpha$: 平滑系数\nfrom sklearn.naive_bayes import BernoulliNB np.random.seed(0) x = np.random.randint(-5, 5, size=(8, 3)) y = np.array([0, 1, 0, 0, 0, 1, 1, 1]) data = pd.DataFrame(np.concatenate([x, y.reshape(-1, 1)], axis=1), columns=['x1', 'x2', 'x3', 'y']) display(data[:3]) bnb = BernoulliNB() bnb.fit(x, y) # 统计每个类别下, 特征中二值化后, 每个特征下值 1 出现的次数 print('值 1 出现的次数:', bnb.feature_count_) # 每个类别的先验概率, 算法得到的该概率值是取对数后的结果, # 需要取指数还原 print('每个类别的先验概率:', np.exp(bnb.class_log_prior_)) # 每个类别下, 每个特征的概率(也需要取指数还原) print('每个特征的概率:', np.exp(bnb.feature_log_prob_)) # 测试集 x_test = np.array([[-5, 0, 2]]) print('预测结果:', bnb.predict(x_test)) print('预测结果概率:', bnb.predict_proba(x_test)) x1\tx2\tx3\ty 0\t0\t-5\t-2\t0 1\t-2\t2\t4\t1 2\t-2\t0\t-3\t0 值 1 出现的次数: [[1. 2. 1.] [3. 3. 3.]] 每个类别的先验概率: [0.5 0.5] 每个特征的概率: [[0.33333333 0.5 0.33333333] [0.66666667 0.66666667 0.66666667]] 预测结果: [0] 预测结果概率: [[0.6 0.4]] 7, 多项式朴素贝叶斯 多项式朴素贝叶斯, 适用于离散变量, 其假设各个特征 x 在各个类别 y 下服从多项式分布(每个特征下的值之和, 就是该特征发生(出现)的次数), 因此每个特征值不能是负数\n$P\\left(x_{i} \\mid y\\right)$ 的概率为:\n$$P\\left(x_{i} \\mid y\\right)=\\frac{N_{y i}+\\alpha}{N_{y}+\\alpha n} $$ $N_{y i}$: 特征 i 在类别 y 的样本中发生(出现)的次数\n$N_{y}$: 类别 y 的样本中, 所有特征发生(出现)的次数\n$n$: 特征数量\n$\\alpha$: 平滑系数\nfrom sklearn.naive_bayes import MultinomialNB np.random.seed(0) x = np.random.randint(1, 5, size=(8, 3)) y = np.array([0, 1, 0, 0, 0, 1, 1, 1]) data = pd.DataFrame(np.concatenate([x, y.reshape(-1, 1)], axis=1), columns=['x1', 'x2', 'x3', 'y']) display(data[:3]) mnb = MultinomialNB() mnb.fit(x, y) # 每个类别的样本数量 print('每个类别的样本数:', mnb.class_count_) # 每个特征在每个类别下发生(出现)的次数 print('每个特征发生(出现)次数:', mnb.feature_count_) # 每个类别下, 每个特征的概率(需要取指数还原) print('每个类别下特征的概率:', np.exp(mnb.feature_log_prob_)) # 测试集 x_test = np.array([[1, 1, 4]]) print('预测结果:', mnb.predict(x_test)) print('预测结果概率:', mnb.predict_proba(x_test)) x1\tx2\tx3\ty 0\t1\t4\t2\t0 1\t1\t4\t4\t1 2\t4\t4\t2\t0 每个类别的样本数: [4. 4.] 每个特征发生(出现)次数: [[10. 14. 10.] [ 9. 11. 11.]] 每个类别下特征的概率: [[0.2972973 0.40540541 0.2972973 ] [0.29411765 0.35294118 0.35294118]] 预测结果: [1] 预测结果概率: [[0.36890061 0.63109939]] 利用鸢尾花数据集比较上述 3 个贝叶斯算法:\n对不同的数据集, 根据其分布情况选择适合的算法, 能得到更好的结果\nfrom sklearn.datasets import load_iris from sklearn.model_selection import train_test_split x, y = load_iris(return_X_y=True) x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25, random_state=0) models = [('高斯朴素贝叶斯分值:', GaussianNB()), ('伯努利朴素贝叶斯分值:', BernoulliNB()), ('多项式朴素贝叶斯分值:', MultinomialNB())] for name, m in models: m.fit(x_train, y_train) print(name, m.score(x_test, y_test)) 高斯朴素贝叶斯分值: 1.0 伯努利朴素贝叶斯分值: 0.23684210526315788 多项式朴素贝叶斯分值: 0.5789473684210527 ",
    "description": "",
    "tags": null,
    "title": "朴素贝叶斯",
    "uri": "/statistics/statistics7/"
  },
  {
    "content": "字典属于映射类型，将可哈希对象映射到任意对象，可哈希对象为字典的键，映射的对象为键对应的条目（值）。因此：\n键必须是可哈希且唯一的； 值可以是任意对象（此处 值 仅指键对应的条目）。 所以字典的键必须是可哈希对象，例如字符串，元组（不能包含不可哈希对象）；哈希值相等的对象作为字典的键会被当作一个键。\n{'1':1, (1,2):2, 1:3, True:4} {'1': 1, (1, 2): 2, 1: 4}\r字典是目前唯一的标准映射类型。其类型为 dict。空字典用一对花括号表示。\ntype({}) dict\r字典可以通过花括号包含逗号分隔的 键值对 来创建，也可以用内置函数 dict() 来创建。\n{'a':1, 'b':2} {'a': 1, 'b': 2}\rdict(a=1,b=2) {'a': 1, 'b': 2}\rdict(zip(['a','b'],(1,2))) {'a': 1, 'b': 2}\r字典是可变对象，可以通过键，来获取对应的项，或更新、添加项。获取项时，键不存在则引发 KeyError。\n# 获取 d = {'a':1} d['a'] 1\r# 更新 d['a'] = [1,2] d {'a': [1, 2]}\r# 键不存在则添加项 d['b'] = {1,2} d {'a': [1, 2], 'b': {1, 2}}\rd['c'] ---------------------------------------------------------------------------\rKeyError Traceback (most recent call last)\r\u003cipython-input-9-05ba6e0488c7\u003e in \u003cmodule\u003e\r----\u003e 1 d['c']\rKeyError: 'c'\r字典的元素（键值对）是按哈希值来存储的，没有序列类型的双向索引操作，但字典会保留元素插入时的顺序，更新不会改变插入顺序。而且使用 popitem 方法删除元素是按后进先出原则删除。\nd = {} d[3] = 3 d[1] = 1 d[2] = 2 d {3: 3, 1: 1, 2: 2}\rd[1] = 10 d {3: 3, 1: 10, 2: 2}\rd.popitem(),d.popitem(),d.popitem() ((2, 2), (1, 10), (3, 3))\rjupyter附件 01_dict.ipynb (6 KB) 02_dict.keys.ipynb (2 KB) 03_dict.values.ipynb (2 KB) 04_dict.items.ipynb (2 KB) 05_dict.get.ipynb (2 KB) 06_dict.copy.ipynb (2 KB) 07_dict.pop.ipynb (3 KB) 08_dict.popitem.ipynb (3 KB) 09_dict.fromkeys.ipynb (3 KB) 10_dict.clear.ipynb (1 KB) 11_dict.setdefault.ipynb (3 KB) 12_dict.update.ipynb (3 KB) 13_loop_through.ipynb (3 KB) 14_operator.ipynb (4 KB) ",
    "description": "",
    "tags": null,
    "title": "字典概述",
    "uri": "/python/07_dictionary/"
  },
  {
    "content": "内置函数 chr()，Python 官方文档描述如下：\nhelp(chr) Help on built-in function chr in module builtins:\rchr(i, /)\rReturn a Unicode string of one character with ordinal i; 0 \u003c= i \u003c= 0x10ffff.\r返回 Unicode 码位对应的字符的字符串格式。码位范围是 0~1114111（16 进制表示是 0x10FFFF），超过这个范围，会触发 ValueError 异常。该函数是 ord() 的逆函数。\nchr(97) 'a'\rord('a') 97\rchr(1114111) '\\U0010ffff'\rchr(1114112) ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-5-4857faf08086\u003e in \u003cmodule\u003e\r----\u003e 1 chr(1114112)\rValueError: chr() arg not in range(0x110000)\r",
    "description": "",
    "tags": null,
    "title": "chr() 返回 Unicode 码位值对应字符",
    "uri": "/python/11_built-in_function/09_chr/"
  },
  {
    "content": "字典的方法 fromkeys，Python 官方文档描述如下：\nhelp(dict.fromkeys) Help on built-in function fromkeys:\rfromkeys(iterable, value=None, /) method of builtins.type instance\rCreate a new dictionary with keys from iterable and values set to value.\r使用可迭代对象 iterable 中的元素作为字典的键，value 为值（默认是 None）创建字典。\ndict.fromkeys('123') {'1': None, '2': None, '3': None}\rdict.fromkeys([1,2,3], 0) {1: 0, 2: 0, 3: 0}\r可迭代对象中不能包含不可哈希对象：\ndict.fromkeys([[1],2,3], 0) ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-6-470a0d0c77b4\u003e in \u003cmodule\u003e\r----\u003e 1 dict.fromkeys([[1],2,3], 0)\rTypeError: unhashable type: 'list'\r",
    "description": "",
    "tags": null,
    "title": "dict.fromkeys 创建字典",
    "uri": "/python/07_dictionary/09_dict.fromkeys/"
  },
  {
    "content": "列表方法 list.reverse()，Python 官方文档描述如下：\nhelp(list.reverse) Help on method_descriptor:\rreverse(self, /)\rReverse *IN PLACE*.\r反转列表中的元素。\n_list = [1,2,3] _list.reverse() _list [3, 2, 1]\r该方法是一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 None), 直接对原列表进行修改：\n_list = [1,2,3] a = _list.reverse() print(a) None\r",
    "description": "",
    "tags": null,
    "title": "list.reverse 反转列表中元素",
    "uri": "/python/03_list/09_list.reverse/"
  },
  {
    "content": "pass 是一个空操作 —— 当它被执行时，什么都不发生。\n它适合当语法上需要一条语句但并不需要执行任何代码时用来临时占位，例如:\npass # 什么也不做的函数 def f():pass # 没有任何自定义属性的类 class A:pass ",
    "description": "",
    "tags": null,
    "title": "pass",
    "uri": "/python/10_statement/09_pass/"
  },
  {
    "content": "集合方法 set.copy()，Python 官方文档描述如下：\nhelp(set.copy) Help on method_descriptor:\rcopy(...)\rReturn a shallow copy of a set.\r返回集合的一个浅拷贝。\na = {1,2} print(id(a),a) b = a.copy() id(b),b 2091426558696 {1, 2}\r(2091426559368, {1, 2})\r",
    "description": "",
    "tags": null,
    "title": "set.copy 浅拷贝",
    "uri": "/python/06_set/09_set.copy/"
  },
  {
    "content": "字符串方法 str.partition()，Python 官方文档描述如下：\nhelp(str.partition) Help on method_descriptor:\rpartition(self, sep, /)\rPartition the string into three parts using the given separator.\rThis will search for the separator in the string. If the separator is found,\rreturns a 3-tuple containing the part before the separator, the separator\ritself, and the part after it.\rIf the separator is not found, returns a 3-tuple containing the original string\rand two empty strings.\r在 sep 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。\n'python'.partition('m') ('python', '', '')\r'python'.partition('th') ('py', 'th', 'on')\r'python'.partition('ht') ('python', '', '')\r",
    "description": "",
    "tags": null,
    "title": "str.partition 拆分",
    "uri": "/python/02_string/09_str.partition/"
  },
  {
    "content": "1, 概念理解 决策树: 通过数据特征的差别, 用已知数据训练将不同数据划分到不同分支(子树)中, 层层划分, 最终得到一个树型结构, 用来对未知数据进行预测, 实现分类或回归\n例如, 有如下数据集, 预测第 11 条数据能否偿还债务:\n序号 有无房产 婚姻状况 年收入 能否偿还债务 1 是 单身 125 能 2 否 已婚 100 能 3 否 单身 100 能 4 是 已婚 110 能 5 是 离婚 60 能 6 否 离婚 95 不能 7 否 单身 85 不能 8 否 已婚 75 能 9 否 单身 90 不能 10 是 离婚 220 能 11 否 已婚 94 ? 我们可以将已知样本作如下划分(训练), 构建一颗决策树, 然后将第 11 条数据代入(测试), 落在哪一个叶子中, 它就是对应叶子的类别: 预测结果是 能\n上例中, 层级已经不可再分, 但如果只划分到婚姻状况就不再划分如何实现预测?\n决策树实现预测:\n对于分类树, 叶子节点中, 哪个类别样本数量最多, 就将其作为未知样本的类别\n对于回归树, 使用叶子节点中, 所有样本的均值, 作为未知样本的结果\n对于上例, 如果只划分到婚姻状况, 那对于婚姻状况这个叶子中, 不能偿还的最多, 预测结果就是 不能\n2, 分类决策树 对上例出现的情况, 我们会有如下问题:\n我们为什么以年收入开始划分, 依据是什么? 划分顺序怎么定?\n年收入为什么选 97.5 为划分阈值?\n要划分多少层才好, 是否越多越好?\n等等…\n下面一步步来作讨论:\n2.01, 信息熵 信息熵 : 用来描述信源的不确定度, 不确定性越大, 信息熵越大. 例如, 明天海南要下雪, 不确定性非常小, 信息熵很小, 明天海南要下雨, 不确定性大, 信息熵就大\n设随机变量 X 具有 m 个特征值, 各个值出现的概率为 $p_{1}$, …, $p_{m}$, 且\n$$p_{1}+p_{2}+\\cdots+p_{m} = 1$$则变量 X 的信息熵(信息期望值)为:\n$$H(X)=-p_{1} \\log_{2} p_{1} -p_{2} \\log_{2} p_{2}-\\cdots -p_{m} \\log_{2} p_{m}$$ $$ =-\\sum_{i=1}^{m}p_{i}\\log_{2}p_{i}$$2.02, 概率分布与信息商的关系 假设明天下雨的概率从 0.01 ~ 0.99 递增, 那么不下雨的概率就从 0.99 ~ 0.01 递减, 看看概率分布和信息熵的关系:\nimport numpy as np import matplotlib.pyplot as plt plt.rcParams['font.family'] = 'SimHei' plt.rcParams['font.size'] = 14 # 下雨的概率 p = np.linspace(0.01, 0.99, 100) # 信息熵 h = -p * np.log2(p) - (1-p) * np.log2(1-p) # 绘制关系图 plt.plot(p, h) plt.xlabel('概率分布') plt.ylabel('信息熵') plt.title('概率分布和信息熵关系图') plt.show() 可见, 概率分布越均衡, 不确定性越大, 信息熵越大, 在所有概率都相等(p下雨=p不下雨)时, 信息熵最大\n如果把概率分布转换到决策树的数据集上, 信息熵体现的就是数据的 不纯度 , 即样本类别的均衡程度. 因为数据集是未分类的, 要把它分类, 样本类别越均衡, 各个类别的占比(概率)分布越均衡, 不纯度越高, 信息熵越大\n2.03, 信息增益 信息增益的定义如下:\n$$I G\\left(D_{p}, f\\right)=I\\left(D_{p}\\right)-\\sum_{j=1}^{n} \\frac{N_{j}}{N_{p}} I\\left(D_{j}\\right) $$ $f$: 划分的特征\n$D_{p}$: 父节点, 即使用特征 f 分割之前的节点\n$I G\\left(D_{p}, f\\right)$: 父节点 $D_{p}$ 使用特征 f 划分下, 获得的信息增益\n$I\\left(D_{p}\\right)$：父节点不纯度, 信息熵是度量标准之一\n$D_{j}$: 父节点 $D_{p}$ 经过分割之后, 会产生 n 个子节点, $D_{j}$ 为第 j 个子节点\n$I\\left(D_{j}\\right)$：子节点不纯度\n$N_{p}$: 父节点 $D_{p}$ 包含样本的数量\n$N_{j}$: 第 j 个子节点 $D_{j}$ 包含样本的数量\n如果是二叉树, 即父节点最多分为左右两个子节点, 此时, 信息增益为:\n$$I G\\left(D_{p}, f\\right)=I\\left(D_{p}\\right)-\\frac{N_{l e f t}}{N_{p}} I\\left(D_{l e f t}\\right)-\\frac{N_{r i g h t}}{N_{p}} I\\left(D_{r i g h t}\\right)$$可见, 信息增益就是父节点的不纯度减去所有子节点的(加权)不纯度\n父节点的不纯度是不变的, 在选择特征进行类别划分时, 应该让子节点的不纯度尽可能低, 这样训练可以更快完成, 信息增益也最大. 这正是训练决策树时, 选择特征顺序的依据\n以开头的例子为例, 不纯度使用信息熵度量, 则根节点的信息熵为:\n$$I\\left(D_{p}\\right)=-0.7 * \\log _{2} 0.7-0.3 * \\log _{2} 0.3=0.88$$如果以”有无房产”划分, 则可计算得子节点信息熵:\n$$\\begin{array}{l} I\\left(D_{\\text {有房产 }}\\right)=0 \\ I\\left(D_{\\text {无房产 }}\\right)=1 \\end{array}$$从而可得根节点信息增益为:\n$$I G(\\text { 有无房产 })=0.88-0.4 * 0-0.6 * 1=0.28 $$同理,\n$$I G(\\text { 婚姻状况 })=0.205 $$而对于年收入, 将年收入排序后, 取不同类别的分界点年收入(75 与 85, 95 与 100)的均值进行划分, 比较哪一个信息增益大:\n$$\\begin{array}{l} I\\left(D_{\\text {年收入 }\u003c 80}\\right)=0 \\ I\\left(D_{\\text { 年收入 } \u003e=80}\\right)=0.954 \\ I G(\\text { 年收入 }=80)=0.88-0.2 * 0-0.8 * 0.954=0.117 \\end{array}$$同理,\n$$I G(\\text { 年收入 }=97.5)=0.395$$可见, 以 年收入=97.5 划分时, 信息增益最大, 故首先选它进行划分\n根节点划分结束, 第二层的父节点以同样的方式计算之后再次划分, 一直到划分停止\n2.04, 过拟合与欠拟合 如果不设置条件, 是不是划分深度越大越好呢?\n下面以鸢尾花数据集为例, 看看划分深度对模型效果的影响:\nfrom sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier x, y = load_iris(return_X_y=True) x = x[:, :2] x_train, x_test, y_train, y_test = train_test_split( x, y, test_size=0.25, random_state=0) ''' 参数介绍: criterion: 不纯度度量标准, 默认基尼系数 gini, 信息熵为 entropy splitter: 选择划分节点的方式, 默认最好 best, 随机 random max_depth: 划分深度, 默认 None 不设限 min_samples_split: 划分节点的最小样本数, 默认 2 min_samples_leaf: 划分节点后, 叶子节点的最少样本数, 默认 1 max_features: 划分节点时, 考虑的最大特征数, 默认 None 考虑所有, 设置数量后会随机选择 random_state: 随机种子, 控制模型的随机行为 ''' tree = DecisionTreeClassifier() # 定义列表, 用来储存不同深度下, 模型的分值 train_score = [] test_score = [] # 设置深度 1~12 开始训练 for depth in range(1, 13): tree = DecisionTreeClassifier(criterion='entropy', max_depth=depth, random_state=0) tree.fit(x_train, y_train) train_score.append(tree.score(x_train, y_train)) test_score.append(tree.score(x_test, y_test)) plt.plot(train_score, label='训练集分值') plt.plot(test_score, label='测试集分值') plt.xlabel('划分深度') plt.ylabel('分值') plt.legend() plt.show() 可见, 划分深度小, 训练集和测试集的分值都小, 容易欠拟合\n随着划分深度的增加, 分值都在增加, 模型预测效果也在变好\n当深度增加到一定程度, 深度再增加, 训练集分值随着增加, 但造成了模型过分依赖训练集数据特征, 从而测试集分值减小, 容易过拟合\n3, 不纯度度量标准 不纯度度量标准有:\n信息熵\n$$I_{H}(D)=-\\sum_{i=1}^{m} p(i \\mid D) \\log _{2} p(i \\mid D) $$m: 节点 D 中含有样本的类别数量\n$p(i \\mid D)$: 节点 D 中, 属于类别 i 的样本占节点 D 中样本总数的比例(概率)\n基尼系数\n$$I_{G}(D)=1-\\sum_{i=1}^{m} p(i \\mid D)^{2}$$错误率\n$$I_{E}(D)=1-\\max {p(i \\mid D)}$$看看各个度量标准与概率分布的关系:\ndef entropy(p): return -p * np.log2(p) - (1-p) * np.log2(1-p) def gini(p): return 1 - p**2 - (1-p)**2 def error(p): return 1 - np.max([p, 1-p], axis=0) p = np.linspace(0.0001, 0.9999, 200) en = entropy(p) er = error(p) g = gini(p) for i, lab, ls in zip([en, g, er], ['信息熵', '基尼系数', '错误率'], ['-', ':', '--']): plt.plot(p, i, label=lab, linestyle=ls, lw=2) plt.legend() plt.xlabel('概率分布') plt.ylabel('不纯度') plt.show() 可见, 无论选哪一种度量标准, 样本属于同一类, 不纯度都是 0; 样本中不同类别占比相同时, 不纯度最大\n4, 决策树常用算法介绍 ID3\nID3 (Iterative Dichotomiser3), 迭代二分法特点:\n-使用多叉树结构\n-使用信息熵作为不纯度度量, 选择信息增益最大的特征划分\n-经典算法, 简单, 训练快\n局限:\n-不支持连续特征\n-不支持缺失值处理\n-不支持回归\n-倾向选择特征取值多的特征来划分, 例如按身份证号划分, 一个号码就是一个特征\nC4.5\nID3算法改进而来, 特点:\n-使用多叉树结构\n-不支持回归\n优化:\n-支持缺失值处理\n-连续值进行离散化处理\n-信息熵作为不纯度度量, 但选择 信息增益率 最大的特征划分\n信息增益率:\n$$I G_{\\text {Ratio}}\\left(D_{p}, f\\right)=\\frac{I G_{H}\\left(D_{p}, f\\right)}{I_{H}(f)} $$ $I_{H}(f)$: 在特征 $f$ 下, 取各个特征值计算得到的信息熵之和, 其实就是特征 $f$ 的不纯度, 特征值越多, 特征不纯度越大\n选择信息增益最大的特征来划分, 父节点的信息熵不变, 就要求信息增益的第二项 $\\sum_{j=1}^{n} \\frac{N_{j}}{N_{p}} I\\left(D_{j}\\right)$ 最小, 从而会倾向选择特征取值多的特征\n因为, 特征取值多, 通常划分之后子节点的不纯度(信息熵)就更低, 例如极端情况, 选身份证划分, 划分之后不管什么类别, 子节点都只有一种类别, 不纯度都是 0, 第二项就是 0, 信息增益就最大\n因此, 采用信息增益率, 将 信息增益/特征不纯度, 就避免了 特征不纯度大 造成 信息增益大 而选择类别多的特征来划分的情况\n看看类别数量与信息熵的关系:\nen = lambda p: np.sum(-p * np.log2(p)) a1 = np.array([0.3, 0.7]) a2 = np.array([0.3, 0.3, 0.4]) a3 = np.array([0.25] * 4) a4 = np.array([0.1] * 10) print(en(a1), en(a2), en(a3), en(a4), sep='\\n') 0.8812908992306927 1.5709505944546684 2.0 3.321928094887362 CART\nCART (Classification And Regression Tree), 分类回归树, 特点如下:\n-使用二叉树结构\n-支持连续值与缺失值处理\n-分类时, 使用基尼系数作为不纯度度量, 选择基尼增益最大的特征划分\n-回归时, 使用 MSE 或 MAE 最小的特征划分\n5, 回归决策树 回归决策树因变量 y 是连续的, 使用叶子节点的均值来预测未知样本, 使用 MSE 或 MAE 作为特征划分的评估指标\n在 scikit-learn 中, 使用的是优化的 CART 算法来实现决策树\n以波士顿房价为例来实现(参数参考分类决策树):\nfrom sklearn.datasets import load_boston from sklearn.tree import DecisionTreeRegressor from sklearn.model_selection import train_test_split x, y = load_boston(return_X_y=True) x_train, x_test, y_train, y_test = train_test_split( x, y, test_size=0.25, random_state=1) tree = DecisionTreeRegressor(max_depth=5, random_state=0) tree.fit(x_train, y_train) print(tree.score(x_train, y_train)) print(tree.score(x_test, y_test)) 0.9204825770764915 0.8763987309111113 ",
    "description": "",
    "tags": null,
    "title": "决策树",
    "uri": "/statistics/statistics8/"
  },
  {
    "content": "命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间。不同命名空间中的变量没有关系。\n命名空间通过防止命名冲突来支持模块化。例如，函数 builtins.open 与 os.open 可通过各自的命名空间来区分。\n# 函数的局部命名空间，在函数调用时创建 def f(): x = '函数 f 命名空间中的变量 x' print(x) # 全局命名空间 x = '全局命名空间中的变量 x' # 调用函数 f，与全局命名空间中的 x 无关 f() 函数 f 命名空间中的变量 x\r# 模块 random 导入创建它自己的局部命名空间 import random # 定义一个全局变量 randint def randint(): print('全局 randint') # random 局部命名空间中的 randint # 与全局变量 randint 无关 randint() random.randint(0,3) 全局 randint\r1\r# 上述定义的变量 f, x, randint，导入的变量 random， # 都存放在了当前全局命名空间中 f, x, random, randint (\u003cfunction __main__.f()\u003e,\r'全局命名空间中的变量 x',\r\u003cmodule 'random' from 'C:\\\\ProgramData\\\\Anaconda3\\\\lib\\\\random.py'\u003e,\r\u003cfunction __main__.randint()\u003e)\r内置命名空间是在 Python 解释器启动时创建，存放的变量包括内置函数、异常等。\n# 全局命名空间中定义变量 str， # 将屏蔽内置命名空间中的 str def str(x): return f'x = {x}' str(123) 'x = 123'\r# 但可以在 builtins 中继续调用 import builtins builtins.str(123) '123'\r递归函数，每次递归调用，都会有一个新的命名空间。\ndef f(x): if x \u003e 0: print(f'x={x}调用，x-1={x-1}继续调用') if x == 0: print(f'x={x},调用结束') else: # 以 x-1 作为参数调用函数 f return f(x-1) f(3) x=3调用，x-1=2继续调用\rx=2调用，x-1=1继续调用\rx=1调用，x-1=0继续调用\rx=0,调用结束\r嵌套的命名空间：\na = '全局变量 a' class A: a = '类变量 a' def f(self): a = '函数局部变量 a' return a print(a) print(A.a) print(A().f()) 全局变量 a\r类变量 a\r函数局部变量 a\r",
    "description": "",
    "tags": null,
    "title": "命名空间",
    "uri": "/python/16_class/09_namespace/"
  },
  {
    "content": "生成器表达式和列表推导式非常相似，区别就是将方括号换成了小括号。\n生成器表达式返回的是一个生成器迭代器 generator。表达式会产生一系列值，可使用内置函数 next() 逐一获取，或使用 for 循环遍历。\n生成器迭代器中的元素，仅供一次性使用，而且可以要多少取多少，它会记住你取了多少，取到了哪里。\n(i*i for i in range(3)) \u003cgenerator object \u003cgenexpr\u003e at 0x00000271080FBC00\u003e\rg = (i*i for i in range(5)) type(g) generator\rnext(g), next(g) (0, 1)\rfor i in g: print(i) 4\r9\r16\r这种表达式被设计用于生成器将立即被外层函数所使用的情况。生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。\nsum(i*i for i in range(5)) 30\rlist(i*i for i in range(5)) [0, 1, 4, 9, 16]\r除了列表推导式和生成器表达式，集合和字典也可使用类似的推导式。\n{i*2 for i in 'abac'} {'aa', 'bb', 'cc'}\r{i:j for i,j in zip('abc',(1,2,3))} {'a': 1, 'b': 2, 'c': 3}\rjupyter附件 01_none.ipynb (2 KB) 02_comprehension.ipynb (4 KB) 03_other_types.ipynb (5 KB) ",
    "description": "",
    "tags": null,
    "title": "生成器表达式和推导式",
    "uri": "/python/08_other_types/"
  },
  {
    "content": "函数定义中使用了 yield 语句，该定义创建的函数是生成器函数。生成器函数通常也直接叫生成器。\n当一个生成器函数被调用的时候，它返回一个迭代器，也称为生成器（全称是生成器迭代器，下面所说生成器均指生成器迭代器）。然后通过这个生成器来控制生成器函数的执行。\n生成器是一个迭代器，也是一个可迭代对象。但一个生成器生成的 “元素” 只能被使用一次，原因如下：\n迭代生成器的时候，生成器函数开始执行，执行到 yield，然后执行被挂起，给生成器的调用者返回 yield 之后的表达式的值。挂起后，所有局部状态都被保留下来，包括局部变量的当前绑定，指令指针，内部求值栈和任何异常处理的状态。\n继续迭代生成器，生成器函数从挂起状态继续执行，执行到 yield，然后执行又被挂起，给生成器的调用者返回 yield 之后的表达式的值。\n生成器迭代完成时，引发 StopIteration。\n在一个生成器函数中，return 语句表示生成器已完成并将导致 StopIteration 被引发。返回值（如果有的话）会被当作一个参数用来构建 StopIteration 并成为 StopIteration.value 属性。\nnext(g) 0\rdef f(n): yield n g = f(0) print(f) print(g) \u003cfunction f at 0x000002480120ACA0\u003e\r\u003cgenerator object f at 0x000002480122E040\u003e\rnext(g) # 迭代结束 ---------------------------------------------------------------------------\rStopIteration Traceback (most recent call last)\r\u003cipython-input-3-c91425ed1388\u003e in \u003cmodule\u003e\r----\u003e 1 next(g) # 迭代结束\rStopIteration: def f(n): yield n n += 1 yield n n += 1 yield n # 生成器已完成，后面的不被执行 return 'end' n += 1 yield n g = f(0) while True: try: print(next(g)) except StopIteration as s: print(s.value) # StopIteration.value 属性 break # 迭代结束，不能再次迭代生成器 next(g) 0\r1\r2\rend\r---------------------------------------------------------------------------\rStopIteration Traceback (most recent call last)\r\u003cipython-input-10-3ebb4e469fc1\u003e in \u003cmodule\u003e\r19 break\r20 # 迭代结束，不能再次迭代生成器\r---\u003e 21 next(g)\rStopIteration: yield from 将可迭代对象中的每一项作为生成器的迭代项：\ndef f(*args): yield from args g = f(1,2,3) next(g),list(g) (1, [2, 3])\rdef f(arg): yield from arg g = f('123') print(list(g)) # g 使用结束，再次使用什么也没有，创建了一个空列表 print(list(g)) # 如要再次使用可再创建一个生成器 list(f('123')) ['1', '2', '3']\r[]\r['1', '2', '3']\r",
    "description": "",
    "tags": null,
    "title": "生成器函数",
    "uri": "/python/12_function/09_generator/"
  },
  {
    "content": "内置函数（类）classmethod，Python 官方文档描述如下：\nhelp(classmethod) Help on class classmethod in module builtins:\rclass classmethod(object)\r| classmethod(function) -\u003e method\r| | Convert a function to be a class method.\r| | A class method receives the class as implicit first argument,\r| just like an instance method receives the instance.\r| To declare a class method, use this idiom:\r| | class C:\r| @classmethod\r| def f(cls, arg1, arg2, ...):\r| ...\r| 把一个函数封装成类方法。一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。\n可将函数作为参数来声明类方法，但请用习惯的装饰器形式（@classmethod）来声明类方法。\ntype(classmethod) type\rclass A: print_itself = classmethod(print) A.print_itself() \u003cclass '__main__.A'\u003e\rclass A: @classmethod def print_itself(cls): print(cls) A.print_itself() \u003cclass '__main__.A'\u003e\r",
    "description": "",
    "tags": null,
    "title": "classmethod 封装函数为类方法",
    "uri": "/python/11_built-in_function/10_classmethod/"
  },
  {
    "content": "def 语句是定义函数的语句。语法如下：\n@assignment_expression\rdef funcname(parameter_list) -\u003e expression:\rsuite 其中的装饰器 @assignment_expression，形参 parameter_list 和标注 -\u003e expression 是可选项。\n函数定义是一条可执行语句。它执行时会将函数名称 funcname 绑定到一个函数对象（函数可执行代码的包装器）。\n例如，用必选项定义一个什么也不做的函数如下：\ndef f(): pass f \u003cfunction __main__.f()\u003e\r一个函数定义可以被一个或多个装饰器表达式所包装。\n装饰器必须是可调用对象，它会以该函数对象作为唯一参数被发起调用。\n其返回值将被绑定到函数名称。多个装饰器会以嵌套方式被应用。\n@str @type def f():pass f \"\u003cclass 'function'\u003e\"\r大致相当于：\ndef f():pass f = str(type(f)) f \"\u003cclass 'function'\u003e\"\r函数形参 parameter_list 详见 函数形参。\n函数标注 -\u003e expression 可以是任何表达式，标注对提高代码的可读性非常有用，看标注而不需要看代码上下文就大概知道代码的使用。例如：\n# 标注函数的参数和返回值类型 def f(arg:int) -\u003e list: return list(str(arg)) f(123) ['1', '2', '3']\r",
    "description": "",
    "tags": null,
    "title": "def",
    "uri": "/python/10_statement/10_def/"
  },
  {
    "content": "字典方法 dict.clear()，Python 官方文档描述如下：\nhelp(dict.clear) Help on method_descriptor:\rclear(...)\rD.clear() -\u003e None. Remove all items from D.\r清空字典元素。\nd = {'a':1, 'b':2} d.clear() d {}\r该方法是一个过程，返回值为 None。\nd = {'a':1, 'b':2} print(d.clear()) None\r",
    "description": "",
    "tags": null,
    "title": "dict.clear 清空字典元素",
    "uri": "/python/07_dictionary/10_dict.clear/"
  },
  {
    "content": "1, 聚类 前面接触的算法, 都是 监督学习 , 即训练数据中自变量(特征)和因变量(结果)都是已知的, 用含有结果的训练集建立模型, 然后对未知结果的数据进行预测\n聚类属于 无监督学习 , 训练数据中没有”已知结果的监督”. 聚类的目的, 就是通过已知样本数据的特征, 将数据划分为若干个类别, 每个类别成一个类簇, 使得同一个簇内的数据相似度越大, “物以类聚”, 不同簇之间的数据相似度越小, 聚类效果越好\n聚类的样本相似度根据距离来度量\n2, K-Means 即 K 均值算法, 是常见的聚类算法, 该算法将数据集分为 K 个簇, 每个簇使用簇内所有样本的均值来表示, 该均值称为”质心”\nK-Means 算法的目标, 就是选择适合的质心, 使得每个簇内, 样本点距质心的距离尽可能的小, 从而保证簇内样本有较高相似度\n算法实现步骤:\na, 从样本中选择 K 个点作为初始质心\nb, 计算每个样本点到各个质心的距离, 将样本点划分到距离最近的质心所对应的簇中\nc, 计算每个簇内所有样本的均值, 使用该均值作为新的质心\nd, 重复 b 和 c, 重复一定次数质心一般会趋于稳定, 如果达到以下条件, 重复结束:\n– 质心位置变化小于指定的阈值\n– 达到最迭代环次数\n对于算法的实现步骤, 我们有几个重要的疑问:\n– 1.怎么评价质心是否达到了最佳位置?\n– 2.初始质心随机选, 还是选在哪里?\n– 3. K 值怎么定?\n3, 算法优化目标 样本的相似度是根据距离来度量的, 一般使用簇内 误差平方和 (within-cluster SSE 簇惯性) 来作为优化算法的目标函数, 距离常用欧氏距离, 优化目标就是使 SSE 最小化:\n$$S S E=\\sum_{i=1}^{k} \\sum_{j=1}^{m_{i}}\\left(\\left|x_{j}-\\mu_{i}\\right|^{2}\\right)$$k: 族的数量\n$m_{i}$: 第 i 个簇含有的样本数量\n${\\mu}_{i}$: 第 i 个族的质心\n$\\left|x_{j}-\\mu_{i}\\right|$: 第 i 个族中，每个样本 $x_{j}$ 与质心 $\\mu_{i}$ 的距离\n同一个数据集, 相同的簇数, SSE 越小, 通常质心位置更佳, 算法模型更好\n4, 初始质心的影响 初始质心可以随机选择, 但由于算法是通过迭代初始质心一步步实现, 初始质心的位置受随机性影响, 算法训练的最终结果也会受到影响\nimport numpy as np from sklearn.cluster import KMeans from sklearn.datasets import make_blobs import matplotlib.pyplot as plt plt.rcParams['font.family'] = 'Microsoft YaHei' plt.rcParams['font.size'] = 12 plt.rcParams['axes.unicode_minus'] = False ''' 生成数据: n_samples: 样本数量 n_features: 特征数 centers: 聚类中心 cluster_std: 簇的标准差, 可以统一指定, 也分别指定 ''' centers = [[1, 1], [5, 2], [2, 5]] x, y = make_blobs(n_samples=90, n_features=2, centers=centers, cluster_std=[2.2, 2.5, 2], random_state=0) # x 是特征, y 是类别标签 # 绘制原始数据 plt.figure(figsize=(12,8)) plt.subplot(221) colors = np.array(['Coral', 'SeaGreen', 'RoyalBlue']) plt.scatter(x[:, 0], x[:, 1], c=colors[y], marker='.', label='原始数据') plt.title('原始数据') # 定义绘制聚类结果的函数 def plot_cluster(model, train, test=None): global colors # 使用上面的颜色 cc = model.cluster_centers_ # 获取质心 label = model.labels_ # 获取聚类结果的标签 # 绘制质心 plt.scatter(cc[:, 0], # 质心的 x 坐标 cc[:, 1], # 质心的 y 坐标 marker='*', s=150, c=colors) # 绘制训练集 plt.scatter(train[:, 0], train[:, 1], marker='.', c=colors[label]) # 绘制测试集 if test is not None: y_hat = model.predict(test) plt.scatter(test[:, 0], test[:, 1], marker='+', s=150, c=colors[y_hat]) # 标题 plt.title(f'SSE:{model.inertia_:.1f} 迭代次数:{model.n_iter_}') # 测试集 test = np.array([[6, 5]]) # 绘制不同初始质心的聚类结果 seed = [1, 10, 100] for i in range(2, 5): plt.subplot(2, 2, i) kmeans = KMeans(n_clusters=3, # 簇数 init='random', # 初始化方式 n_init=1, # 初始化质心组数 random_state=seed[i-2]) kmeans.fit(x) plot_cluster(kmeans, x) # 测试结果 plot_cluster(kmeans, x, test) 从上图可以看出受初始化质心的影响, 聚类效果(SSE) 与 收敛速度(迭代次数) 会不同, 也即是可能会收敛到局部最小, 而不是整体最优; 同时, 也可以看出 SSE 越小, 整体结果越优, 越接近原始数据\n5, K-Means++ 优化 针对上述初始化质心造成的问题, 设置初始化多组质心可以得到缓解, 但通常限于聚类簇数较少的情况, 如果簇数较多, 可能就不会有效\n于是有了 K-Means++, 选择初始化质心时, 不在随机选, 而是按下述步骤进行选择:\n– 1, 从训练数据中随机选择一个样本点, 作为初始质心\n– 2, 对任意一个非质心样本点 $x^{(i)}$, 计算 $x^{(i)}$ 与现有最近质心的距离 $D\\left(x^{(i)}\\right)$\n– 3, 根据概率 $\\frac{D\\left(x^{(i)}\\right)^{2}}{\\sum_{j=1}^{m}D\\left(x^{(j)}\\right)^{2}}$ 最大, 来选择最远的一个样本点 $x^{(i)}$ 作为质心, m 为非质心样本点数量\n– 4, 重复 2 和 3, 直到选择了 K 个质心为止\n做了优化之后, 保证了初始质心不会集中, 而是分散在数据集中\n下面试试 K-Means++ 的聚类效果:\nkmeans = KMeans(n_clusters=3, init='k-means++', n_init=1) kmeans.fit(x) plot_cluster(kmeans, x) 6, 确定 K 值 K 是超参数, 需要预先人为指定\n有时需要按照建模的需求和目的来选择聚类的个数, 但是 K 值选择不当, 聚类效果可能不佳. 例如实际 3 类, K 选了 10, 或者 K 无限制, 取值和样本点个数一样, 最后每个点一个类, SEE 为 0, 但是聚类已经毫无意义\n如果不是硬性要求 K 的取值, 怎么确定最佳的 K 值呢? 一个比较好的方法就是 肘部法则 :\nSEE 需要越小越好, K 又不能取太大, 我们可以看看他们之间的关系:\n# 设置列表储存 SSE sse = [] # K 值从 1~9 变化 scope = range(1, 10) for k in scope: kmeans = KMeans(n_clusters=k) kmeans.fit(x) sse.append(kmeans.inertia_) plt.xticks(scope) plt.plot(scope, sse, marker='o') plt.show() 从上图可以看出, K 增加, SSE 减小, 但当 K \u003e 3 时, K 再增加, SSE 减小变得缓慢, 所以 K 选择 3, 实际情况也是 3\n6, Mini Batch K-Means K-Means 每次迭代都会使用所有数据参与运算, 当数据集较大时, 会比较耗时. Mini Batch K-Means (小批量 K-Means) 算法每次迭代使用小批量样本训练, 逐批次累计的方式进行计算, 从而大大减少计算时间. 效果上, 通常只是略差于 K-Means\nMini Batch K-Means 算法实现步骤:\na, 从数据集中随机选择部分数据, 使用 K-Means 算法在这部分数据上聚类, 获取质心\nb, 再从数据集中随机选择部分数据, 分别分配给最近的质心\nc, 每个簇根据现有的数据集更新质心\nd, 重复 b 和 c, 直到质心变化小于指定阈值或达到最大迭代次数\n下面比较一下两个算法:\nimport time import pandas as pd from sklearn.cluster import MiniBatchKMeans from sklearn.metrics.pairwise import pairwise_distances_argmin import warnings warnings.filterwarnings('ignore') # 生成数据 centers = [[1, 1], [400, 100], [100, 400]] x, y = make_blobs(n_samples=8000, n_features=2, centers=centers, cluster_std=120, random_state=0) # 定义函数, 用于计算模型训练时间 def elapsed_time(model, data): start = time.time() model.fit(data) end = time.time() return end - start n_clusters = len(centers) kmeans = KMeans(n_clusters=n_clusters) mbk = MiniBatchKMeans(n_clusters=n_clusters, batch_size=200, # 小批量的大小 n_init=10 # 和 KMeans 统一为 10 ) kmeans_time = elapsed_time(kmeans, x) mbk_time = elapsed_time(mbk, x) print('K-Means耗时:', kmeans_time) print('Mini Batch K-Means耗时:', mbk_time) # 绘制聚类效果 plt.figure(figsize=(12, 5)) model = [kmeans, mbk] for i, m in enumerate(model, start=1): plt.subplot(1, 2, i) plot_cluster(m, x) K-Means耗时: 0.051812171936035156 Mini Batch K-Means耗时: 0.04886937141418457 可见, 聚类耗时 K-Means 更多, 如果数据量很大, 耗时会更明显, 而聚类效果基本一样. 但发现颜色对不上, 这是因为质心的随机性, 聚类之后质心虽然最终落在相同的位置, 但是顺序不一致, 从而聚类的结果标签不一致, 即使是同一个算法, 运行几次, 标签结果也会不一致\n我们将相同簇用相同的颜色绘制:\nplt.figure(figsize=(12, 5)) # 定义列表, 用来保存两个模型预测结果 y_hat_list = [] for i, m in enumerate(model, start=1): plt.subplot(1, 2, i) y_hat = m.predict(x) if m == mbk: ''' 因为输出的质心顺序就是训练结果标签的顺序 故可以按 mbk 训练的质心, 去找 kmeans 训练的相同簇的质心 pairwise_distances_argmin(x, y) 解释: 依次取出数组 X 中的元素 x, 计算找到数组 Y 中与 x 距离最近的元素 y 的索引, 返回索引构成的数组 ''' # 将两者相同簇的质心一一对应并按 mbk 质心的顺序封装成字典 ar = pairwise_distances_argmin( mbk.cluster_centers_, kmeans.cluster_centers_) dict_ = dict(enumerate(ar)) # 用 mbk 的训练结果标签 y_hat 就可以寻找到对应的 kmeans 的质心 y_hat = pd.Series(y_hat).map(dict_).values # 将预测结果加入到列表中 y_hat_list.append(y_hat) plt.scatter(x[:, 0], x[:, 1], c=colors[y_hat], marker='.') 比较两个算法聚类结果的差异:\nsame = y_hat_list[0] == y_hat_list[1] diff = y_hat_list[0] != y_hat_list[1] plt.scatter(x[same, 0], x[same, 1], c='g', marker='.', label='预测相同') plt.scatter(x[diff, 0], x[diff, 1], c='r', marker='.', label='预测不同') plt.legend() print('相同数量:', x[same].shape[0]) print('不同数量:', x[diff].shape[0]) 相同数量: 7967 不同数量: 33 两个算法聚类结果只有 33 个样本点不同\n",
    "description": "",
    "tags": null,
    "title": "K-Means 算法",
    "uri": "/statistics/statistics9/"
  },
  {
    "content": "列表方法 list.pop()，Python 官方文档描述如下：\nhelp(list.pop) Help on method_descriptor:\rpop(self, index=-1, /)\rRemove and return item at index (default last).\rRaises IndexError if list is empty or index is out of range.\r删除列表中给定位置的元素并返回它。如果没有给定位置，list.pop() 将会删除并返回列表中的最后一个元素。给定位置超出范围，抛出 IndexError 错误。\n_list = [1,2,3,4] _list.pop() 4\r_list [1, 2, 3]\r_list.pop(0) 1\r_list [2, 3]\r_list.pop(5) ---------------------------------------------------------------------------\rIndexError Traceback (most recent call last)\r\u003cipython-input-4-efa5a84417c8\u003e in \u003cmodule\u003e\r----\u003e 1 _list.pop(5)\rIndexError: pop index out of range\r",
    "description": "",
    "tags": null,
    "title": "list.pop 删除元素并返回",
    "uri": "/python/03_list/10_list.pop/"
  },
  {
    "content": "集合方法 set.update()，Python 官方文档描述如下：\nhelp(set.update) Help on method_descriptor:\rupdate(...)\rUpdate a set with the union of itself and others.\r该方法接收任意的位置参数，将其他集合的元素合并到一个集合中。相当于 a |= b | … （a，b 是集合），但方法的参数可以是可迭代对象。\na = {1,2} a.update([3],(4,5)) a {1, 2, 3, 4, 5}\ra = {1,2} a |= {3} | {4,5} a {1, 2, 3, 4, 5}\r该方法是一个过程，就地修改集合，返回值为 None。\na = {1,2} b = a.update([3],(4,5)) print(b) None\r",
    "description": "",
    "tags": null,
    "title": "set.update 合并更新",
    "uri": "/python/06_set/10_set.update/"
  },
  {
    "content": "字符串方法 str.rpartition()，Python 官方文档描述如下：\nhelp(str.rpartition) Help on method_descriptor:\rrpartition(self, sep, /)\rPartition the string into three parts using the given separator.\rThis will search for the separator in the string, starting at the end. If\rthe separator is found, returns a 3-tuple containing the part before the\rseparator, the separator itself, and the part after it.\rIf the separator is not found, returns a 3-tuple containing two empty strings\rand the original string.\r在 sep 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。\n'python'.rpartition('n') ('pytho', 'n', '')\r'pythhhon'.rpartition('hh') ('pyth', 'hh', 'on')\r分隔符未找到，则返回的 3 元组中 字符串本身 排在最后：\n'python'.rpartition('ht') ('', '', 'python')\r",
    "description": "",
    "tags": null,
    "title": "str.rpartition 拆分",
    "uri": "/python/02_string/10_str.rpartition/"
  },
  {
    "content": "操作符概述 操作符可分为运算符（operators）和分隔符（delimiters）。\n运算符有：\n数字运算符 +，-，*，**，/，//，%，详细用法见 数字运算。\n整数按位运算符 \u003c\u003c，\u003e\u003e，\u0026，|，^，~，详细用法见 整数及其位运算。\n比较运算符 \u003c，\u003e，\u003c=，\u003e=，==，!=，in，not in，is，is not，详细用法见 比较运算符。\n布尔运算符 and，or，not，详细用法见 布尔值及布尔运算。\n赋值运算符 := Python 3.8 新增，将右边的表达式赋值给左边的变量， 同时返回表达式的值。\n(a := 1+1) 2\r运算符还分为一元运算符和二元运算符，一元运算符运算一个对象（操作数），二元运算符运算两个。一元运算符有 +（正数），-（负数），~（整数按位取反）和 not（布尔运算 非）。if ... else ... 有时称作三元运算符。\n-1, +2, ~3, not 4 (-1, 2, -4, False)\r1 + 2 - 3 * 4 # 二元运算符加、减和乘 -9\rTrue if 2 \u003e 3 else False False\r分隔符有：\n(，)，[，]，{，}，,，:，.，;，=，+=，-=，*=，/=，//=，%=，\u0026=，|=，^=，\u003e\u003e=，\u003c\u003c=，**=\n部分分隔符用法举例：\n圆括号绑定表达式，或元组显示，方括号用来对序列进行索引、切片取值或列表显示，花括号字典显示或集合显示\n3 * (1 + 2) * (1,) (1, 1, 1, 1, 1, 1, 1, 1, 1)\r[1,2,3,4][1:3] [2, 3]\r{'列表':[], '集合':{1,2,3}} {'列表': [], '集合': {1, 2, 3}}\r上述分隔符 = 为赋值操作符，之后的操作符为增强赋值操作符，将名称绑定（或重新绑定）到特定值，以及修改属性或可变对象的成员项。 详见 赋值语句。\n假设将值 value1 绑定到名称 name，name = value1，则 name += value2 的结果相当于 name = name + value2，其他操作符类似。\n举例如下：\na = 1 a += 1 a 2\rb = 17 b |= 5 b 21\r除了运算符和分隔符，还有 '，\"，\\，# 字符，作为其他字符的组成部分时具有特殊含义，或是对词法分析器有重要意义。\n'，\"，\\，详见 字符串概述 和 转义字符。\n# 通常用来注释代码，但不能包含在字符串中，注释在语法分析中会被忽略：\n# 这是注释 ''' # hello world # hello python ''' '\\n# hello world\\n# hello python\\n'\r操作符除了常规的用法，操作不同的数据类型，相应的数据类型可能定义了特定的操作规则；在特定的应用场景，也有着特殊的用法。详见 操作符特殊用法\njupyter附件 01_operator_summary.ipynb (7 KB) 02_compare.ipynb (14 KB) 03_precedence.ipynb (4 KB) 04_special.ipynb (3 KB) ",
    "description": "",
    "tags": null,
    "title": "操作符概述",
    "uri": "/python/09_operator/"
  },
  {
    "content": "作用域定义了一个代码块中名称的可见性。如果代码块中定义了一个局部变量，则其作用域包含该代码块。如果定义发生于函数代码块中，则其作用域会扩展到该函数所包含的任何代码块，除非有某个被包含代码块引入了对该名称的不同绑定。\n当一个名称在代码块中被使用时，会由包含它的最近作用域来解析。对一个代码块可见的所有这种作用域的集合称为该代码块的环境。\n一个作用域是一个 命名空间 可直接访问的 Python 程序的文本区域。这里的 “可直接访问” 意味着对名称的非限定引用（限定引用指点号表达式例如 math.pi）会尝试在命名空间中查找名称。\n# 全局变量作用域为当前模块 a = '全局变量' def f(): # print 内置名称作用域包含全局 print(f'print 函数的命名空间可以访问：{a}') return f'f 的命名空间可以访问：{a}' print(a) print(f()) 全局变量\rprint 函数的命名空间可以访问：全局变量\rf 的命名空间可以访问：全局变量\r# 全局变量作用域为当前模块 # 但被包含命名空间引入了同名的局部变量 a = '全局变量' def f(): # f 中定义的局部变量 # 作用域为函数内部 a = '局部变量' print(f'print 函数的命名空间可以访问：{a}') return f'f 的命名空间可以访问：{a}' print(a) print(f()) 全局变量\rprint 函数的命名空间可以访问：局部变量\rf 的命名空间可以访问：局部变量\r虽然作用域是静态地确定的，但它们会被动态地使用。嵌套作用域的搜索顺序:\n最先搜索最内部作用域包含的局部名称 从最近的封闭作用域开始搜索作用域包含的名称 倒数第二个作用域包含当前模块的全局名称 最外面的作用域（最后搜索）是包含内置名称的命名空间 # 搜索最内部作用域名称 str # 屏蔽上层作用域 def f(): str = 0 def f1(): str = 1 return str return f1() f(), str (1, str)\r# 搜索最近封闭作用域名称 str # 屏蔽上层作用域 def f(): str = 0 def f1(): return str return f1() f(), str (0, str)\r# 搜索当前模块作用域名称 str # 屏蔽上层作用域 str = '当前模块str' def f(): def f1(): return str return f1() f() '当前模块str'\r# 搜索最外面作用域名称 str # 删除前面对 str 的绑定 del str # 注意，运行多次会将内置名称 str 都删除 def f(): def f1(): return str return f1() f() str\r可见，当前模块中的全局名称，最好不要和内置名称相同，它会屏蔽掉内置名称，从而不可以直接使用内置功能。内置名称如下：\nimport builtins dir(builtins) ['ArithmeticError',\r'AssertionError',\r'AttributeError',\r'BaseException',\r'BlockingIOError',\r'BrokenPipeError',\r'BufferError',\r'BytesWarning',\r'ChildProcessError',\r'ConnectionAbortedError',\r'ConnectionError',\r'ConnectionRefusedError',\r'ConnectionResetError',\r'DeprecationWarning',\r'EOFError',\r'Ellipsis',\r'EnvironmentError',\r'Exception',\r'False',\r'FileExistsError',\r'FileNotFoundError',\r'FloatingPointError',\r'FutureWarning',\r'GeneratorExit',\r'IOError',\r'ImportError',\r'ImportWarning',\r'IndentationError',\r'IndexError',\r'InterruptedError',\r'IsADirectoryError',\r'KeyError',\r'KeyboardInterrupt',\r'LookupError',\r'MemoryError',\r'ModuleNotFoundError',\r'NameError',\r'None',\r'NotADirectoryError',\r'NotImplemented',\r'NotImplementedError',\r'OSError',\r'OverflowError',\r'PendingDeprecationWarning',\r'PermissionError',\r'ProcessLookupError',\r'RecursionError',\r'ReferenceError',\r'ResourceWarning',\r'RuntimeError',\r'RuntimeWarning',\r'StopAsyncIteration',\r'StopIteration',\r'SyntaxError',\r'SyntaxWarning',\r'SystemError',\r'SystemExit',\r'TabError',\r'TimeoutError',\r'True',\r'TypeError',\r'UnboundLocalError',\r'UnicodeDecodeError',\r'UnicodeEncodeError',\r'UnicodeError',\r'UnicodeTranslateError',\r'UnicodeWarning',\r'UserWarning',\r'ValueError',\r'Warning',\r'WindowsError',\r'ZeroDivisionError',\r'__IPYTHON__',\r'__build_class__',\r'__debug__',\r'__doc__',\r'__import__',\r'__loader__',\r'__name__',\r'__package__',\r'__spec__',\r'abs',\r'all',\r'any',\r'ascii',\r'bin',\r'bool',\r'breakpoint',\r'bytearray',\r'bytes',\r'callable',\r'chr',\r'classmethod',\r'compile',\r'complex',\r'copyright',\r'credits',\r'delattr',\r'dict',\r'dir',\r'display',\r'divmod',\r'enumerate',\r'eval',\r'exec',\r'filter',\r'float',\r'format',\r'frozenset',\r'get_ipython',\r'getattr',\r'globals',\r'hasattr',\r'hash',\r'help',\r'hex',\r'id',\r'input',\r'int',\r'isinstance',\r'issubclass',\r'iter',\r'len',\r'license',\r'list',\r'locals',\r'map',\r'max',\r'memoryview',\r'min',\r'next',\r'object',\r'oct',\r'open',\r'ord',\r'pow',\r'print',\r'property',\r'range',\r'repr',\r'reversed',\r'round',\r'set',\r'setattr',\r'slice',\r'sorted',\r'staticmethod',\r'str',\r'sum',\r'super',\r'tuple',\r'type',\r'vars',\r'zip']\r",
    "description": "",
    "tags": null,
    "title": "作用域",
    "uri": "/python/16_class/10_scope/"
  },
  {
    "content": "内置函数 compile()，Python 官方文档描述如下：\nhelp(compile) Help on built-in function compile in module builtins:\rcompile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)\rCompile source into a code object that can be executed by exec() or eval().\rThe source code may represent a Python module, statement or expression.\rThe filename will be used for run-time error messages.\rThe mode must be 'exec' to compile a module, 'single' to compile a\rsingle (interactive) statement, or 'eval' to compile an expression.\rThe flags argument, if present, controls which future statements influence\rthe compilation of the code.\rThe dont_inherit argument, if true, stops the compilation inheriting\rthe effects of any future statements in effect in the code calling\rcompile; if absent or false these statements do influence the compilation,\rin addition to any features explicitly specified.\r将 source 编译成代码或 AST 对象。代码对象可以被 exec() 或 eval() 执行。\n参数说明：\nsource，要编译的资源，可以是字符串、字节或 AST 对象。 filename，源所来自的文件的名称。如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用字符串）。 mode，指定了编译代码必须用的模式。如果 source 是语句序列，可以是 ’exec’；如果是单一表达式，可以是 ’eval’；如果是单个交互式语句，可以是 ‘single’。 flags\t和 dont-inherit，控制在编译 source 时要用到哪个 future 语句。 optimize，指定编译器的优化级别；默认值 -1 选择与解释器的 -O 选项相同的优化级别。 source = 'for i in range(3):print(i)' code = compile(source,'null','exec') code \u003ccode object \u003cmodule\u003e at 0x000001E999B07780, file \"null\", line 1\u003e\rexec(code) 0\r1\r2\reval(code) 0\r1\r2\r",
    "description": "",
    "tags": null,
    "title": "compile() 创建代码对象",
    "uri": "/python/11_built-in_function/11_compile/"
  },
  {
    "content": "字典方法 dict.setdefault()，Python 官方文档描述如下：\nhelp(dict.setdefault) Help on method_descriptor:\rsetdefault(self, key, default=None, /)\rInsert key with a value of default if key is not in the dictionary.\rReturn the value for key if key is in the dictionary, else default.\r如果字典存在键 key，则返回它的值；如果 key 不存在，则插入 key，以 default（默认 None）作为它的值，并返回。\nd = {'a':1, 'b':2} d.setdefault('a') 1\rd.setdefault('c', 3) 3\rd {'a': 1, 'b': 2, 'c': 3}\rd.setdefault('c', 4) # 如果存在，并不会再次设置 3\rd {'a': 1, 'b': 2, 'c': 3}\r",
    "description": "",
    "tags": null,
    "title": "dict.setdefault 获取或插入元素",
    "uri": "/python/07_dictionary/11_dict.setdefault/"
  },
  {
    "content": "列表方法 list.remove()，Python 官方文档描述如下：\nhelp(list.remove) Help on method_descriptor:\rremove(self, value, /)\rRemove first occurrence of value.\rRaises ValueError if the value is not present.\r移除列表中第一个值为 value 的元素。如果没有这样的元素，则抛出 ValueError 异常。\n_list = [1,3,2,3] _list.remove(3) _list [1, 2, 3]\r_list.remove(4) ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-3-5747ddae04fe\u003e in \u003cmodule\u003e\r----\u003e 1 _list.remove(4)\rValueError: list.remove(x): x not in list\r该方法是一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 None), 直接对原列表进行修改：\n_list = [1,3,2,3] a = _list.remove(3) print(a) None\r",
    "description": "",
    "tags": null,
    "title": "list.remove 移除一个元素",
    "uri": "/python/03_list/11_list.remove/"
  },
  {
    "content": "return 在语法上只会出现于函数定义所嵌套的代码，不会出现于类定义所嵌套的代码。\n如果提供了表达式，它将被求值，否则以 None 替代（类似省略 return 语句结果）。\nreturn 会离开当前函数调用，并以表达式的值 (或 None) 作为返回值。\n当 return 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然后再真正离开该函数。\ndef f2(): x =1 print(f2()) None\rdef f1(): x = 1 return print(f1()) None\r# return 结束函数调用 def f(x): return x**2 print('end') # retrun 结束函数调用，不会被执行 f(2) 4\r# finally 总是被执行再结束函数调用 def f(x): try: return 3/x except ZeroDivisionError as e: print(e) finally: return x, x**2 f(0),f(2) division by zero\r((0, 0), (2, 4))\r",
    "description": "",
    "tags": null,
    "title": "return",
    "uri": "/python/10_statement/11_return/"
  },
  {
    "content": "集合方法 set.intersection_update()，Python 官方文档描述如下：\nhelp(set.intersection_update) Help on method_descriptor:\rintersection_update(...)\rUpdate a set with the intersection of itself and another.\r该方法接收任意的位置参数，更新集合，只保留在其他所有集合中都存在的元素。相当于 a \u0026= b \u0026 …（a，b 是集合），但方法的参数可以是可迭代对象。\na = {1,2,3,4} a.intersection_update((1,2,5),{1,3,5}) a {1}\ra = {1,2,3,4} a \u0026= {1,2,5} \u0026 {1,3,5} a {1}\r该方法是一个过程，就地修改集合，返回值为 None。\na = {1,2,3,4} b = a.intersection_update() print(b) None\r",
    "description": "",
    "tags": null,
    "title": "set.intersection_update 交集更新",
    "uri": "/python/06_set/11_set.intersection_update/"
  },
  {
    "content": "字符串方法 str.splitlines()，Python 官方文档描述如下：\nhelp(str.splitlines) Help on method_descriptor:\rsplitlines(self, /, keepends=False)\rReturn a list of the lines in the string, breaking at line boundaries.\rLine breaks are not included in the resulting list unless keepends is given and\rtrue.\r返回由原字符串中各行组成的列表，在行边界的位置拆分。结果列表中不包含行边界，除非给出了 keepends 且为真值。\n此方法会以下列行边界进行拆分。特别地，行边界是 universal newlines 的一个超集。\n\\n 换行 \\r 回车 \\r\\n 回车 + 换行 \\v 或 \\x0b 行制表符 \\f 或 \\x0c 换表单 \\x1c 文件分隔符 \\x1d 组分隔符 \\x1e 记录分隔符 \\x85 下一行 \\u2028 行分隔符 \\u2029 段分隔符 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines() ['ab c', '', 'de fg', 'kl']\r'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True) ['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']\r分隔空字符串此方法将返回一个空列表；末尾的换行不会令结果中增加额外的空字符串:\n''.splitlines() []\r\"One line\\nTwo lines\\n\".splitlines() ['One line', 'Two lines']\r'One line\\nTwo lines\\n'.split('\\n') ['One line', 'Two lines', '']\r",
    "description": "",
    "tags": null,
    "title": "str.splitlines 按行拆分",
    "uri": "/python/02_string/11_str.splitlines/"
  },
  {
    "content": "语句分为简单语句和复合语句，简单语句由一个单独的逻辑行构成。多条简单语句可以存在于同一行内并以分号分隔。表达式语句属于简单语句。\n表达式语句用于计算和写入值（大多是在交互模式下），或者调用一个过程 (过程就是不返回有意义结果的函数。在 Python 中，过程的返回值为 None)。\n表达式语句会对指定的表达式进行求值。\n在交互模式下，它会通过内置的 repr() 函数转换为一个字符串，该结果字符串将以单独一行的形式写入标准输出（例外情况是如果结果为 None，则该过程调用不产生任何输出）。\n以下均是一个表达式语句（可包含多个表达式）：\n'python' 'python'\r1 1\r(a := 1) # 3.8 新功能，赋值表达式 1\ra 1\r'a\\n',f'b{1}' # 两个表达式 ('a\\n', 'b1')\r1 + 2 * 3 / 5, True and False # 两个表达式 (2.2, False)\rlambda x: x**2 \u003cfunction __main__.\u003clambda\u003e(x)\u003e\r0 if 2\u003e3 else (1 if 5\u003c6 else 2) 1\r[1,2,3] + [4] [1, 2, 3, 4]\r[].append(1) # 返回 None [].append(1) is None True\r# 返回值为 None，输出并不是表达式的值 print('非表达式的值') is None 非表达式的值\rTrue\rsum(i for i in [3,2,5]) 10\rlist(zip('abc',[1,2,3]))[1:] [('b', 2), ('c', 3)]\r用分号分隔多个表达式语句，输出最后一个的值。\n1; print('非表达式的值'); 1 + 2 * 3 / 5, True and False 非表达式的值\r(2.2, False)\rjupyter附件 01_expression.ipynb (6 KB) 02_assignment.ipynb (8 KB) 03_if.ipynb (3 KB) 04_for.ipynb (3 KB) 05_while.ipynb (1 KB) 06_break.ipynb (4 KB) 07_continue.ipynb (3 KB) 08_del.ipynb (5 KB) 09_pass.ipynb (1 KB) 10_def.ipynb (3 KB) 11_return.ipynb (2 KB) 12_yield.ipynb (4 KB) 13_class.ipynb (3 KB) 14_try.ipynb (15 KB) 15_raise.ipynb (12 KB) 16_with.ipynb (4 KB) 17_assert.ipynb (3 KB) 18_import.ipynb (11 KB) 19_global.ipynb (3 KB) 20_nonlocal.ipynb (4 KB) ",
    "description": "",
    "tags": null,
    "title": "表达式语句",
    "uri": "/python/10_statement/"
  },
  {
    "content": "直接调用类对象，即可创建该类的实例对象。\nint() # 调用 int 类 0\rlist('123') # 传参调用 list 类 ['1', '2', '3']\rclass A: def __init__(self, name): self.name = name def __repr__(self): return self.name A('实例1'), A('实例2') # 调用自定义类 (实例1, 实例2)\r实例对象是由特殊方法 __new__() 创建，__init__() 定制完成。两个方法是隐式地完成创建和定制的，当然也可以显式地创建并定制。\nclass A: def __init__(self): self.name = '实例' A # 类对象 A __main__.A\r# 显式地创建类 A 的一个实例 a a = object.__new__(A) a \u003c__main__.A at 0x20d23e95d30\u003e\r# 未初始化，无属性 a.name ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-36-b3a4d04d98fc\u003e in \u003cmodule\u003e\r1 # 未初始化，无属性\r----\u003e 2 a.name\rAttributeError: 'A' object has no attribute 'name'\r# 也可以使用 a.__init__(), # 它会自动将实例作为第一个参数完成初始化 A.__init__(a) a \u003c__main__.A at 0x20d23e95d30\u003e\ra.name '实例'\r",
    "description": "",
    "tags": null,
    "title": "创建实例",
    "uri": "/python/16_class/11_create_instance/"
  },
  {
    "content": "内置函数 abs()，Python 官方文档描述如下：\nhelp(abs) Help on built-in function abs in module builtins:\rabs(x, /)\rReturn the absolute value of the argument.\r返回一个数的绝对值，参数可以是整数、浮点数或任何实现了 __abs__() 的对象。如果参数是一 个复数，则返回它的模。\nabs(-1) 1\rabs(-3.14) 3.14\rabs(3+4j) 5.0\rjupyter附件 01_abs.ipynb (2 KB) 02_all.ipynb (2 KB) 03_any.ipynb (2 KB) 04_ascii.ipynb (3 KB) 05_bin.ipynb (1 KB) 06_bool.ipynb (12 KB) 07_bytes.ipynb (20 KB) 08_callable.ipynb (3 KB) 09_chr.ipynb (3 KB) 10_classmethod.ipynb (4 KB) 11_compile.ipynb (3 KB) 12_complex.ipynb (8 KB) 13_delattr.ipynb (2 KB) 14_dict.ipynb (8 KB) 15_dir.ipynb (9 KB) 16_divmod.ipynb (2 KB) 17_enumerate.ipynb (4 KB) 18_eval.ipynb (4 KB) 19_exec.ipynb (4 KB) 20_filter.ipynb (4 KB) 21_float.ipynb (12 KB) 22_format.ipynb (3 KB) 23_frozenset.ipynb (6 KB) 24_getattr.ipynb (4 KB) 25_globals.ipynb (3 KB) 26_hasattr.ipynb (2 KB) 27_hash.ipynb (4 KB) 28_help.ipynb (6 KB) 29_hex.ipynb (1 KB) 30_id.ipynb (3 KB) 31_input.ipynb (2 KB) 32_int.ipynb (16 KB) 33_isinstance.ipynb (4 KB) 34_issubclass.ipynb (3 KB) 35_iter.ipynb (3 KB) 36_len.ipynb (2 KB) 37_list.ipynb (6 KB) 38_locals.ipynb (3 KB) 39_map.ipynb (4 KB) 40_max.ipynb (3 KB) 41_min.ipynb (3 KB) 42_next.ipynb (3 KB) 43_object.ipynb (2 KB) 44_oct.ipynb (2 KB) 45_open.ipynb (12 KB) 46_ord.ipynb (1 KB) 47_pow.ipynb (4 KB) 48_print.ipynb (3 KB) 49_property.ipynb (14 KB) 50_range.ipynb (5 KB) 51_repr.ipynb (3 KB) 52_reversed.ipynb (3 KB) 53_round.ipynb (4 KB) 54_set.ipynb (8 KB) 55_setattr.ipynb (3 KB) 56_slice.ipynb (5 KB) 57_sorted.ipynb (3 KB) 58_staticmethod.ipynb (4 KB) 59_str.ipynb (22 KB) 60_sum.ipynb (3 KB) 61_super.ipynb (7 KB) 62_tuple.ipynb (4 KB) 63_type.ipynb (7 KB) 64_vars.ipynb (4 KB) 65_zip.ipynb (4 KB) test.txt (26 B) ",
    "description": "",
    "tags": null,
    "title": "abs() 数字取绝对值",
    "uri": "/python/11_built-in_function/"
  },
  {
    "content": "内置函数（类）complex，Python 官方文档描述如下：\nhelp(complex) Help on class complex in module builtins:\rclass complex(object)\r| complex(real=0, imag=0)\r| | Create a complex number from a real part and an optional imaginary part.\r| | This is equivalent to (real + imag*1j) where imag defaults to 0.\r| | Methods defined here:\r| | __abs__(self, /)\r| abs(self)\r| | __add__(self, value, /)\r| Return self+value.\r| | __bool__(self, /)\r| self != 0\r| | __divmod__(self, value, /)\r| Return divmod(self, value).\r| | __eq__(self, value, /)\r| Return self==value.\r| | __float__(self, /)\r| float(self)\r| | __floordiv__(self, value, /)\r| Return self//value.\r| | __format__(...)\r| complex.__format__() -\u003e str\r| | Convert to a string according to format_spec.\r| | __ge__(self, value, /)\r| Return self\u003e=value.\r| | __getattribute__(self, name, /)\r| Return getattr(self, name).\r| | __getnewargs__(...)\r| | __gt__(self, value, /)\r| Return self\u003evalue.\r| | __hash__(self, /)\r| Return hash(self).\r| | __int__(self, /)\r| int(self)\r| | __le__(self, value, /)\r| Return self\u003c=value.\r| | __lt__(self, value, /)\r| Return self\u003cvalue.\r| | __mod__(self, value, /)\r| Return self%value.\r| | __mul__(self, value, /)\r| Return self*value.\r| | __ne__(self, value, /)\r| Return self!=value.\r| | __neg__(self, /)\r| -self\r| | __pos__(self, /)\r| +self\r| | __pow__(self, value, mod=None, /)\r| Return pow(self, value, mod).\r| | __radd__(self, value, /)\r| Return value+self.\r| | __rdivmod__(self, value, /)\r| Return divmod(value, self).\r| | __repr__(self, /)\r| Return repr(self).\r| | __rfloordiv__(self, value, /)\r| Return value//self.\r| | __rmod__(self, value, /)\r| Return value%self.\r| | __rmul__(self, value, /)\r| Return value*self.\r| | __rpow__(self, value, mod=None, /)\r| Return pow(value, self, mod).\r| | __rsub__(self, value, /)\r| Return value-self.\r| | __rtruediv__(self, value, /)\r| Return value/self.\r| | __sub__(self, value, /)\r| Return self-value.\r| | __truediv__(self, value, /)\r| Return self/value.\r| | conjugate(...)\r| complex.conjugate() -\u003e complex\r| | Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.\r| | ----------------------------------------------------------------------\r| Static methods defined here:\r| | __new__(*args, **kwargs) from builtins.type\r| Create and return a new object. See help(type) for accurate signature.\r| | ----------------------------------------------------------------------\r| Data descriptors defined here:\r| | imag\r| the imaginary part of a complex number\r| | real\r| the real part of a complex number\r返回值为 real + imag*1j 的复数，或将字符串或数字转换为复数。\n如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。 第二个形参不能是字符串。 每个实参都可以是任意的数值类型（包括复数）。 如果省略了 imag，则默认值为零，构造函数会像 int 和 float 一样进行数值转换。 如果两个实参都省略，则返回 0j。 当从字符串转换时，字符串在 + 或 - 的周围必须不能有空格。 type(complex) type\rcomplex('1') (1+0j)\rcomplex('1+2j') (1+2j)\rcomplex(1j, 2j) (-2+1j)\rcomplex(1j) 1j\rcomplex() 0j\rcomplex('1 + 2j') ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-7-fd0fa4b53d7c\u003e in \u003cmodule\u003e\r----\u003e 1 complex('1 + 2j')\rValueError: complex() arg is a malformed string\r",
    "description": "",
    "tags": null,
    "title": "complex 创建复数",
    "uri": "/python/11_built-in_function/12_complex/"
  },
  {
    "content": "字典方法 dict.update()，Python 官方文档描述如下：\nhelp(dict.update) Help on method_descriptor:\rupdate(...)\rD.update([E, ]**F) -\u003e None. Update D from dict/iterable E and F.\rIf E is present and has a .keys() method, then does: for k in E: D[k] = E[k]\rIf E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v\rIn either case, this is followed by: for k in F: D[k] = F[k]\r更新字典，键相同，则覆盖原有的值，不同，则增加 键值对 元素。有下列几种情况：\n以字典更新字典： d = {'a':1, 'b':2} d.update({'a':10, 'c':3}) d {'a': 10, 'b': 2, 'c': 3}\r以可迭代对象更新字典： d = {'a':1, 'b':2} d.update([('a',10),['c',3]]) d {'a': 10, 'b': 2, 'c': 3}\r以关键字参数更新字典： d = {'a':1, 'b':2} d.update(a=10, c=3) d {'a': 10, 'b': 2, 'c': 3}\r",
    "description": "",
    "tags": null,
    "title": "dict.update 更新字典",
    "uri": "/python/07_dictionary/12_dict.update/"
  },
  {
    "content": "列表方法 list.count()，Python 官方文档描述如下：\nhelp(list.count) Help on method_descriptor:\rcount(self, value, /)\rReturn number of occurrences of value.\r返回元素 value 在列表中出现的次数，没有出现为 0。\n_list = [1,2,3,1] _list.count(1), _list.count([1]) (2, 0)\r",
    "description": "",
    "tags": null,
    "title": "list.count 统计元素出现次数",
    "uri": "/python/03_list/12_list.count/"
  },
  {
    "content": "集合方法 set.difference_update()，Python 官方文档描述如下：\nhelp(set.difference_update) Help on method_descriptor:\rdifference_update(...)\rRemove all elements of another set from this set.\r该方法接收任意的位置参数，更新集合，移除在其他集合中也存在的元素。相当于 a -= b | …（a，b 是集合），但方法的参数可以是可迭代对象。\na = {1,2,3,4} a.difference_update((1,3,5),[4,5]) a {2}\ra = {1,2,3,4} a -= {1,3,5} | {4,5} a {2}\r该方法是一个过程，就地修改集合，返回值为 None。\na = {1,2,3,4} b = a.difference_update([4,5]) print(b) None\r",
    "description": "",
    "tags": null,
    "title": "set.difference_update 差集更新",
    "uri": "/python/06_set/12_set.difference_update/"
  },
  {
    "content": "字符串方法 str.strip()，Python 官方文档描述如下：\nhelp(str.strip) Help on method_descriptor:\rstrip(self, chars=None, /)\rReturn a copy of the string with leading and trailing whitespace remove.\rIf chars is given and not None, remove characters in chars instead.\r返回原字符串的副本，移除其中的前导和末尾字符。chars 参数为指定要移除字符的字符串。如果省略或为 None，则 chars 参数默认移除空格符。实际上 chars 参数并非指定单个前缀或后缀；而是会移除参数值中的所有字符:\n' python '.strip() 'python'\r' python '.strip('p') ' python '\r' python '.strip('p n') 'ytho'\r' pythonnnn '.strip('p n') 'ytho'\r",
    "description": "",
    "tags": null,
    "title": "str.strip 移除两边字符",
    "uri": "/python/02_string/12_str.strip/"
  },
  {
    "content": "yield 语句，仅在定义 生成器函数 时使用，并且仅被用于生成器函数的函数体内部。语法如下：\nyield from expression from 和表达式 expression 是可选的，没有表达式默认是 None。\nyield 语句整体也是一个可被求值的表达式语句，初始值也是默认 None，可通过 send 方法设置 yield 表达式的值。\n在函数定义中使用 yield 使得该定义创建的是生成器函数而非普通函数。当一个生成器函数被调用的时候，它返回一个生成器迭代器。\nyield from 相当于将一个可迭代对象 “拆包”，然后逐项被生成器迭代时使用。\n# 创建一个简单的生成器函数 def f(): yield print(f) # 调用它获得一个生成器 print(f()) # next() 函数迭代生成器获取表达式的值 print(next(f())) \u003cfunction f at 0x00000157028A9598\u003e\r\u003cgenerator object f at 0x000001570286CB88\u003e\rNone\r# 获取并设置 yield 语句的值 def f(n): x = yield n print(x) g = f(1) print(next(g)) # 迭代结束，打印出 yield 语句 x 的初始值为 None print(next(g,'end')) 1\rNone\rend\r# 可通过 send 方法设置当前 yield 表达式的值 # 并返回生成器产生的下一个值 def f(n): x = yield n print(f'yield 表达式的值为:{x}') n += 1 yield n g = f(0) next(g), g.send(10) yield 表达式的值为:10\r(0, 1)\rdef f(*args): yield from args g = f(1,2,3) next(g),next(g),next(g),next(g,'end') (1, 2, 3, 'end')\rdef f(arg): yield from arg g = f('123') next(g),next(g),next(g),next(g,'end') ('1', '2', '3', 'end')\r",
    "description": "",
    "tags": null,
    "title": "yield",
    "uri": "/python/10_statement/12_yield/"
  },
  {
    "content": "Python 是动态语言，对象的属性不仅可以查看、访问、调用，还可以动态地增、删、改。\n下面定义一个没有自定义属性的类 A 举例：\ndir() 函数查看属性，双下划线 __ 包围的属性是继承自 object 的特殊属性：\n# 定义一个类，查看属性 class A: pass dir(A) ['__class__',\r'__delattr__',\r'__dict__',\r'__dir__',\r'__doc__',\r'__eq__',\r'__format__',\r'__ge__',\r'__getattribute__',\r'__gt__',\r'__hash__',\r'__init__',\r'__init_subclass__',\r'__le__',\r'__lt__',\r'__module__',\r'__ne__',\r'__new__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__setattr__',\r'__sizeof__',\r'__str__',\r'__subclasshook__',\r'__weakref__']\r# 访问属性 __class__ 相当于调用 type() 函数 A.__class__, A().__class__ (type, __main__.A)\r给类 A 及其实例动态添加属性，属性可以是数据属性和方法。类层级添加的属性，将作为所有实例的属性；实例添加的属性，只有对应的实例能访问。\n# 添加数据属性 a1 = A() a2 = A() A.a = '类变量' a1.x = 'a1 的属性' a2.y = 'a2 的属性' # 类层级添加方法 def f(self): print(self.a) A.f = f # 类 A 调用刚添加的属性 A.f(a1) A.f(a2) 类变量\r类变量\r# 实例调用刚添加的属性 a1.f() a2.f() 类变量\r类变量\r# 实例 a1 没有 y 属性 # 同理，a2 没有 x 属性 a1.y ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-44-178a7ac627a0\u003e in \u003cmodule\u003e\r1 # 实例 a1 没有 y 属性\r2 # 同理，a2 没有 x 属性\r----\u003e 3 a1.y\rAttributeError: 'A' object has no attribute 'y'\r实例直接添加一个函数作为属性，将不会隐式地将自身作为第一个参数，而是和正常函数一样使用：\ndef p(self): print(self) a1.p = p a1.p('正常传参') a1.p() 正常传参\r---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-45-4ebdece61250\u003e in \u003cmodule\u003e\r4 a1.p = p\r5 a1.p('正常传参')\r----\u003e 6 a1.p()\rTypeError: p() missing 1 required positional argument: 'self'\r如果要通过实例添加实例方法（第一个参数 self 即是自身的方法），可以通过 types 模块添加。添加的属性，类不可访问，只有对应的实例可访问：\nfrom types import MethodType # 改变了 a1 的上述 p 属性 a1.p = MethodType(p, a1) a1.p() \u003c__main__.A object at 0x000001D40578D730\u003e\rA.p ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-47-94cb580acfb0\u003e in \u003cmodule\u003e\r----\u003e 1 A.p\rAttributeError: type object 'A' has no attribute 'p'\ra2.p ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-48-29321b2aa581\u003e in \u003cmodule\u003e\r----\u003e 1 a2.p\rAttributeError: 'A' object has no attribute 'p'\r删除属性使用 del 语句：\ndel a1.p a1.p() ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-49-9cf9b7e7dc86\u003e in \u003cmodule\u003e\r1 del a1.p\r2 ----\u003e 3 a1.p()\rAttributeError: 'A' object has no attribute 'p'\r",
    "description": "",
    "tags": null,
    "title": "属性操作",
    "uri": "/python/16_class/12_attribute_operation/"
  },
  {
    "content": "class 语句用来定义类，语法如下：\n@assignment_expression\rclass classname(argument_list):\rsuite 其中的装饰器 @assignment_expression，基类参数及圆括号 (argument_list) 是可选项。\n类定义是一条可执行语句。它执行时会将类名称 classname 绑定到一个新建的类对象。\n没有继承基类参数 argument_list 的类默认继承自基类 object。下列是一个必选参数定义的类，默认继承自 object:\n# 创建一个类名为 A 的类 class A: pass A.__bases__ # 查看基类 (object,)\r# 创建一个类 B 继承自 int 和 A class B(int, A): pass B.__bases__ (int, __main__.A)\r类也可以被装饰，就像装饰函数一样，装饰器表达式的求值规则与函数装饰器相同（详见 def 定义函数）。结果随后会被绑定到类名称。\n@str @type class C: pass C \"\u003cclass 'type'\u003e\"\r大致相当于：\nclass C: pass C = str(type(C)) C \"\u003cclass 'type'\u003e\"\r",
    "description": "",
    "tags": null,
    "title": "class 语句",
    "uri": "/python/10_statement/13_class/"
  },
  {
    "content": "内置函数 delattr()，Python 官方文档描述如下：\nhelp(delattr) Help on built-in function delattr in module builtins:\rdelattr(obj, name, /)\rDeletes the named attribute from the given object.\rdelattr(x, 'y') is equivalent to ``del x.y''\r实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。delattr(x, 'y') 等价于 del x.y。\nclass A: y = 0 x = A x.y 0\rdelattr(x,'y') x.y ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-12-3552434a3e61\u003e in \u003cmodule\u003e\r----\u003e 1 x.y\rAttributeError: type object 'A' has no attribute 'y'\r",
    "description": "",
    "tags": null,
    "title": "delattr() 删除对象属性",
    "uri": "/python/11_built-in_function/13_delattr/"
  },
  {
    "content": "列表方法 list.index()，Python 官方文档描述如下：\nhelp(list.index) Help on method_descriptor:\rindex(self, value, start=0, stop=9223372036854775807, /)\rReturn first index of value.\rRaises ValueError if the value is not present.\r返回列表中第一个值为 value 的元素从零开始的索引。如果没有这样的元素将会抛出 ValueError 异常。\n可选参数 start 和 stop 是切片符号，用于将搜索限制为列表的特定子序列。返回的是相对于整个序列开始计算的索引，而不是相对于 start 参数。\n_list = [1,2,3,4,3] _list.index(3) 2\r_list.index(3,1,4) 2\r_list.index(3,4,10) 4\r_list.index(3,5,10) ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-6-3e258cbffc85\u003e in \u003cmodule\u003e\r----\u003e 1 _list.index(3,5,10)\rValueError: 3 is not in list\r",
    "description": "",
    "tags": null,
    "title": "list.index 查找最小索引",
    "uri": "/python/03_list/13_list.index/"
  },
  {
    "content": "集合的对称差集更新操作，相当于集合方法 set.symmetric_difference_update，其文档描述如下：\nhelp(set.symmetric_difference_update) Help on method_descriptor:\rsymmetric_difference_update(...)\rUpdate a set with the symmetric difference of itself and another.\r更新集合，只保留两个集合中非共同部分。\na = {1,2,3} a.symmetric_difference_update([2,3,4]) a {1, 4}\ra = {1,2,3} a ^= {2,3,4} a {1, 4}\r该方法是一个过程，就地修改集合，返回值为 None。\na = {1,2,3} b = a.symmetric_difference_update([2,3,4]) print(b) None\r",
    "description": "",
    "tags": null,
    "title": "set ^= other 对称差集更新",
    "uri": "/python/06_set/13_set.symmetric_difference_update/"
  },
  {
    "content": "字符串方法 str.lstrip()，Python 官方文档描述如下：\nhelp(str.lstrip) Help on method_descriptor:\rlstrip(self, chars=None, /)\rReturn a copy of the string with leading whitespace removed.\rIf chars is given and not None, remove characters in chars instead.\r返回原字符串的副本，移除其中的前导字符。chars 参数为指定要移除字符的字符串。如果省略或为 None，则 chars 参数默认移除空格符。实际上 chars 参数并非指定单个前缀；而是会移除参数值中出现的所有字符:\n' python '.lstrip() 'python '\r' python '.lstrip('y p') 'thon '\r' python '.lstrip('py') ' python '\r'ppppython '.lstrip('y p') 'thon '\r",
    "description": "",
    "tags": null,
    "title": "str.lstrip 移除左边字符",
    "uri": "/python/02_string/13_str.lstrip/"
  },
  {
    "content": "一个从父类继承过来的方法，如果不满足子类的需求，可以进行重写，重写的方法将屏蔽父类的方法，但可以显示地调用，或使用 super() 委托给父类调用，实现父类、子类的方法都可调用。\nclass A: def f(self,x): y = x + x print(y) class B(A): def f(self,x): y = (x + x)**2 print(y) b = B() b.f(2) 16\r# 显示地调用 A.f(b, 2) 4\rclass A: def f(self,x): y = x + x print(y) class B(A): def f(self,x): super().f(x) y = (x + x)**2 print(y) b = B() b.f(2) 4\r16\r还可使用装饰器修改方法，或添加丰富功能等。\n# 将方法定义为静态方法 class C: @staticmethod def f(value): print(value) c = C() c.f('必须传参调用') 必须传参调用\r# 将私有属性定义为只读， # 直接用不带下划线的名称访问 class C: def __init__(self): self.__name = '私有属性' @property def name(self): return self.__name c = C() c.name '私有属性'\r# 尝试修改不被允许 c.name = 0 ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-11-c0f354f546f5\u003e in \u003cmodule\u003e\r1 # 尝试修改不被允许\r----\u003e 2 c.name = 0\rAttributeError: can't set attribute\r用特殊方法定制类：\nclass D: pass d = D() bool(d) True\r# 上述类的实例逻辑值检查为 True # 定义为 False class D: def __bool__(self): return False d = D() bool(d) False\r# 让数字字符串也可以相减 class Mystr(str): def __sub__(self, other): return str(float(self) - float(other)) m = Mystr('123') n = Mystr('3.14') m, n, m - n ('123', '3.14', '119.86')\r",
    "description": "",
    "tags": null,
    "title": "方法操作",
    "uri": "/python/16_class/13_method_operation/"
  },
  {
    "content": "函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。是可以向调用者返回某个值（至少是 None）的一组语句。\n函数使代码的组织模块化，提供了代码的利用率。例如 print() 函数实现打印功能，input() 函数实现输入功能，需要它们的地方，都可以使用。\n函数通过函数名称来使用它，传入零个或多个参数，并在函数体执行中被使用。\n# 函数 abs() 返回一个数的绝对值 a = abs(-3.14) a 3.14\r# print() 函数打印传入的参数值，返回 None n = print('hello, world') n is None hello, world\rTrue\r按照上述定义，类也被称作函数（例如内置函数 int，list 等）。\n我们通常所说的函数，是指使用 def 语句和 lambda 表达式定义的函数。\n而在类内部定义，使用属性表示法来调用的函数，我们习惯称作方法。\n# int 类实例化返回整数对象 int('1') 1\risinstance(1, int) True\r# list 类的方法 append 将一个对象加入列表中，返回值为 None a = [] b = list.append(a,'123') a, b is None (['123'], True)\r函数有内置函数和内置方法，用户也可以自定义函数和方法。定义了一个函数，即创建了一个函数对象，可以通过函数名和必要的参数调用它。\ndef my_sum(lst): '将列表中的字符串数字转为数字求和' # 函数文档说明 rlt = sum(map(float,lst)) # 调用内置函数求值 return rlt # 返回结果 my_sum(['1','3.14',2]) # 调用自定义函数 6.140000000000001\rjupyter附件 01_function_summary.ipynb (4 KB) 02_function_definition.ipynb (5 KB) 03_formal_parameter.ipynb (10 KB) 04_return_value.ipynb (4 KB) 05_recursion.ipynb (1 KB) 06_doc.ipynb (4 KB) 07_function_call.ipynb (7 KB) 08_lambda.ipynb (4 KB) 09_generator.ipynb (6 KB) ",
    "description": "",
    "tags": null,
    "title": "函数概述",
    "uri": "/python/12_function/"
  },
  {
    "content": "字典是可迭代对象，可以遍历字典的元素。由于字典元素是 键值对，遍历比较特殊。\n如果未指定遍历对象，默认遍历字典的键。很多函数将字典作为可迭代对象处理时，也是如此。\nd = {'a':1, 'c':3, 'b':2} for k in d: print(k) a\rc\rb\rlist(d) ['a', 'c', 'b']\rsorted(d) ['a', 'b', 'c']\rmax(d) 'c'\r可以利用字典的视图指定遍历字典的键（默认就是遍历键，可以省略），值 或是 键值对。\nd = {'a':1, 'c':3, 'b':2} for k in d.keys(): # 可以不用视图 print(k) a\rc\rb\rd = {'a':1, 'c':3, 'b':2} for k in d.values(): print(k) 1\r3\r2\rd = {'a':1, 'c':3, 'b':2} for k,v in d.items(): print(k,v) a 1\rc 3\rb 2\r# 按值排序后再遍历 d = {'a':1, 'c':3, 'b':2} for k,v in sorted(d.items(),key=lambda x:x[1]): print(k,v) a 1\rb 2\rc 3\r",
    "description": "",
    "tags": null,
    "title": "字典遍历",
    "uri": "/python/07_dictionary/13_loop_through/"
  },
  {
    "content": "内置函数（类）dict，Python 官方文档描述如下：\nhelp(dict) Help on class dict in module builtins:\rclass dict(object)\r| dict() -\u003e new empty dictionary\r| dict(mapping) -\u003e new dictionary initialized from a mapping object's\r| (key, value) pairs\r| dict(iterable) -\u003e new dictionary initialized as if via:\r| d = {}\r| for k, v in iterable:\r| d[k] = v\r| dict(**kwargs) -\u003e new dictionary initialized with the name=value pairs\r| in the keyword argument list. For example: dict(one=1, two=2)\r| 创建一个新字典。参数说明：\n不传参数创建空字典； 传递一个映射对象； 传递一个可迭代对象； 传递关键字参数。 type(dict) type\rdict() {}\rdict({'a':1}) {'a': 1}\rd = zip('abc',[1,2,3]) dict(d) {'a': 1, 'b': 2, 'c': 3}\rdict([('a', 1), ('b', 2)]) {'a': 1, 'b': 2}\rdict(a=1,b=2) {'a': 1, 'b': 2}\r",
    "description": "",
    "tags": null,
    "title": "dict 创建字典",
    "uri": "/python/11_built-in_function/14_dict/"
  },
  {
    "content": "列表方法 list.copy()，Python 官方文档描述如下：\nhelp(list.copy) Help on method_descriptor:\rcopy(self, /)\rReturn a shallow copy of the list.\r返回列表的一个浅拷贝。相当于 a[:]（a 是一个列表）。浅拷贝得到新的列表，列表中有可变对象时，浅拷贝中的可变对象元素，是原列表中同一个对象的多次引用。\nlist_1 = [[1],2,3] list_2 = list_1.copy() print(list_2) id(list_1),id(list_2) [[1], 2, 3]\r(2622792783240, 2622792782728)\r# 同一个对象 id(list_1[0]), id(list_2[0]) (2622792782792, 2622792782792)\r改变其中一个都会跟着改变：\nlist_1[0][:] = 'abc' list_1, list_2 ([['a', 'b', 'c'], 2, 3], [['a', 'b', 'c'], 2, 3])\r",
    "description": "",
    "tags": null,
    "title": "list.copy 列表的一个浅拷贝",
    "uri": "/python/03_list/14_list.copy/"
  },
  {
    "content": "集合方法 set.add()，Python 官方文档描述如下：\nhelp(set.add) Help on method_descriptor:\radd(...)\rAdd an element to a set.\rThis has no effect if the element is already present.\r集合中增加一个元素，如果元素已经存在，没有任何影响。\na = {1,2} a.add(3) a {1, 2, 3}\ra = {1,2} a.add(1) a {1, 2}\r该方法是一个过程，就地修改集合，返回值为 None。\na = {1,2} b = a.add(3) print(b) None\r",
    "description": "",
    "tags": null,
    "title": "set.add 添加元素",
    "uri": "/python/06_set/14_set.add/"
  },
  {
    "content": "字符串方法 str.rstrip()，Python 官方文档描述如下：\nhelp(str.rstrip) Help on method_descriptor:\rrstrip(self, chars=None, /)\rReturn a copy of the string with trailing whitespace removed.\rIf chars is given and not None, remove characters in chars instead.\r返回原字符串的副本，移除其中的末尾字符。chars 参数为指定要移除字符的字符串。如果省略或为 None，则 chars 参数默认移除空格符。实际上 chars 参数并非指定单个后缀；而是会移除参数值中的所有字符串:\n' python '.rstrip() ' python'\r' python '.rstrip('n o') ' pyth'\r' python '.rstrip('n') ' python '\r' pythonnnnn'.rstrip('no') ' pyth'\r",
    "description": "",
    "tags": null,
    "title": "str.rstrip 移除右边字符",
    "uri": "/python/02_string/14_str.rstrip/"
  },
  {
    "content": "try 语句可为一组语句指定异常处理器和/或清理代码。语法结构有两种如下。\n有 try 和 except 子句（可多个），以及可选的 else 和 finally 子句： try:\rsuite\rexcept expression as identifier:\rsuite\relse: # 可选\rsuite\rfinally: # 可选\rsuite 只有 try 和 finally 子句： try:\rsuite\rfinally:\rsuite except 子句之后的表达式（通常为异常）expression，关键字 as 以及指定的别名 identifier 都是可选的。\n当 try 子句中没有发生异常时，没有异常处理器会被执行。当 try 子句中发生异常时，将启动对异常处理器的搜索。此搜索会依次检查 except 子句，直至找到与该异常相匹配的子句。\nexcept 子句可指定一个或多个异常，如果与发生的异常 “兼容” 则该子句将匹配该异常。\n指定的异常如果是发生的异常所属的类或基类，则该子句将匹配该异常； 指定的异常可以置于一个元组，其中包含有与发生的异常 “兼容” 的异常，该子句将匹配该异常。 当一个异常完全未被处理时，解释器会终止程序的执行。\nfor i in range(3): try: print(3/i) except (ZeroDivisionError, AssertionError) as e: print(e) division by zero\r3.0\r1.5\rfor i in range(3): try: print(3/i) except ZeroDivisionError: print(f'i={i}引发异常') i=0引发异常\r3.0\r1.5\rfor i in range(3): print(3/i) ---------------------------------------------------------------------------\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-5-ddbcfc1a1b1b\u003e in \u003cmodule\u003e\r1 for i in range(3):\r----\u003e 2 print(3/i)\rZeroDivisionError: division by zero\r如果存在无表达式的 except 子句，它必须是最后一个，它将匹配任何异常：\ntry: 3/0 except NameError as n: print(n) except: pass 如果没有 except 子句与异常相匹配，则会在周边代码和发起调用栈上继续搜索异常处理器，除非存在一个finally 子句正好引发了另一个异常。新引发的异常将导致旧异常的丢失:\ndef f(): try: return 3/0 except NameError as n: print(n) try: f() except ZeroDivisionError as z: print(z) division by zero\rdef f(): try: return 3/0 except NameError as n: print(n) finally: name1 try: f() except ZeroDivisionError as z: # 该异常已丢失 print(z) except NameError as n: print(n) name 'name1' is not defined\r使用 as 将匹配的异常赋值给一个别名，才能在 except 子句之后引用它，并且它将在 except 子句结束时被清除：\nfor i in range(3): try: print(3/i) except (ZeroDivisionError, AssertionError) as e: print(e) print(e) division by zero\r3.0\r1.5\r---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-16-a87e190baccb\u003e in \u003cmodule\u003e\r4 except (ZeroDivisionError, AssertionError) as e:\r5 print(e)\r----\u003e 6 print(e)\rNameError: name 'e' is not defined\r如果控制流离开 try 子句体时没有引发异常，并且没有执行 return, continue 或 break 语句，可选的 else 子句将被执行:\ntry: print('开始') except: print('捕获') else: print('结束') 开始\r结束\rwhile True: try: print('开始') break except: print('捕获') else: print('结束') 开始\r如果存在 finally，它用来指定一个 “清理” 处理程序。try，except 或 else 子句中发生任何未处理的异常，会被临时保存。finally 始终被执行，被保存的异常，它会在 finally 子句执行后被重新引发：\ntry: print(3/0) except: name2 else: # 未被执行 range(3)[5] finally: print('end') end\r---------------------------------------------------------------------------\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-24-7d6fe0d94043\u003e in \u003cmodule\u003e\r1 try:\r----\u003e 2 print(3/0)\r3 except:\rZeroDivisionError: division by zero\rDuring handling of the above exception, another exception occurred:\rNameError Traceback (most recent call last)\r\u003cipython-input-24-7d6fe0d94043\u003e in \u003cmodule\u003e\r2 print(3/0)\r3 except:\r----\u003e 4 name2\r5 else: # 未被执行\r6 range(3)[5]\rNameError: name 'name2' is not defined\r如果 finally 子句引发了另一个异常，被保存的异常会被设为新异常的上下文。如果 finally 子句执行了 return, break 或 continue 语句，则被保存的异常会被丢弃:\nwhile True: try: print('开始') except: print('捕获') else: range(3)[5] finally: print(3/0) 开始\r---------------------------------------------------------------------------\rIndexError Traceback (most recent call last)\r\u003cipython-input-25-1f272bfbd667\u003e in \u003cmodule\u003e\r6 else:\r----\u003e 7 range(3)[5]\r8 finally:\rIndexError: range object index out of range\rDuring handling of the above exception, another exception occurred:\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-25-1f272bfbd667\u003e in \u003cmodule\u003e\r7 range(3)[5]\r8 finally:\r----\u003e 9 print(3/0)\rZeroDivisionError: division by zero\rwhile True: try: print('开始') except: print('捕获') else: range(3)[5] finally: break 开始\r当 return, break 或 continue 语句在 finally 语句之前被执行时，finally 子语句也会 ‘在离开时’ 被执行:\nwhile True: try: print('开始') except: print('捕获') else: break finally: print('结束') 开始\r结束\rdef f(): try: return '开始' finally: print('结束') f() # 先执行 finally 再离开函数调用 结束\r'开始'\r",
    "description": "",
    "tags": null,
    "title": "try",
    "uri": "/python/10_statement/14_try/"
  },
  {
    "content": "异常中断代码块的正常控制流程以便处理 错误 或 其他异常条件 。它是 Python 中的一类对象。一个异常表示一个或一类错误。\n异常会在错误被检测到的位置引发，它可以被 当前包围发生错误的代码块 或是 任何直接或间接调用发生错误的代码块的其他代码块 所处理。\nPython 解析器会在检测到代码运行错误的时候引发异常。也可以通过 raise 语句显式地引发异常。\n异常处理通过 try 语句 来指定。该语句的 finally 子句可被用来指定清理代码，它并不处理异常，而是无论之前的代码是否发生异常都会被执行。\nPython 的错误处理采用的是 “终止” 模型：异常处理器可以找出发生了什么问题，并在外层继续执行，但它不能修复错误的根源并重试失败的操作（除非通过从顶层重新进入出错的代码片段）。\n当一个异常完全未被处理时，解释器会终止程序的执行，或者返回交互模式。无论是哪种情况，它都会打印栈回溯信息，除非是当异常为 SystemExit 的时候。\n异常是通过类实例来标识的。except 子句必须引用实例的类或是其所属的基类。实例可通过处理器被接收，并可携带有关异常条件的附加信息。\n在 Python 中，所有异常必须为一个派生自 BaseException 的类的实例。\n内置异常类可以被子类化以定义新的异常。鼓励从 Exception 类或它的某个子类而不是从 BaseException 来派生新的异常。\n内置异常的类层级结构如下：\nBaseException\r+-- SystemExit\r+-- KeyboardInterrupt\r+-- GeneratorExit\r+-- Exception\r+-- StopIteration\r+-- StopAsyncIteration\r+-- ArithmeticError\r| +-- FloatingPointError\r| +-- OverflowError\r| +-- ZeroDivisionError\r+-- AssertionError\r+-- AttributeError\r+-- BufferError\r+-- EOFError\r+-- ImportError\r| +-- ModuleNotFoundError\r+-- LookupError\r| +-- IndexError\r| +-- KeyError\r+-- MemoryError\r+-- NameError\r| +-- UnboundLocalError\r+-- OSError\r| +-- BlockingIOError\r| +-- ChildProcessError\r| +-- ConnectionError\r| | +-- BrokenPipeError\r| | +-- ConnectionAbortedError\r| | +-- ConnectionRefusedError\r| | +-- ConnectionResetError\r| +-- FileExistsError\r| +-- FileNotFoundError\r| +-- InterruptedError\r| +-- IsADirectoryError\r| +-- NotADirectoryError\r| +-- PermissionError\r| +-- ProcessLookupError\r| +-- TimeoutError\r+-- ReferenceError\r+-- RuntimeError\r| +-- NotImplementedError\r| +-- RecursionError\r+-- SyntaxError\r| +-- IndentationError\r| +-- TabError\r+-- SystemError\r+-- TypeError\r+-- ValueError\r| +-- UnicodeError\r| +-- UnicodeDecodeError\r| +-- UnicodeEncodeError\r| +-- UnicodeTranslateError\r+-- Warning\r+-- DeprecationWarning\r+-- PendingDeprecationWarning\r+-- RuntimeWarning\r+-- SyntaxWarning\r+-- UserWarning\r+-- FutureWarning\r+-- ImportWarning\r+-- UnicodeWarning\r+-- BytesWarning\r+-- ResourceWarning jupyter附件 01_ex_summary.ipynb (4 KB) 02_handling.ipynb (7 KB) 03_raising.ipynb (3 KB) 04_user_defined.ipynb (3 KB) 05_finally.ipynb (5 KB) ",
    "description": "",
    "tags": null,
    "title": "错误和异常",
    "uri": "/python/13_exception/"
  },
  {
    "content": "字典不可以使用比较大小的操作符 \u003c, \u003c=, \u003e= 和 \u003e，会引发 TypeError。\n{1:1} \u003c {2:2} ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-1-8ea82599b938\u003e in \u003cmodule\u003e\r----\u003e 1 {1:1} \u003c {2:2}\rTypeError: '\u003c' not supported between instances of 'dict' and 'dict'\r字典比较相等时，当且仅当 键值对 都相等时才相等。\n{1:1.0, 2:2} == {2:2, True:1} True\r{1:'1', 2:2} == {2:2, 1:1} False\r字典可以使用 ** 操作符进行拆包，拆包后置于新字典中，可以用来更新字典；或拆包后作为关键字参数传递给函数。\n{'a':1, 'b':2, **{'a':10}} {'a': 10, 'b': 2}\rd = {'a':1, 'b':2} 'a={a},b={b}'.format(**d) 'a=1,b=2'\rPython 3.9 新版，实现了两个操作符 | 和 |=：\n{'a':1} | {'b':2} {'a': 1, 'b': 2}\r合并 d 和 other 中的键和值来创建一个新的字典，两者必须都是字典。当 d 和 other 有相同键时，other 的值优先。\n{'a':1} | {'a':5, 'b':2} {'a': 5, 'b': 2}\r用 other 的键和值更新字典 d ，other 可以是映射（mapping）或可迭代对象（iterable）的键值对。当 d 和 other 有相同键时，other 的值优先。\n",
    "description": "",
    "tags": null,
    "title": "字典操作符",
    "uri": "/python/07_dictionary/14_operator/"
  },
  {
    "content": "内置函数 dir()，Python 官方文档描述如下：\nhelp(dir) Help on built-in function dir in module builtins:\rdir(...)\rdir([object]) -\u003e list of strings\rIf called without an argument, return the names in the current scope.\rElse, return an alphabetized list of names comprising (some of) the attributes\rof the given object, and of attributes reachable from it.\rIf the object supplies a method named __dir__, it will be used; otherwise\rthe default dir() logic is used and returns:\rfor a module object: the module's attributes.\rfor a class object: its attributes, and recursively the attributes\rof its bases.\rfor any other object: its attributes, its class's attributes, and\rrecursively the attributes of its class's base classes.\r如果没有实参，则返回当前作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。\ndir() ['In',\r'Out',\r'_',\r'__',\r'___',\r'__builtin__',\r'__builtins__',\r'__doc__',\r'__loader__',\r'__name__',\r'__package__',\r'__spec__',\r'_dh',\r'_i',\r'_i1',\r'_i2',\r'_ih',\r'_ii',\r'_iii',\r'_oh',\r'exit',\r'get_ipython',\r'quit']\r如果对象有一个名为 __dir__() 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 dir() 来报告它的属性。\nclass A: def __dir__(self): return ['area', 'perimeter', 'location'] a = A() dir(a) ['area', 'location', 'perimeter']\r如果对象不提供 __dir__()，默认的 dir() 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：\n如果对象是模块对象，则列表包含模块的属性名称; 如果对象是类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性; 如果对象是实例对象，则列表包含实例的属性名称，它的类的属性名称，并且递归查找它的类的所有基类的属性。 import string dir(string) ['Formatter',\r'Template',\r'_ChainMap',\r'_TemplateMetaclass',\r'__all__',\r'__builtins__',\r'__cached__',\r'__doc__',\r'__file__',\r'__loader__',\r'__name__',\r'__package__',\r'__spec__',\r'_re',\r'_string',\r'ascii_letters',\r'ascii_lowercase',\r'ascii_uppercase',\r'capwords',\r'digits',\r'hexdigits',\r'octdigits',\r'printable',\r'punctuation',\r'whitespace']\rdir(int) ['__abs__',\r'__add__',\r'__and__',\r'__bool__',\r'__ceil__',\r'__class__',\r'__delattr__',\r'__dir__',\r'__divmod__',\r'__doc__',\r'__eq__',\r'__float__',\r'__floor__',\r'__floordiv__',\r'__format__',\r'__ge__',\r'__getattribute__',\r'__getnewargs__',\r'__gt__',\r'__hash__',\r'__index__',\r'__init__',\r'__init_subclass__',\r'__int__',\r'__invert__',\r'__le__',\r'__lshift__',\r'__lt__',\r'__mod__',\r'__mul__',\r'__ne__',\r'__neg__',\r'__new__',\r'__or__',\r'__pos__',\r'__pow__',\r'__radd__',\r'__rand__',\r'__rdivmod__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__rfloordiv__',\r'__rlshift__',\r'__rmod__',\r'__rmul__',\r'__ror__',\r'__round__',\r'__rpow__',\r'__rrshift__',\r'__rshift__',\r'__rsub__',\r'__rtruediv__',\r'__rxor__',\r'__setattr__',\r'__sizeof__',\r'__str__',\r'__sub__',\r'__subclasshook__',\r'__truediv__',\r'__trunc__',\r'__xor__',\r'bit_length',\r'conjugate',\r'denominator',\r'from_bytes',\r'imag',\r'numerator',\r'real',\r'to_bytes']\rdir(1) ['__abs__',\r'__add__',\r'__and__',\r'__bool__',\r'__ceil__',\r'__class__',\r'__delattr__',\r'__dir__',\r'__divmod__',\r'__doc__',\r'__eq__',\r'__float__',\r'__floor__',\r'__floordiv__',\r'__format__',\r'__ge__',\r'__getattribute__',\r'__getnewargs__',\r'__gt__',\r'__hash__',\r'__index__',\r'__init__',\r'__init_subclass__',\r'__int__',\r'__invert__',\r'__le__',\r'__lshift__',\r'__lt__',\r'__mod__',\r'__mul__',\r'__ne__',\r'__neg__',\r'__new__',\r'__or__',\r'__pos__',\r'__pow__',\r'__radd__',\r'__rand__',\r'__rdivmod__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__rfloordiv__',\r'__rlshift__',\r'__rmod__',\r'__rmul__',\r'__ror__',\r'__round__',\r'__rpow__',\r'__rrshift__',\r'__rshift__',\r'__rsub__',\r'__rtruediv__',\r'__rxor__',\r'__setattr__',\r'__sizeof__',\r'__str__',\r'__sub__',\r'__subclasshook__',\r'__truediv__',\r'__trunc__',\r'__xor__',\r'bit_length',\r'conjugate',\r'denominator',\r'from_bytes',\r'imag',\r'numerator',\r'real',\r'to_bytes']\r",
    "description": "",
    "tags": null,
    "title": "dir() 返回对象属性列表",
    "uri": "/python/11_built-in_function/15_dir/"
  },
  {
    "content": "raise 语句用来引发异常。语法如下：\nraise expression from expression 如果不带表达式，raise 会重新引发当前作用域内最后一个激活的异常。如果当前作用域内没有激活的异常，将会引发 RuntimeError 来提示错误。\nraise ---------------------------------------------------------------------------\rRuntimeError Traceback (most recent call last)\r\u003cipython-input-1-9c9a2cba73bf\u003e in \u003cmodule\u003e\r----\u003e 1 raise\rRuntimeError: No active exception to reraise\rraise 会将第一个表达式求值为异常对象。它必须为 BaseException 的子类或实例。如果它是一个类，当需要时会通过不带参数地实例化该类来获得异常的实例。\ntype(ZeroDivisionError) type\rraise ZeroDivisionError # 无提示信息 ---------------------------------------------------------------------------\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-2-798b08d1683c\u003e in \u003cmodule\u003e\r----\u003e 1 raise ZeroDivisionError # 无提示信息\rZeroDivisionError: raise ZeroDivisionError('分母不能为 0') # 自定义提示信息 ---------------------------------------------------------------------------\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-17-950b4accf1f2\u003e in \u003cmodule\u003e\r----\u003e 1 raise ZeroDivisionError('分母不能为 0') # 自定义提示信息\rZeroDivisionError: 分母不能为 0\rfrom 子句用于异常串连：如果有该子句，则第二个表达式必须为另一个异常类或实例，它将被关联到所引发的异常:\nraise IndexError(\"索引错误\") from NameError('名称错误') ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\rNameError: 名称错误\rThe above exception was the direct cause of the following exception:\rIndexError Traceback (most recent call last)\r\u003cipython-input-18-124f83b49e6f\u003e in \u003cmodule\u003e\r----\u003e 1 raise IndexError(\"索引错误\") from NameError('名称错误')\rIndexError: 索引错误\rtry: print(1 / 0) except Exception as e: raise RuntimeError(\"Something bad happened\") from e ---------------------------------------------------------------------------\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-13-83aaca0b7e7f\u003e in \u003cmodule\u003e\r1 try:\r----\u003e 2 print(1 / 0)\r3 except Exception as e:\rZeroDivisionError: division by zero\rThe above exception was the direct cause of the following exception:\rRuntimeError Traceback (most recent call last)\r\u003cipython-input-13-83aaca0b7e7f\u003e in \u003cmodule\u003e\r2 print(1 / 0)\r3 except Exception as e:\r----\u003e 4 raise RuntimeError(\"Something bad happened\") from e\rRuntimeError: Something bad happened\r如果一个异常在异常处理器或 finally 中被引发，类似的机制会隐式地发挥作用：\ntry: print(1 / 0) except: raise RuntimeError(\"Something bad happened\") ---------------------------------------------------------------------------\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-16-5576c5c08e42\u003e in \u003cmodule\u003e\r1 try:\r----\u003e 2 print(1 / 0)\r3 except:\rZeroDivisionError: division by zero\rDuring handling of the above exception, another exception occurred:\rRuntimeError Traceback (most recent call last)\r\u003cipython-input-16-5576c5c08e42\u003e in \u003cmodule\u003e\r2 print(1 / 0)\r3 except:\r----\u003e 4 raise RuntimeError(\"Something bad happened\")\rRuntimeError: Something bad happened\rtry: print(1 / 0) finally: raise RuntimeError(\"Something bad happened\") ---------------------------------------------------------------------------\rZeroDivisionError Traceback (most recent call last)\r\u003cipython-input-15-8b172672db5a\u003e in \u003cmodule\u003e\r1 try:\r----\u003e 2 print(1 / 0)\r3 finally:\rZeroDivisionError: division by zero\rDuring handling of the above exception, another exception occurred:\rRuntimeError Traceback (most recent call last)\r\u003cipython-input-15-8b172672db5a\u003e in \u003cmodule\u003e\r2 print(1 / 0)\r3 finally:\r----\u003e 4 raise RuntimeError(\"Something bad happened\")\rRuntimeError: Something bad happened\r",
    "description": "",
    "tags": null,
    "title": "raise",
    "uri": "/python/10_statement/15_raise/"
  },
  {
    "content": "集合方法 set.remove()，Python 官方文档描述如下：\nhelp(set.remove) Help on method_descriptor:\rremove(...)\rRemove an element from a set; it must be a member.\rIf the element is not a member, raise a KeyError.\r删除一个指定元素，删除元素不存在则引发 KeyError。\na = {1,2} a.remove(1) a {2}\ra = {1,2} a.remove(3) a ---------------------------------------------------------------------------\rKeyError Traceback (most recent call last)\r\u003cipython-input-3-d0f57d460301\u003e in \u003cmodule\u003e\r1 a = {1,2}\r----\u003e 2 a.remove(3)\r3 a\rKeyError: 3\r该方法是一个过程，就地修改集合，返回值为 None。\na = {1,2} b = a.remove(1) print(b) None\r",
    "description": "",
    "tags": null,
    "title": "set.remove 删除元素",
    "uri": "/python/06_set/15_set.remove/"
  },
  {
    "content": "字符串方法 str.find()，Python 官方文档描述如下：\nhelp(str.find) Help on method_descriptor:\rfind(...)\rS.find(sub[, start[, end]]) -\u003e int\rReturn the lowest index in S where substring sub is found,\rsuch that sub is contained within S[start:end]. Optional\rarguments start and end are interpreted as in slice notation.\rReturn -1 on failure.\r返回子字符串 sub 在 s[start:end] 切片内被找到的最小索引。可选参数 start 与 end 会被解读为切片表示法。如果 sub 未被找到则返回 -1。\n只给定 sub 一个参数的话，于是从第一个字符开始搜索到字符串结束；如果，随后给定了一个可选参数的话，那么它是 start，于是从 start 开始，搜索到字符串结束；如果 start 之后还有参数的话，那么它是 end；于是从 start 开始，搜索到 end - 1 结束（即不包含索引值为 end 的那个字符）。\n'pythonpython'.find('y') 1\r'pythonpython'.find('pt') -1\r'pythonpython'.find('y',5) 7\r'pythonpython'.find('y',5,7) -1\r",
    "description": "",
    "tags": null,
    "title": "str.find 查找最小索引",
    "uri": "/python/02_string/15_str.find/"
  },
  {
    "content": "所有的类都继承自 object。被继承的类称为基类（或父类，超类），继承者称为子类。\n对于多数应用来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。\nclass A(): def show(self): print('A') class B(A): pass class C(): pass class D(): def show(self): print('D') class E(C, B, D): # C -\u003e B -\u003e A -\u003e D pass e = E() e.show() A\r真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 super() 的协同调用。这种方式在某些其他多重继承型语言中被称为 后续方法调用，它比单继承型语言中的 super 调用更强大。\n动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。例如，所有类都是继承自 object，因此任何多重继承的情况都提供了一条以上的路径可以通向 object。为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化，保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。\n总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。\n一个基类如果有 __init__() 方法，则其所派生的类如果也有 __init__() 方法，就必须显式地调用它以确保实例基类部分的正确初始化：\nclass A: def __init__(self): self.a = 'A' def f(self): print(self.a) class B(A): def __init__(self): self.b = 'B' b = B() b.f() # 基类未初始化，属性 a 不可调用 ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-5-cda60db4451f\u003e in \u003cmodule\u003e\r11 12 b = B()\r---\u003e 13 b.f()\r\u003cipython-input-5-cda60db4451f\u003e in f(self)\r4 5 def f(self):\r----\u003e 6 print(self.a)\r7 8 class B(A):\rAttributeError: 'B' object has no attribute 'a'\rA.__init__(b) # 将实例 b 传给 A 初始化 b.f() A\r# 或者直接用 super() class A: def __init__(self): self.a = 'A' def f(self): print(self.a) class B(A): def __init__(self): super().__init__() self.b = 'B' b = B() b.f() A\r",
    "description": "",
    "tags": null,
    "title": "类继承",
    "uri": "/python/16_class/14_inheritance/"
  },
  {
    "content": "文件对象是指对外提供面向文件 API 以使用下层资源的对象（带有 read() 或 write() 这样的方法），也被称作流或文件类对象。\n有三种类别的文件对象: 原始二进制文件, 缓冲二进制文件 以及 文本文件。三种类别下还有子类别，因创建方式的不同得到不同类别文件对象。它们的接口定义均在 io 模块中。创建文件对象的规范方式是使用 open() 函数。\n用户代码直接操作原始流的用法非常罕见。不过，可以通过在禁用缓冲的情况下以二进制模式打开文件来创建原始流：\nf = open(\"test.txt\",\"rb\", buffering=0) f \u003c_io.FileIO name='test.txt' mode='rb' closefd=True\u003e\r缓冲二进制流不执行编码、解码或换行转换。这种类型的流可以用于所有类型的非文本数据（例如图片，视频），并且还可以在需要手动控制文本数据的处理时使用。创建缓冲二进制流的最简单方法是使用 open()，并在模式中指定 ‘b’：\nf = open(\"test.txt\",\"rb\") f \u003c_io.BufferedReader name='test.txt'\u003e\r文本流生成 str 对象。这意味着，无论何时后台存储是由字节组成的，数据的编码和解码都是透明的，并且可以选择转换特定于平台的换行符。创建文本流的最简单方法是使用 open()，可以选择指定编码：\nf = open(\"test.txt\",encoding=\"utf-8\") f \u003c_io.TextIOWrapper name='test.txt' mode='r' encoding='utf-8'\u003e\r所有流对提供给它们的数据类型都很敏感。例如将 str 对象给二进制流的 write() 方法会引发 TypeError。\nf = open(\"test.txt\",\"ab\") f.write('写入内容') ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-19-a9efd264aca2\u003e in \u003cmodule\u003e\r1 f = open(\"test.txt\",\"ab\")\r----\u003e 2 f.write('写入内容')\rTypeError: a bytes-like object is required, not 'str'\r内存中的流也可以作为文件对象使用：\nimport io f = io.StringIO(\"some initial text data\") print(f) f.read() \u003c_io.StringIO object at 0x000001BE348D2040\u003e\r'some initial text data'\rf = io.BytesIO(b\"some initial binary data: \\x00\\x01\") print(f) f.read() \u003c_io.BytesIO object at 0x000001BE348D3310\u003e\rb'some initial binary data: \\x00\\x01'\ropen() 函数打开文件，创建流后，会使文件在一段不确定的时间内处于打开状态。这在简单脚本中不是问题，但对于较大的应用程序来说可能是个问题。此时用 close() 方法刷新并关闭流（或直接使用 with 语句打开）是明智的做法。\nf = open(\"test.txt\",encoding=\"utf-8\") print(f.read()) f.close() 为什么要掌握自学能力？\r未来还很长。\rjupyter附件 01_file_summary.ipynb (6 KB) 02_read.ipynb (8 KB) 03_write.ipynb (6 KB) test.txt (137 B) ",
    "description": "",
    "tags": null,
    "title": "文件对象概述",
    "uri": "/python/14_file/"
  },
  {
    "content": "内置函数 divmod()，Python 官方文档描述如下：\nhelp(divmod) Help on built-in function divmod in module builtins:\rdivmod(x, y, /)\rReturn the tuple (x//y, x%y). Invariant: div*y + mod == x.\r它将两个（非复数）数字作为实参，返回两个数字的（商,余数）元组。对于混合操作数类型，适用二元算术运算符的规则。\ndivmod(1,2) (0, 1)\rdivmod(3.14, 2) (1.0, 1.1400000000000001)\r",
    "description": "",
    "tags": null,
    "title": "divmod() 求两个数的商和余",
    "uri": "/python/11_built-in_function/16_divmod/"
  },
  {
    "content": "集合方法 set.discard()，Python 官方文档描述如下：\nhelp(set.discard) Help on method_descriptor:\rdiscard(...)\rRemove an element from a set if it is a member.\rIf the element is not a member, do nothing.\r从集合中删除一个指定元素，元素不存在没有任何影响。\na = {1,2} a.discard(1) a {2}\ra = {1,2} a.discard(3) a {1, 2}\r该方法是一个过程，就地修改集合，返回值为 None。\na = {1,2} b = a.discard(1) print(b) None\r",
    "description": "",
    "tags": null,
    "title": "set.discard 删除元素",
    "uri": "/python/06_set/16_set.discard/"
  },
  {
    "content": "字符串方法 str.rfind()，Python 官方文档描述如下：\nhelp(str.rfind) Help on method_descriptor:\rrfind(...)\rS.rfind(sub[, start[, end]]) -\u003e int\rReturn the highest index in S where substring sub is found,\rsuch that sub is contained within S[start:end]. Optional\rarguments start and end are interpreted as in slice notation.\rReturn -1 on failure.\r返回子字符串 sub 在字符串内被找到的最大（最右）索引，这样 sub 将包含在 s[start:end] 当中。可选参数 start 与 end 会被解读为切片表示法。如果未找到则返回 -1。\n只给定 sub 一个参数的话，于是从第一个字符开始搜索到字符串结束；如果，随后给定了一个可选参数的话，那么它是 start，于是从 start 开始，搜索到字符串结束；如果 start 之后还有参数的话，那么它是 end；于是从 start 开始，搜索到 end - 1 结束（即不包含索引值为 end 的那个字符）。\n'python python'.rfind('on') 11\r'python python'.rfind('on',1,7) 4\r'python python'.rfind('on',7) 11\r'python python'.rfind('no') -1\r",
    "description": "",
    "tags": null,
    "title": "str.rfind 查找最大索引",
    "uri": "/python/02_string/16_str.rfind/"
  },
  {
    "content": "with 语句用于包装代码块的执行，代码块带有使用上下文管理器定义的函数或方法。语法如下：\nwith expression as target, expression as target, ...:\rsuite 带有一个表达式 expression 的 with 语句的执行过程如下:\n对上下文表达式求值以获得一个上下文管理器。 载入上下文管理器的 __enter__() 以便后续使用。 载入上下文管理器的 __exit__() 以便后续使用。 发起调用上下文管理器的 __enter__() 方法。 如果 with 语句中包含目标 target，来自 __enter__() 的返回值将被赋值给它。 执行语句体。 发起调用上下文管理器的 __exit__() 方法。 with 语句会保证如果 __enter__() 方法返回时未发生错误，则 __exit__() 将总是被调用。因此，如果在对目标赋值期间发生错误，则会将其视为在语句体内部发生的错误。\n如果语句体的退出是由异常导致的，则其类型、值和回溯信息将被作为参数传递给 __exit__()。否则的话，将提供三个 None 参数（相当于无异常地退出）。\n如果语句体的退出是由异常导致的，并且来自 __exit__() 方法的返回值为真，则该异常会被抑制，并会继续执行 with 语句之后的语句。如果返回值为假，则该异常会被重新引发（__exit__() 方法不应该重新引发被传入的异常，这是调用者的责任）。\n如果语句体由于异常以外的任何原因退出，则来自 __exit__() 的返回值会被忽略，并会在该类退出正常的发生位置继续执行。\n以下代码:\nwith EXPRESSION as TARGET:\rSUITE 在语义上等价于:\nmanager = (EXPRESSION)\renter = type(manager).__enter__\rexit = type(manager).__exit__\rvalue = enter(manager)\rhit_except = False # False 表示正常执行\rtry:\rTARGET = value\rSUITE\rexcept:\rhit_except = True # 发生了异常\r# 忽略或抑制异常，继续退出；或退出并引发异常\rif not exit(manager, *sys.exc_info()):\rraise\rfinally:\rif not hit_except: # 正常执行\r# 正常退出\rexit(manager, None, None, None) 可见使用 with 语句，无论有没有发生异常，都会 “清理” 程序（保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等）。\n有多个表达式，则会视作存在多个 with 语句嵌套来处理多个上下文管理器:\nwith A() as a, B() as b:\rSUITE\r# 在语义上等价于:\rwith A() as a:\rwith B() as b:\rSUITE with 语句常用来打开文件而不需要显式地关闭文件：\nwith open('../11_built-in_function/test.txt', 'r', encoding='utf-8') as f: print(f.read()) xue.cn\r自学是门手艺\r# 相当于 f = open('../11_built-in_function/test.txt', 'r', encoding='utf-8') print(f.read()) f.close() xue.cn\r自学是门手艺\r",
    "description": "",
    "tags": null,
    "title": "with",
    "uri": "/python/10_statement/16_with/"
  },
  {
    "content": "模块是 Python 代码的一种组织单位，也是一种对象。各模块具有独立的命名空间，可包含任意 Python 对象。\n一个 .py 文件是一个模块；一个文件夹是一个模块（包）；文件夹（包）中还可以再有 .py 文件（子模块）和文件夹（子包）。例如 内置模块 random，和第三方包 pandas。\n文件夹中包含一个 __init__.py 文件的包是常规包；无 __init__.py 文件的是命名空间包，仅被用作子包的容器。\n模块无论是用 Python、C 还是别的语言实现均可。\nimport random, pandas type(random), type(pandas) (module, module)\r所有包都是模块，但并非所有模块都是包。或者换句话说，包只是一种特殊的模块。\n可以使用属性 __packge__ 查看包名，如果只是模块不是包，该属性为空字符串。\n__name__ 属性是模块的名字。\n特别地，主模块（你正在运行代码的当前模块）的 __packge__ 属性总是 None；__name__ 属性总是 '__main__' （__main__ 是一个在解释器启动时直接初始化的特殊模块），这可以控制当前模块能够执行，而导入到其他模块不能被执行的代码，然后用来测试当前模块。\nrandom.__package__, pandas.__package__ ('', 'pandas')\rprint(__package__) None\rrandom.__name__, pandas.__name__ ('random', 'pandas')\r__name__ '__main__'\ra = 3 + 2 - 5 def f(): print(a+1) print(a) if __name__ == '__main__': # 以下代码导入其他模块不会执行 print(a == 0) 0\rTrue\r使用 import 语句将其他模块导入当前模块；使用属性表示法调用模块中的属性。\nimport pandas as pd pd.core \u003cmodule 'pandas.core' from 'C:\\\\ProgramData\\\\Anaconda3\\\\lib\\\\site-packages\\\\pandas\\\\core\\\\__init__.py'\u003e\rpd.core.series.Series pandas.core.series.Series\r还可以以脚本的方式执行不属于包的模块（此时 __name__ 属性为 \"__main__\"）。\nimport this this The Zen of Python, by Tim Peters\rBeautiful is better than ugly.\rExplicit is better than implicit.\rSimple is better than complex.\rComplex is better than complicated.\rFlat is better than nested.\rSparse is better than dense.\rReadability counts.\rSpecial cases aren't special enough to break the rules.\rAlthough practicality beats purity.\rErrors should never pass silently.\rUnless explicitly silenced.\rIn the face of ambiguity, refuse the temptation to guess.\rThere should be one-- and preferably only one --obvious way to do it.\rAlthough that way may not be obvious at first unless you're Dutch.\rNow is better than never.\rAlthough never is often better than *right* now.\rIf the implementation is hard to explain, it's a bad idea.\rIf the implementation is easy to explain, it may be a good idea.\rNamespaces are one honking great idea -- let's do more of those!\r\u003cmodule 'this' from 'C:\\\\ProgramData\\\\Anaconda3\\\\lib\\\\this.py'\u003e\r# %run 是 jupyter 的魔法命令，在终端使用 python 命令 # F:\\anaconda\\lib\\this.py 根据自己电脑的路径调整 %run F:\\anaconda\\lib\\this.py The Zen of Python, by Tim Peters\rBeautiful is better than ugly.\rExplicit is better than implicit.\rSimple is better than complex.\rComplex is better than complicated.\rFlat is better than nested.\rSparse is better than dense.\rReadability counts.\rSpecial cases aren't special enough to break the rules.\rAlthough practicality beats purity.\rErrors should never pass silently.\rUnless explicitly silenced.\rIn the face of ambiguity, refuse the temptation to guess.\rThere should be one-- and preferably only one --obvious way to do it.\rAlthough that way may not be obvious at first unless you're Dutch.\rNow is better than never.\rAlthough never is often better than *right* now.\rIf the implementation is hard to explain, it's a bad idea.\rIf the implementation is easy to explain, it may be a good idea.\rNamespaces are one honking great idea -- let's do more of those!\rjupyter附件 __init__.py (26 B) 01_module_summary.ipynb (8 KB) 02_create_module.ipynb (5 KB) 04_executable_file.ipynb (5 KB) 05_import_code.ipynb (12 KB) mycode.py (195 B) space.py (0 B) test.py (51 B) xue.py (26 B) ",
    "description": "",
    "tags": null,
    "title": "模块概述",
    "uri": "/python/15_module/"
  },
  {
    "content": "assert 语句是在程序中插入调试性断言的简便方式。在表达式条件为 False 的时候触发异常。\n简单形式为：assert expression。\nassert 1 + 1 == 2 assert 1 + 1 != 2 ---------------------------------------------------------------------------\rAssertionError Traceback (most recent call last)\r\u003cipython-input-2-5cd89e6dd50b\u003e in \u003cmodule\u003e\r----\u003e 1 assert 1 + 1 != 2\rAssertionError: 扩展形式为：assert expression1, expression2。expression2 通常是提示信息。\nassert 1 + 1 != 2, '计算错误' ---------------------------------------------------------------------------\rAssertionError Traceback (most recent call last)\r\u003cipython-input-7-3b85a53ff241\u003e in \u003cmodule\u003e\r----\u003e 1 assert 1 + 1 != 2, '计算错误'\rAssertionError: 计算错误\rfor i in range(5): try: assert i % 2 == 0, f'{i}是奇数' print(i) except AssertionError as a: print(a) 0\r1是奇数\r2\r3是奇数\r4\r",
    "description": "",
    "tags": null,
    "title": "assert",
    "uri": "/python/10_statement/17_assert/"
  },
  {
    "content": "内置函数（类）enumerate，Python 官方文档描述如下：\nhelp(enumerate) Help on class enumerate in module builtins:\rclass enumerate(object)\r| enumerate(iterable, start=0)\r| | Return an enumerate object.\r| | iterable\r| an object supporting iteration\r| | The enumerate object yields pairs containing a count (from start, which\r| defaults to zero) and a value yielded by the iterable argument.\r| | enumerate is useful for obtaining an indexed list:\r| (0, seq[0]), (1, seq[1]), (2, seq[2]), ...\r| 返回一个可迭代对象（iterable）的枚举对象。枚举对象是一个迭代器，迭代出来是一个个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。\ntype(enumerate) type\re = enumerate({'a':1,'b':2,'c':3}) e \u003cenumerate at 0x200ccb71240\u003e\rnext(e) (0, 'a')\rfor i in e: print(i) (1, 'b')\r(2, 'c')\re = enumerate('abc', 1) list(e) [(1, 'a'), (2, 'b'), (3, 'c')]\r",
    "description": "",
    "tags": null,
    "title": "enumerate 枚举",
    "uri": "/python/11_built-in_function/17_enumerate/"
  },
  {
    "content": "集合方法 set.pop()，Python 官方文档描述如下：\nhelp(set.pop) Help on method_descriptor:\rpop(...)\rRemove and return an arbitrary set element.\rRaises KeyError if the set is empty.\r集合中删除任意一个元素，并返回它。如果集合为空，引发 KeyError。\na = {1,2} a.pop() 1\ra {2}\rset().pop() ---------------------------------------------------------------------------\rKeyError Traceback (most recent call last)\r\u003cipython-input-6-db3bab0ab3b8\u003e in \u003cmodule\u003e\r----\u003e 1 set().pop()\rKeyError: 'pop from an empty set'\r",
    "description": "",
    "tags": null,
    "title": "set.pop 删除元素并返回",
    "uri": "/python/06_set/17_set.pop/"
  },
  {
    "content": "字符串方法 str.index()，Python 官方文档描述如下：\nhelp(str.index) Help on method_descriptor:\rindex(...)\rS.index(sub[, start[, end]]) -\u003e int\rReturn the lowest index in S where substring sub is found,\rsuch that sub is contained within S[start:end]. Optional\rarguments start and end are interpreted as in slice notation.\rRaises ValueError when the substring is not found.\r返回子字符串 sub 在 s[start:end] 切片内被找到的最小索引。可选参数 start 与 end 会被解读为切片表示法。类似于 find()，但在找不到 sub 时会引发 ValueError。\n只给定 sub 一个参数的话，于是从第一个字符开始搜索到字符串结束；如果，随后给定了一个可选参数的话，那么它是 start，于是从 start 开始，搜索到字符串结束；如果 start 之后还有参数的话，那么它是 end；于是从 start 开始，搜索到 end - 1 结束（即不包含索引值为 end 的那个字符）。\n'pythonpython'.index('y') 1\r'pythonpython'.index('pt') ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-3-4252de1acf66\u003e in \u003cmodule\u003e\r----\u003e 1 'pythonpython'.index('pt')\rValueError: substring not found\r'pythonpython'.index('y',5) 7\r'pythonpython'.index('y',5,7) ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-5-35705122f03a\u003e in \u003cmodule\u003e\r----\u003e 1 'pythonpython'.index('y',5,7)\rValueError: substring not found\r",
    "description": "",
    "tags": null,
    "title": "str.index 查找最小索引",
    "uri": "/python/02_string/17_str.index/"
  },
  {
    "content": "面向对象概述 面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。它把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。\n例如生活中我们会遇到各种数字及其运算，于是计算机科学家们就把数字抽象出来，成为一类对象。它们有别于其他事物（例如文字，图像）的特征，有自己的一套运算、操作方法。\nPython 中的数字当然非常类似数学中的数字，但也受限于计算机中的数字表示方法。\n为了方便，又把数字这一类对象，基本分成了整数，浮点数，复数三类对象。这对应 Python 中的 int，float，comlex 三种数字类型，三种数字类型下具体的整数，浮点数，复数也是对象。它们有共同的特征和计算方法，也有各自特有的特征和方法。例如都可以进行加减乘除，只有整数有按位运算。\n整数中，0 和 1 的特殊性，又使得可以将整数类中再分出一类对象，布尔类型对象。布尔类型的对象，只有两个对象，True 和 False。\n从数字类对象，到三类数字对象，到布尔类对象，到具体的数字对象以及 True 和 False 对象，层层细分，最终是具体的一个个对象，它们都是对象。这也是为什么称 Python 一切皆对象的原因。\n类似地，对数据，因为要实现的目的不同，将装数据的 “容器” 分为字符串，列表，元组，集合，字典等类型的对象。\n函数抽象出函数对象，模块又抽象出模块对象…… 甚至连空都是对象（None）。\n具体的对象，称为实例，它归属于某个类。而所有的类，又都是 object 对象的子类。各种类（类型），又统一归为类型对象（type)。\ntype(1), isinstance(1,int) # 1 是 int 类的实例 (int, True)\rissubclass(int,object) # int 类是 object 的子类 True\rtype(int), isinstance(int,type) # int 是 type 的实例 (type, True)\r按照面向对象的思想，我们可以定义一个 “人” 类对象，然后很方便地给这个 “人” 加上现有的各种函数，类，以及模块的功能，造出更多更多有各种特异功能的 “人”。这是不是非常伟大的设计思想呢？\njupyter附件 01_class_summary.ipynb (3 KB) 02_class_definition.ipynb (5 KB) 03_instance.ipynb (5 KB) 04_object.ipynb (7 KB) 05_name.ipynb (12 KB) 06_variable.ipynb (5 KB) 07_attribute.ipynb (8 KB) 08_method.ipynb (6 KB) 09_namespace.ipynb (5 KB) 10_scope.ipynb (9 KB) 11_create_instance.ipynb (4 KB) 12_attribute_operation.ipynb (10 KB) 13_method_operation.ipynb (5 KB) 14_inheritance.ipynb (5 KB) ",
    "description": "",
    "tags": null,
    "title": "面向对象概述",
    "uri": "/python/16_class/"
  },
  {
    "content": "内置函数 eval()，Python 官方文档描述如下：\nhelp(eval) Help on built-in function eval in module builtins:\reval(source, globals=None, locals=None, /)\rEvaluate the given source in the context of globals and locals.\rThe source may be a string representing a Python expression\ror a code object as returned by compile().\rThe globals must be a dictionary and locals can be any mapping,\rdefaulting to the current globals and locals.\rIf only globals is given, locals defaults to it.\rsource 参数接受字符串（会作为一个 Python 表达式）或代码对象（可通过 compile() 创建），然后解析并求值，返回求值结果。\neval('{1 + 1}') {2}\rs = 'for i in range(3):print(i)' code = compile(s,'','exec') eval(code) 0\r1\r2\reval(\"__import__('math').sqrt(3**2+4**2)\") 5.0\r参数 globals 和 locals 作为 source 的全局和局部命名空间。如果省略 locals 字典则其默认值为 globals 字典。如果两个字典同时省略，则表达式执行时会使用 eval() 被调用的环境中的全局和局部名称。\n如果 globals 字典存在且不包含以 __builtins__ 为键的值，则会在解析 source 之前插入以此为键的对内置模块 builtins 的引用。这意味着 source 通常具有对标准 builtins 模块的完全访问权限且受限的环境会被传播。\nglobals 实参必须是一个字典。locals 可以是任何映射对象。\nx = 3 def f(): y = 4 code = \"__import__('math').sqrt(x**2+y**2)\" z = eval(code,{'x':5},{'y':12}) print(f'x={x}, y={y}, z={z}') f() x=3, y=4, z=13.0\rx = 3 def f(): y = 4 code = \"__import__('math').sqrt(x**2+y**2)\" z = eval(code,{'x':5,'y':12}) print(f'x={x}, y={y}, z={z}') f() x=3, y=4, z=13.0\rx = 3 def f(): y = 4 code = \"__import__('math').sqrt(x**2+y**2)\" z = eval(code) print(f'x={x}, y={y}, z={z}') f() x=3, y=4, z=5.0\r",
    "description": "",
    "tags": null,
    "title": "eval() 解析字符串或代码并求值",
    "uri": "/python/11_built-in_function/18_eval/"
  },
  {
    "content": "import 语句用于从模块中导入子模块，类，函数等。语法大致有三种：\n# 第一种\rimport module as name, module as name, ...\r# 第二种\r# import 之后可以置于一个元组\rfrom module import identifier as name, identifier as name, ...\r# 第三种\rfrom module import * 模块 module 可以是高层级到低层级用属性表示法引用的模块，例如 pandas.core.series。\nas 及其后的别名 name 是可选的。\n语句可以导入单个或多个对象，用逗号分隔实际是多个子句。\n第一种导入方法，如果成功获取到模块，则可以通过以下方式之一在 import 语句所在命名空间中使用它：\n如果被导入模块是最高层级模块，模块名被绑定； 如果导入的模块不是最高层级的模块，则该模块的最高层级模块名被绑定，该模块必须使用完整限定名访问； 如果有 as，则 as 之后的别名被绑定，模块名不绑定。 如果没有指定模块，引发 ModuleNotFoundError。\nimport pandas pandas \u003cmodule 'pandas' from 'F:\\\\anaconda\\\\lib\\\\site-packages\\\\pandas\\\\__init__.py'\u003e\rdel pandas import pandas.core.series pandas, pandas.core, pandas.core.series (\u003cmodule 'pandas' from 'F:\\\\anaconda\\\\lib\\\\site-packages\\\\pandas\\\\__init__.py'\u003e,\r\u003cmodule 'pandas.core' from 'F:\\\\anaconda\\\\lib\\\\site-packages\\\\pandas\\\\core\\\\__init__.py'\u003e,\r\u003cmodule 'pandas.core.series' from 'F:\\\\anaconda\\\\lib\\\\site-packages\\\\pandas\\\\core\\\\series.py'\u003e)\rseries # 必须完成限定名访问 ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-6-2859777d6f2b\u003e in \u003cmodule\u003e\r----\u003e 1 series\rNameError: name 'series' is not defined\rdel pandas import pandas.core.series as pds pds \u003cmodule 'pandas.core.series' from 'F:\\\\anaconda\\\\lib\\\\site-packages\\\\pandas\\\\core\\\\series.py'\u003e\rpandas # 只能使用别名访问 ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-8-609b6d5922fb\u003e in \u003cmodule\u003e\r----\u003e 1 pandas\rNameError: name 'pandas' is not defined\rdef f(): import pandas # 局部命名空间导入 pandas # 全局命名空间不能访问 ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-10-0b76d1984901\u003e in \u003cmodule\u003e\r1 def f():\r2 import pandas # 局部命名空间导入\r----\u003e 3 pandas\rNameError: name 'pandas' is not defined\r第二种导入方法，如果成功获取到模块，from 之后的模块名不会被绑定，对于 import 子句导入的属性或子模块，如果有 as 子句，则只能使用其指定的别名使用它，否则使用该属性或子模块的名称 identifier 使用它。\n如果属性或子模块不存在，或不能导入，引发 ImportError。\nfrom pandas.core import base base \u003cmodule 'pandas.core.base' from 'F:\\\\anaconda\\\\lib\\\\site-packages\\\\pandas\\\\core\\\\base.py'\u003e\rpandas.core # 只导入了该模块下的子模块 base ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-2-37462de79a89\u003e in \u003cmodule\u003e\r----\u003e 1 pandas.core\rNameError: name 'pandas' is not defined\r# 导入多个可置于元组中 from random import (random as r1, randint as r2,) r1, r2 (\u003cfunction Random.random()\u003e,\r\u003cbound method Random.randint of \u003crandom.Random object at 0x000001E531A14580\u003e\u003e)\r# pandas 下没有 base，导入错误 from pandas import base ---------------------------------------------------------------------------\rImportError Traceback (most recent call last)\r\u003cipython-input-7-7903c4949085\u003e in \u003cmodule\u003e\r----\u003e 1 from pandas import base\rImportError: cannot import name 'base' from 'pandas' (F:\\anaconda\\lib\\site-packages\\pandas\\__init__.py)\r第三种导入方法，则在模块中定义的全部公有名称都将绑定到 import 语句所在的命名空间。\n公有名称是由在模块的命名空间中检测一个名为 __all__ 的变量来确定的；如果 __all__ 没有被定义，则公有名称的集合将包含模块的命名空间中找到的所有不以下划线字符 _ 打头的名称。\nfrom random import * randint \u003cbound method Random.randint of \u003crandom.Random object at 0x0000025E1DCC8180\u003e\u003e\r当指定要导入哪个模块时，你不必指定模块的绝对名称。当一个模块或包被包含在另一个包之中时，可以在同一个最高层级包中进行相对导入，而不必提及包名称。\n通过在 from 之后指定的模块或包中使用前缀点号，你可以在不指定确切名称的情况下指明在当前包层级结构中要上溯多少级。一个前缀点号表示是执行导入的模块所在的当前包，两个点号表示上溯一个包层级。三个点号表示上溯两级，依此类推。例如：\npackage/\r__init__.py\rsubpackage1/\r__init__.py\rmoduleX.py\rmoduleY.py\rsubpackage2/\r__init__.py\rmoduleZ.py\rmoduleA.py 假设当前位置是 subpackage1/moduleX.py，则：\nfrom .moduleY import spam\rfrom . import moduleY\rfrom ..subpackage1 import moduleY\rfrom ..subpackage2.moduleZ import eggs\rfrom ..moduleA import foo 都是有效的。\n",
    "description": "",
    "tags": null,
    "title": "import",
    "uri": "/python/10_statement/18_import/"
  },
  {
    "content": "集合方法 set.clear()，Python 官方文档描述如下：\nhelp(set.clear) Help on method_descriptor:\rclear(...)\rRemove all elements from this set.\r清空集合所有元素。\na = {1,2} a.clear() a set()\r该方法是一个过程，就地修改集合，返回值为 None。\na = {1,2} b = a.clear() print(b) None\r",
    "description": "",
    "tags": null,
    "title": "set.clear 清空集合元素",
    "uri": "/python/06_set/18_set.clear/"
  },
  {
    "content": "字符串方法 str.rindex()，Python 官方文档描述如下：\nhelp(str.rindex) Help on method_descriptor:\rrindex(...)\rS.rindex(sub[, start[, end]]) -\u003e int\rReturn the highest index in S where substring sub is found,\rsuch that sub is contained within S[start:end]. Optional\rarguments start and end are interpreted as in slice notation.\rRaises ValueError when the substring is not found.\r返回子字符串 sub 在字符串内被找到的最大（最右）索引，这样 sub 将包含在 s[start:end] 当中。可选参数 start 与 end 会被解读为切片表示法。如果未找到则返回 -1。类似于 rfind()，但在子字符串 sub 未找到时会引发 ValueError。\n只给定 sub 一个参数的话，于是从第一个字符开始搜索到字符串结束；如果，随后给定了一个可选参数的话，那么它是 start，于是从 start 开始，搜索到字符串结束；如果 start 之后还有参数的话，那么它是 end；于是从 start 开始，搜索到 end - 1 结束（即不包含索引值为 end 的那个字符）。\n'python python'.rindex('on') 11\r'python python'.rindex('on',1,7) 4\r'python python'.rindex('on',7) 11\r'python python'.rindex('no') ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-5-92aeb174dba9\u003e in \u003cmodule\u003e\r----\u003e 1 'python python'.rindex('no')\rValueError: substring not found\r",
    "description": "",
    "tags": null,
    "title": "str.rindex 查找最大索引",
    "uri": "/python/02_string/18_str.rindex/"
  },
  {
    "content": "内置函数 exec()，Python 官方文档描述如下：\nhelp(exec) Help on built-in function exec in module builtins:\rexec(source, globals=None, locals=None, /)\rExecute the given source in the context of globals and locals.\rThe source may be a string representing one or more Python statements\ror a code object as returned by compile().\rThe globals must be a dictionary and locals can be any mapping,\rdefaulting to the current globals and locals.\rIf only globals is given, locals defaults to it.\r这个函数支持动态执行 Python 代码。source 必须是字符串或者代码对象。\n如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。\n如果是代码对象，它将被直接执行。\n该函数返回值为 None。\nprint(exec('{1 + 1}')) None\rs = 'for i in range(3):print(i)' code = compile(s,'','exec') exec(code) 0\r1\r2\r参数 globals 和 locals 作为 source 的全局和局部命名空间。如果省略 locals 字典则其默认值为 globals 字典。如果两个字典同时省略，则表达式执行时会使用 eval() 被调用的环境中的全局和局部名称。\n如果 globals 字典存在且不包含以 __builtins__ 为键的值，则将为该键插入对内建 builtins 模块字典的引用。因此，在将执行的代码传递给 exec() 之前，可以通过将自己的 __builtins__ 字典插入到 globals 中来控制可以使用哪些内置代码。\nglobals 实参必须是一个字典。locals 可以是任何映射对象。\nx = 1 def f(): x = 2 code = \"for i in range(x):print(i)\" exec(code,{'x':3},{'x':4}) f() 0\r1\r2\r3\rx = 1 def f(): x = 2 code = \"for i in range(x):print(i)\" exec(code,{'x':3}) f() 0\r1\r2\rx = 1 def f(): x = 2 code = \"for i in range(x):print(i)\" exec(code) f() 0\r1\r",
    "description": "",
    "tags": null,
    "title": "exec() 解析字符串或代码并求值",
    "uri": "/python/11_built-in_function/19_exec/"
  },
  {
    "content": "global 语句作用于整个当前代码块，它后面所列出的标识符将被解读为全局变量。\n在 global 语句中列出的名称不得在同一代码块内该 global 语句之前的位置中使用。\n当前的实现虽然并未强制要求，但在 global 语句中列出的名称不得被定义为正式形参，不也得出现于 for 循环的控制目标、class 定义、函数定义、import 语句 或 变量标注之中。\n举例如下：\ndef f(): a = 0 f() # 调用函数，对 a 赋值 a # a 是局部变量，不可访问 ---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u003cipython-input-5-251a24e05273\u003e in \u003cmodule\u003e\r3 4 f() # 调用函数，对 a 赋值\r----\u003e 5 a # a 是局部变量，不可访问\rNameError: name 'a' is not defined\rdef f(): global a # 将 a 声明为全局变量 a = 0 f() # 调用函数，对 a 赋值 print(a) # a 已经是全局变量 del a 0\rdef f(): a = 1 # 同一代码块中，不可在 global 前使用 global a # 将 a 声明为全局变量 a = 0 File \"\u003cipython-input-9-51bc7826eb42\u003e\", line 3\rglobal a # 将 a 声明为全局变量\r^\rSyntaxError: name 'a' is assigned to before global declaration\ra = 1 # 与 global 不在一个代码块 def f(): global a, b # 将 a, b 声明为全局变量 a = 0 # a 被重新赋值 b = 1 f() # 调用函数，对 b 赋值，对 a 重新赋值 print(a,b) del a,b 0 1\r",
    "description": "",
    "tags": null,
    "title": "global",
    "uri": "/python/10_statement/19_global/"
  },
  {
    "content": "字符串方法 str.join()，Python 官方文档描述如下：\nhelp(str.join) Help on method_descriptor:\rjoin(self, iterable, /)\rConcatenate any number of strings.\rThe string whose method is called is inserted in between each given string.\rThe result is returned as a new string.\rExample: '.'.join(['ab', 'pq', 'rs']) -\u003e 'ab.pq.rs'\r返回一个由 iterable 中的字符串拼接而成的字符串。如果 iterable 中存在任何非字符串值则会引发 TypeError。调用该方法的字符串将作为元素之间的分隔。\n'~'.join('abc') 'a~b~c'\r'acb'.join(['1','2']) '1acb2'\r''.join(['1','2']) '12'\r'-'.join({'1':1,'2':2}) '1-2'\r'-'.join(['1',2]) ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-9-fc346e5ca62e\u003e in \u003cmodule\u003e\r----\u003e 1 '-'.join(['1',2])\rTypeError: sequence item 1: expected str instance, int found\r'-'.join(b'abc') ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-8-9d04d7060926\u003e in \u003cmodule\u003e\r----\u003e 1 '-'.join(b'abc')\rTypeError: sequence item 0: expected str instance, int found\r",
    "description": "",
    "tags": null,
    "title": "str.join 拼接字符串",
    "uri": "/python/02_string/19_str.join/"
  },
  {
    "content": "内置函数（类）filter，Python 官方文档描述如下：\nhelp(filter) Help on class filter in module builtins:\rclass filter(object)\r| filter(function or None, iterable) --\u003e filter object\r| | Return an iterator yielding those items of iterable for which function(item)\r| is true. If function is None, return the items that are true.\r| 返回可迭代对象（iterable）中那些传递给函数 function 计算之后，布尔值仍然为真的元素组成的迭代器。\n如果 function 是 None，则会假设它是一个身份函数，即 iterable 中所有布尔值为假的元素会被移除。\ntype(filter) type\rf = filter(None,[0,1,2,1]) list(f) [1, 2, 1]\rf = filter(lambda x: x-1, [0,1,2,1]) list(f) [0, 2]\rlist(filter(None,'0120')) ['0', '1', '2', '0']\rlist(filter(int,'0120')) ['1', '2']\r",
    "description": "",
    "tags": null,
    "title": "filter 真值元素筛选",
    "uri": "/python/11_built-in_function/20_filter/"
  },
  {
    "content": "nonlocal 语句会使得所列出的名称指向在它之前已经存在的，和它最近并且在包含它的作用域中绑定，除全局变量以外的变量。\n这种功能很重要，因为绑定的默认行为是先搜索局部命名空间。这个语句允许被封装的代码重新绑定局部作用域以外且非全局（模块）作用域当中的变量。\n举例如下：\na = '全局' def f(): a = 'f' # f 中已经存在的 a, 包含 f2 def f1(): a = 'f1' # f1 中的局部变量 def f2(): nonlocal a # 和他最近且包含的是 'f' a = 'f2' def f3(): global a a = 'f3' # 调用 f1 不改变 a = 'f' f1() print(a) # 调用 f2, nonlocal 将 a = 'f' 重新绑定为 a = 'f2' f2() print(a) # 调用 f3, global 将 a 声明为全局变量， # 并将 a = '全局' 重新绑定为 a = 'f3' # 但在 f 这个局部中，a 仍然是 'f2' f3() print(a) f() # 调用 f 使绑定都生效 print(a) f\rf2\rf2\rf3\r# 不存在不可以绑定 def f(): nonlocal a a = 1 f() File \"\u003cipython-input-3-3706e217f701\u003e\", line 2\rnonlocal a\r^\rSyntaxError: no binding for nonlocal 'a' found\r# 不是包含它的作用域，不可以绑定 def f(): def f1(): a = 0 f1() nonlocal a a = 1 f() File \"\u003cipython-input-4-a036260d029b\u003e\", line 5\rnonlocal a\r^\rSyntaxError: no binding for nonlocal 'a' found\r# 全局变量，不可以绑定 a = 0 def f(): nonlocal a a = 1 f() File \"\u003cipython-input-5-87297c0b0eeb\u003e\", line 4\rnonlocal a\r^\rSyntaxError: no binding for nonlocal 'a' found\r",
    "description": "",
    "tags": null,
    "title": "nonlocal",
    "uri": "/python/10_statement/20_nonlocal/"
  },
  {
    "content": "字符串方法 str.startswith()，Python 官方文档描述如下：\nhelp(str.startswith) Help on method_descriptor:\rstartswith(...)\rS.startswith(prefix[, start[, end]]) -\u003e bool\rReturn True if S starts with the specified prefix, False otherwise.\rWith optional start, test S beginning at that position.\rWith optional end, stop comparing S at that position.\rprefix can also be a tuple of strings to try.\r如果字符串以指定的 prefix 开始则返回 True，否则返回 False。prefix 也可以为由多个供查找的前缀构成的元组。如果有可选项 start，将从所指定位置开始检查。如果有可选项 end，将在所指定位置之前停止比较。\n'a.b.a.c'.startswith('ab') False\r'a.b.a.c'.startswith('a.') True\r'a.b.a.c'.startswith('ab',2) False\r'a.b.a.c'.startswith('a.',4) True\r'a.b.a.c'.startswith('a',1,4) False\r",
    "description": "",
    "tags": null,
    "title": "str.startswith 指定字符串开头？",
    "uri": "/python/02_string/20_str.startswith/"
  },
  {
    "content": "内置函数（类）float，Python 官方文档描述如下：\nhelp(float) Help on class float in module builtins:\rclass float(object)\r| float(x=0, /)\r| | Convert a string or number to a floating point number, if possible.\r| 返回从数字或字符串 x 生成的浮点数。\n如果实参是字符串:\n它必须是包含十进制数字的字符串; 通常是 Python 整数或浮点数的字符串形式； 也可以是 ‘NaN’（非数字）、表示正负无穷大的字符串（“Infinity” 或 “inf”）。字母大小写随意； 字符串前后可以有空白字符。 如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发OverflowError。\n如果没有实参，则返回 0.0 。\ntype(float) type\rfloat() 0.0\rfloat(1) 1.0\rfloat(- 1.0) -1.0\rfloat(' -1.0 \\n') -1.0\rfloat(' 01_2.1_4 ') 12.14\rfloat('0001') 1.0\rfloat('3.14e02') 314.0\rfloat('-naN') nan\rfloat('-inf') -inf\r",
    "description": "",
    "tags": null,
    "title": "float 创建浮点数",
    "uri": "/python/11_built-in_function/21_float/"
  },
  {
    "content": "字符串方法 str.endswith()，Python 官方文档描述如下：\nhelp(str.endswith) Help on method_descriptor:\rendswith(...)\rS.endswith(suffix[, start[, end]]) -\u003e bool\rReturn True if S ends with the specified suffix, False otherwise.\rWith optional start, test S beginning at that position.\rWith optional end, stop comparing S at that position.\rsuffix can also be a tuple of strings to try.\r如果字符串以指定的 suffix 结束返回 True，否则返回 False。suffix 也可以为由多个供查找的后缀构成的元组。如果有可选项 start，将从所指定位置开始检查。如果有可选项 end，将在所指定位置之前停止比较。\n'python.exe'.endswith('.exe') True\r'python.exe'.endswith(('.exe','.txt'), 5) True\r'python.exe'.endswith(('.py','.txt'), 5) False\r'python.exe'.endswith(('.exe','.txt'), 5,9) False\r",
    "description": "",
    "tags": null,
    "title": "str.endswith 指定字符串结尾？",
    "uri": "/python/02_string/21_str.endswith/"
  },
  {
    "content": "内置函数 format()，Python 官方文档描述如下：\nhelp(format) Help on built-in function format in module builtins:\rformat(value, format_spec='', /)\rReturn value.__format__(format_spec)\rformat_spec defaults to the empty string.\rSee the Format Specification Mini-Language section of help('FORMATTING') for\rdetails.\r将 value 转换为 format_spec 控制的 “格式化” 表示。format_spec 的解释取决于 value 实参的类型，但是大多数内置类型使用标准格式化语法：格式化迷你语言。详见 str.format 格式化。\n默认的 format_spec 是一个空字符串，它通常和调用 str(value) 的结果相同。\nformat('嗨','\u003e10') ' 嗨'\rformat('嗨','~^10') '~~~~嗨~~~~~'\rformat(1,'05') '00001'\rformat(3.14,'.3f') '3.140'\rformat(123456789,'_') '123_456_789'\rformat(123456789,'.2e') '1.23e+08'\rformat(123456789) '123456789'\r",
    "description": "",
    "tags": null,
    "title": "format() 格式化",
    "uri": "/python/11_built-in_function/22_format/"
  },
  {
    "content": "字符串方法 str.ljust()，Python 官方文档描述如下：\nhelp(str.ljust) Help on method_descriptor:\rljust(self, width, fillchar=' ', /)\rReturn a left-justified string of length width.\rPadding is done using the specified fill character (default is a space).\r返回长度为 width 的字符串，原字符串在其中靠左对齐。使用指定的 fillchar 填充空位 (默认使用 ASCII 空格符)。如果 width 小于等于字符串长度 len(str) 则返回原字符串的副本。\n'python'.ljust(1) 'python'\r'python'.ljust(10,'~') 'python~~~~'\r'python'.ljust(10) 'python '\r",
    "description": "",
    "tags": null,
    "title": "str.ljust 左对齐",
    "uri": "/python/02_string/22_str.ljust/"
  },
  {
    "content": "内置函数（类）frozenset，Python 官方文档描述如下：\nhelp(frozenset) Help on class frozenset in module builtins:\rclass frozenset(object)\r| frozenset() -\u003e empty frozenset object\r| frozenset(iterable) -\u003e frozenset object\r| | Build an immutable unordered collection of unique elements.\r| 将可迭代对象转换为集合，返回一个新的 frozenset 集合对象。可迭代对象为空，或不传参数，得到一个空集合。\ntype(frozenset) type\rfrozenset() frozenset()\rfrozenset([]) frozenset()\rfrozenset('0123') frozenset({'0', '1', '2', '3'})\rfrozenset({'a':1,'b':2}) frozenset({'a', 'b'})\r",
    "description": "",
    "tags": null,
    "title": "frozenset 创建不可变集合",
    "uri": "/python/11_built-in_function/23_frozenset/"
  },
  {
    "content": "字符串方法 str.center()，Python 官方文档描述如下：\nhelp(str.center) Help on method_descriptor:\rcenter(self, width, fillchar=' ', /)\rReturn a centered string of length width.\rPadding is done using the specified fill character (default is a space).\r返回长度为 width 的字符串，原字符串在其正中。使用指定的 fillchar 填充两边的空位（默认使用ASCII 空格符）。如果 width 小于等于字符串长度，则返回原字符串的副本:\n'Python'.center(1) 'Python'\r'Python'.center(10) ' Python '\r'Python'.center(20,'~') '~~~~~~~Python~~~~~~~'\r",
    "description": "",
    "tags": null,
    "title": "str.center 居中",
    "uri": "/python/02_string/23_str.center/"
  },
  {
    "content": "内置函数 getattr()，Python 官方文档描述如下：\nhelp(getattr) Help on built-in function getattr in module builtins:\rgetattr(...)\rgetattr(object, name[, default]) -\u003e value\rGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\rWhen a default argument is given, it is returned when the attribute doesn't\rexist; without it, an exception is raised in that case.\r返回对象给定的属性名指向的值。name 必须是字符串。如果该字符串是对象的属性名称之一，则返回该属性的值。例如，getattr(x, 'y') 等同于 x.y。如果指定的属性不存在，且提供了 default 值，则返回它，否则触发 AttributeError。\ngetattr(1,'imag') 0\rgetattr(1,'bool',True) True\rgetattr(1,'bool') ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-6-524bb2b35e58\u003e in \u003cmodule\u003e\r----\u003e 1 getattr(1,'bool')\rAttributeError: 'int' object has no attribute 'bool'\rclass A: y = 1 x = A() x.y 1\rgetattr(x,'y') 1\r",
    "description": "",
    "tags": null,
    "title": "getattr() 获取对象的属性",
    "uri": "/python/11_built-in_function/24_getattr/"
  },
  {
    "content": "字符串方法 str.rjust()，Python 官方文档描述如下：\nhelp(str.rjust) Help on method_descriptor:\rrjust(self, width, fillchar=' ', /)\rReturn a right-justified string of length width.\rPadding is done using the specified fill character (default is a space).\r返回长度为 width 的字符串，原字符串在其中靠右对齐。使用指定的 fillchar 填充空位 (默认使用 ASCII 空格符)。如果 width 小于等于字符串长度 len(str) 则返回原字符串的副本。\n'python'.rjust(1) 'python'\r'python'.rjust(10,'~') '~~~~python'\r'python'.rjust(10) ' python'\r",
    "description": "",
    "tags": null,
    "title": "str.rjust 右对齐",
    "uri": "/python/02_string/24_str.rjust/"
  },
  {
    "content": "内置函数 globals()，Python 官方文档描述如下：\nhelp(globals) Help on built-in function globals in module builtins:\rglobals()\rReturn the dictionary containing the current scope's global variables.\rNOTE: Updates to this dictionary *will* affect name lookups in the current\rglobal scope and vice-versa.\r返回包含当前作用域的全局变量字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。\n更新此字典 将 影响当前全局范围内的名称查找，反之亦然。\nglobals() 和 locals() 函数各自返回当前的全局和本地字典，因此可以将它们传递给 eval() 或 exec() 来使用。\nglobals() {'__name__': '__main__',\r'__doc__': 'Automatically created module for IPython interactive environment',\r'__package__': None,\r'__loader__': None,\r'__spec__': None,\r'__builtin__': \u003cmodule 'builtins' (built-in)\u003e,\r'__builtins__': \u003cmodule 'builtins' (built-in)\u003e,\r'_ih': ['', 'help(globals)', 'globals()'],\r'_oh': {},\r'_dh': ['D:\\\\Jupyter\\\\xuecn_books\\\\books\\\\xue_python_kp\\\\11_built-in_function'],\r'In': ['', 'help(globals)', 'globals()'],\r'Out': {},\r'get_ipython': \u003cbound method InteractiveShell.get_ipython of \u003cipykernel.zmqshell.ZMQInteractiveShell object at 0x000001E15E70D748\u003e\u003e,\r'exit': \u003cIPython.core.autocall.ZMQExitAutocall at 0x1e160f63978\u003e,\r'quit': \u003cIPython.core.autocall.ZMQExitAutocall at 0x1e160f63978\u003e,\r'_': '',\r'__': '',\r'___': '',\r'_i': 'help(globals)',\r'_ii': '',\r'_iii': '',\r'_i1': 'help(globals)',\r'_i2': 'globals()'}\r",
    "description": "",
    "tags": null,
    "title": "globals() 返回全局变量字典",
    "uri": "/python/11_built-in_function/25_globals/"
  },
  {
    "content": "字符串方法 str.format()，Python 官方文档描述如下：\nhelp(str.format) Help on method_descriptor:\rformat(...)\rS.format(*args, **kwargs) -\u003e str\rReturn a formatted version of S, using substitutions from args and kwargs.\rThe substitutions are identified by braces ('{' and '}').\r执行字符串格式化操作。调用此方法的字符串可以包含字符串字面值或者以花括号 {} 括起来的替换域。每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。\n\"The sum of 1 + 2 is {0}\".format(1+2) 'The sum of 1 + 2 is 3'\r如果你需要在字面文本中包含花括号字符，可以通过重复来转义:\n\"{{python}}\".format() '{python}'\r位置传参和关键字传参方式非常灵活，多个位置索引依次为 0,1,2……，且可以不插入字符串中；关键字传参则需要将关键字插入字符串中：\n'{} and {} are both {age} years old.\\ '.format('A','B',age=18) 'A and B are both 18 years old.'\r'{1} and {0} are both {age} years old.\\ '.format('A','B',age=18) 'B and A are both 18 years old.'\r'{age} and {} are both {} years old.\\ '.format('A','B',age=18) '18 and A are both B years old.'\r'{0} and {0} are both {0} years old.\\ '.format('A','B',age=18) 'A and A are both A years old.'\r通常，格式化值的工作由值本身的 __format__() 方法来完成。但是，在某些情况下最好强制将类型格式化为一个字符串，覆盖其本身的格式化定义。通过在调用 __format__() 之前将值转换为字符串，可以绕过正常的格式化逻辑。\n目前支持的转换旗标有三种: ‘!s’ 会对值调用 str()，’!r’ 调用 repr() 而 ‘!a’ 则调用 ascii()。\n'{1!s} and {0!r} are both {age!a} years old.\\ '.format('A','B',age=18) \"B and 'A' are both 18 years old.\"\r可以包含值应如何呈现的规格描述，例如字段宽度、对齐、填充、小数精度等细节信息。每种值类型可以定义自己的 “格式化迷你语言” 或解读方式。\n各种格式化方式示例： # 复数格式化 ('The complex number {0} is formed' ' from the real part {0.real} ' 'and the imaginary part {0.imag}.').format(3-5j) 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'\r# 利用索引取出某项格式化，不可切片 'X: {0[0]}; Y: {0[1]}'.format([1,2,3]) 'X: 1; Y: 2'\r# 切片格式化 a = [1,2,3] 'X: {0}; Y: {1}'.format(a[:2],a[-2:]) 'X: [1, 2]; Y: [2, 3]'\r# 右对齐 '{:\u003e20}'.format('right aligned') ' right aligned'\r# 填充 ~ 居中 '{:~^20}'.format('centered') '~~~~~~centered~~~~~~'\r# 更复杂的排版 for i, w in zip('\u003c^\u003e', ['left', 'center', 'right']): print('{0:{fill}{align}20}'.format(w, fill=i, align=i)) left\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\r^^^^^^^center^^^^^^^\r\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003eright\r# 数字前填充 0 '{:05}'.format(12) '00012'\r# 设置保留精度 '{:f}; {:+.1f}'.format(3.14, -3.14) '3.140000; -3.1'\r# 各种进制格式化 \"int: {0:d}; hex: {0:x}; oct: {0:o}; \\ bin: {0:b}\".format(42) 'int: 42; hex: 2a; oct: 52; bin: 101010'\r# 保留进制前缀 \"int: {0:d}; hex: {0:#x}; oct: {0:#o}; \\ bin: {0:#b}\".format(42) 'int: 42; hex: 0x2a; oct: 0o52; bin: 0b101010'\r# 让数字更易读 '{:,}'.format(1234567890) '1,234,567,890'\r# 百分比格式化 'Correct answers: {:.2%}'.format(5/6) 'Correct answers: 83.33%'\r# 特定类型的专属格式化 import datetime d = datetime.datetime(2010, 7, 4, 12, 15, 58) '{:%Y-%m-%d %H:%M:%S}'.format(d) '2010-07-04 12:15:58'\r# IP地址格式化 octets = [192, 168, 0, 1] '{:02X}{:02X}{:02X}{:02X}'.format(*octets) 'C0A80001'\r“格式化迷你语言” 总结 各种对齐选项的含义：\n‘\u003c’ 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 ‘\u003e’ 强制字段在可用空间内右对齐（这是数字的默认值）。 ‘=’ 强制将填充放置在符号（如果有）之后但在数字之前。这用于以 “+000000120” 形式打印字段。此对齐选项仅对数字类型有效。当 ’0’ 紧接在字段宽度之前时，它成为默认值。 ‘^’ 强制字段在可用空间内居中。 仅对数字类型有效选项：\n‘+’ 表示标志应该用于正数和负数。 ‘-’ 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 ‘#’ 选项可以让“替代形式”被用于转换。替代形式可针对不同类型分别定义。对于整数类型，当使用二进制、八进制或十六进制输出时，此选项会为输出值添加相应的 ‘0b’, ‘0o’ 或 ‘0x’ 前缀。 ‘,’ 选项表示使用逗号作为千位分隔符。对于感应区域设置的分隔符，请改用 ’n’ 整数表示类型。 ‘_’ 选项表示对浮点表示类型和整数表示类型 ’d’ 使用下划线作为千位分隔符。对于整数表示类型 ‘b’,‘o’, ‘x’ 和 ‘X’，将为每 4 个数位插入一个下划线。对于其他表示类型指定此选项则将导致错误。 确定了数据应如何呈现：\n’s’ 字符串格式。这是字符串的默认类型，可以省略。 ‘b’ 二进制格式。输出以 2 为基数的数字。 ‘c’ 字符。在打印之前将整数转换为相应的 unicode 字符。 ’d’ 十进制整数。输出以 10 为基数的数字。 ‘o’ 八进制格式。输出以 8 为基数的数字。 ‘x’ 十六进制格式。输出以 16 为基数的数字，使用小写字母表示 9 以上的数码。 ‘X’ 十六进制格式。输出以 16 为基数的数字，使用大写字母表示 9 以上的数码。 ’n’ 数字。这与 ’d’ 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。 ’e’ 指数表示。以使用字母’e’ 来标示指数的科学计数法打印数字。默认的精度为 6。 ‘E’ 指数表示。与 ’e’ 相似，不同之处在于它使用大写字母’E’ 作为分隔字符。 ‘f’ 定点表示。将数字显示为一个定点数。默认的精确度为 6。 ‘F’ 定点表示。与 ‘f’ 相似，但会将 nan 转为 NAN 并将 inf 转为 INF。 ‘g’ 常规格式。对于给定的精度 p \u003e= 1，这会将数值舍入到 p 位有效数字，再将结果以定点格式或科学计数法进行格式化，具体取决于其值的大小。 ‘G’ 常规格式。类似于 ‘g’，不同之处在于当数值非常大时会切换为 ‘E’。无穷与 NaN 也会表示为大写形式。 ’n’ 数字。这与 ‘g’ 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。 ‘%’ 百分比。将数字乘以 100 并显示为定点 (‘f’) 格式，后面带一个百分号。 ",
    "description": "",
    "tags": null,
    "title": "str.format 格式化",
    "uri": "/python/02_string/25_str.format/"
  },
  {
    "content": "内置函数 hasattr()，Python 官方文档描述如下：\nhelp(hasattr) Help on built-in function hasattr in module builtins:\rhasattr(obj, name, /)\rReturn whether the object has an attribute with the given name.\rThis is done by calling getattr(obj, name) and catching AttributeError.\r该函数实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 True，否则返回 False。\nhasattr('abc', 'join') True\rclass A: y = 1 hasattr(A, 'y') True\r",
    "description": "",
    "tags": null,
    "title": "hasattr() 是对象的属性吗？",
    "uri": "/python/11_built-in_function/26_hasattr/"
  },
  {
    "content": "字符串方法 str.format_map()，Python 官方文档描述如下：\nhelp(str.format_map) Help on method_descriptor:\rformat_map(...)\rS.format_map(mapping) -\u003e str\rReturn a formatted version of S, using substitutions from mapping.\rThe substitutions are identified by braces ('{' and '}').\r类似于 str.format(**mapping)，不同之处在于 mapping 会被直接使用。适宜使用此方法的一个例子是当 mapping 为 dict 的子类的情况：\n# 创建一个字典子类型，当 键值对 不存在时，返回键 class Default(dict): def __missing__(self, key): return key d = Default(a=1) d['a'], d['b'] (1, 'b')\r# country 键值对不存在，所以直接格式化键 ‘country’ '{name} was born in {country}'.format_map( Default(name='Guido')) 'Guido was born in country'\r与 format 格式化对比：\n'{a} is {age}'.format_map({'a':'A', 'age':18}) 'A is 18'\r'{a} is {age}'.format(**{'a':'A', 'age':18}) 'A is 18'\r",
    "description": "",
    "tags": null,
    "title": "str.format_map 格式化",
    "uri": "/python/02_string/26_str.format_map/"
  },
  {
    "content": "f-string 即格式化字符串字面值。字符串以 ‘f’ 或 ‘F’ 为前缀。这种字符串可包含替换字段，即以 {} 标示的表达式。格式化字符串字面值，会在运行时将表达式求值，而其他字符串字面值总是一个常量。\n格式化字符串字面值中的表达式会被当作包含在圆括号中的普通 Python 表达式一样处理，但有少数例外。\n空表达式不被允许，lambda 和赋值表达式 :=（python 3.8版添加）必须显式地加上圆括号。\nf'{(a := 1+1)}' # python 3.8 才能运行 '2'\rf'{(lambda x:1)}' '\u003cfunction \u003clambda\u003e at 0x000001D70B06CA60\u003e'\r替换表达式可以包含换行（例如在三重引号字符串中），但是不能包含注释。\na = 3; b = 2 f'''3+2\\ -5= {a + b - 5}''' '3+2-5=\\n0'\r每个表达式会在格式化字符串字面值所包含的位置按照从左至右的顺序被求值。\nf'{1+2 \u003e 3}' 'False'\r可以在表达式后加一个等于号 ‘=’（3.8 新版功能），提供了等于号 ‘=’ 的时候，输出将包含 ‘=’、’=’ 前后的空格以及求值结果。默认情况下，’=’ 会导致表达式的 repr() 被使用，除非专门指定了格式。\nfoo = \"bar\" f\"{ foo = }\" \" foo = 'bar'\"\r可以带一个以叹号 ‘!’ 标示的转换字段，转换符 ‘!s’ 即对结果调用 str()，’!r’ 为调用 repr()，而 ‘!a’ 为调用 ascii()。\nfoo = \"bar\" f\"{foo = !s}\" 'foo = bar'\r还可带一个以冒号 ‘:’ 标示的格式说明符，“格式化迷你语言” 与 str.format() 方法所使用的微语言一致，详见 str.format 方法。\nfoo = 3.14 f\"{foo:.4f}\" '3.1400'\rf'{123:#o}' '0o173'\ra=5/6 f'{a:.2%}' '83.33%'\r格式表达式中不允许有反斜杠，这会引发错误:\nf\"newline: {ord('\\n')}\" File \"\u003cipython-input-23-30c78f70325d\u003e\", line 1\rf\"newline: {ord('\\n')}\"\r^\rSyntaxError: f-string expression part cannot include a backslash\r想包含需要用反斜杠转义的值，可以创建一个临时变量:\nnewline = ord('\\n') f\"newline: {newline}\" 'newline: 10'\r格式化字符串字面值不可用作文档字符串，即便其中没有包含表达式:\ndef foo(): f\"Not a docstring\" print(foo.__doc__) None\r",
    "description": "",
    "tags": null,
    "title": "f-string 格式化字符串",
    "uri": "/python/02_string/27_f-string/"
  },
  {
    "content": "内置函数 hash()，Python 官方文档描述如下：\nhelp(hash) Help on built-in function hash in module builtins:\rhash(obj, /)\rReturn the hash value for the given object.\rTwo objects that compare equal must also have the same hash value, but the\rreverse is not necessarily true.\r返回对象的哈希值（如果它有的话）。哈希值是整数。它们在集合或字典查找元素时用来快速比较集合的元素或字典的键。相同大小的数字有相同的哈希值。\n可哈希对象必须具有相同的哈希值比较结果才会相同。\nhash(1) == hash(1.0) == hash(True) True\r1 == 1.0 == True True\rhash('abc') 2812132477407752679\rhash((1,2,3)) 529344067295497451\rhash([1,2,3]) ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-5-35e31e935e9e\u003e in \u003cmodule\u003e\r----\u003e 1 hash([1,2,3])\rTypeError: unhashable type: 'list'\rhash((1,2)) ",
    "description": "",
    "tags": null,
    "title": "hash() 返回对象的哈希值",
    "uri": "/python/11_built-in_function/27_hash/"
  },
  {
    "content": "内置函数（帮助系统）help，Python 官方文档描述如下：\nhelp(help) Help on _Helper in module _sitebuiltins object:\rclass _Helper(builtins.object)\r| Define the builtin 'help'.\r| | This is a wrapper around pydoc.help that provides a helpful message\r| when 'help' is typed at the Python interactive prompt.\r| | Calling help() at the Python prompt starts an interactive help session.\r| Calling help(thing) prints help for the python object 'thing'.\r| | Methods defined here:\r| | __call__(self, *args, **kwds)\r| Call self as a function.\r| | __repr__(self)\r| Return repr(self).\r| | ----------------------------------------------------------------------\r| Data descriptors defined here:\r| | __dict__\r| dictionary for instance variables (if defined)\r| | __weakref__\r| list of weak references to the object (if defined)\r启动内置的帮助系统（此函数主要在交互式中使用）。\n如果没有实参，解释器控制台里会启动交互式帮助系统。\n如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。\n如果实参是其他任意对象，则会生成该对象的帮助页。\ntype(help) _sitebuiltins._Helper\rhelp() Welcome to Python 3.8's help utility!\rIf this is your first time using Python, you should definitely check out\rthe tutorial on the Internet at https://docs.python.org/3.8/tutorial/.\rEnter the name of any module, keyword, or topic to get help on writing\rPython programs and using Python modules. To quit this help utility and\rreturn to the interpreter, just type \"quit\".\rTo get a list of available modules, keywords, symbols, or topics, type\r\"modules\", \"keywords\", \"symbols\", or \"topics\". Each module also comes\rwith a one-line summary of what it does; to list the modules whose name\ror summary contain a given string such as \"spam\", type \"modules spam\".\rhelp\u003e print\rHelp on built-in function print in module builtins:\rprint(...)\rprint(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\rPrints the values to a stream, or to sys.stdout by default.\rOptional keyword arguments:\rfile: a file-like object (stream); defaults to the current sys.stdout.\rsep: string inserted between values, default a space.\rend: string appended after the last value, default a newline.\rflush: whether to forcibly flush the stream.\rhelp\u003e q\rYou are now leaving help and returning to the Python interpreter.\rIf you want to ask for help on a particular object directly from the\rinterpreter, you can type \"help(object)\". Executing \"help('string')\"\rhas the same effect as typing a particular string at the help\u003e prompt.\rhelp('list.append') Help on method_descriptor in list:\rlist.append = append(self, object, /)\rAppend object to the end of the list.\rhelp(list.append) Help on method_descriptor:\rappend(self, object, /)\rAppend object to the end of the list.\r",
    "description": "",
    "tags": null,
    "title": "help 启动帮助系统",
    "uri": "/python/11_built-in_function/28_help/"
  },
  {
    "content": "操作符 * 操作符 * 可以实现将字符串重复 n（整数）遍相连接：\n'Python' * 3 'PythonPythonPython'\rn 是小于 1 的整数，则得到空字符串：\n'Python' * -1 ''\r* 操作符可以与 = 连用，重复拼接并赋值：\na = 'py' a *= 3 a 'pypypy'\r由于字符串是可迭代对象，因此可以使用 * 对字符串进行拆包：\n(*'Python',) ('P', 'y', 't', 'h', 'o', 'n')\r操作符 % 字符串使用 % 操作符，官方文档叫 “printf 风格的字符串格式化”。比较早的格式化方法，官方已不推荐使用，了解它能更好地读懂别人的代码。\n转换标记符包含两个或更多字符并具有以下组成，且必须遵循如下规定的顺序：\n‘%’ 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成。 转换旗标（可选），用于影响某些转换类型的结果。 最小字段宽度（可选）。如果指定为 ‘*’ (星号)，则实际宽度会从 values 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。 精度（可选），以在 ‘.’ (点号) 之后加精度值的形式给出。如果指定为 ‘*’ (星号)，则实际精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。 长度修饰符（可选）。 转换类型。 'hi %r' % 'python' \"hi 'python'\"\r'%s %r' % ('hi','python') \"hi 'python'\"\r转换旗标为：\n标志 含义 ‘#’ 值的转换将使用“替代形式”。 ‘0’ 转换将为数字值填充零字符。 ‘-’ 转换值将靠左对齐（如果同时给出 ‘0’ 转换，则会覆盖后者）。 ’ ' (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。 ‘+’ 符号字符 (’+’ 或 ‘-’) 将显示于转换结果的开头（会覆盖 ”空格” 旗标）。 'A is %#x' % 18 'A is 0x12'\r'A is % d' % 18 'A is 18'\r'A is %05o' % 18 'A is 00022'\r转换类型为：\n转换符 含义 ’d’ 有符号十进制整数。 ‘i’ 有符号十进制整数。 ‘o’ 有符号八进制数。 ‘x’ 有符号十六进制数（小写）。 ‘X’ 有符号十六进制数（大写）。 ’e’ 浮点指数格式（小写）。 ‘E’ 浮点指数格式（大写）。 ‘f’ 浮点十进制格式。 ‘F’ 浮点十进制格式。 ‘g’ 浮点格式。如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。 ‘G’ 浮点格式。如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。 ‘c’ 单个字符（接受整数或单个字符的字符串）。 ‘r’ 字符串（使用repr() 转换任何 Python 对象）。 ’s’ 字符串（使用str() 转换任何 Python 对象）。 ‘a’ 字符串（使用ascii() 转换任何 Python 对象）。 ‘%’ 不转换参数，在结果中输出一个 ‘%’ 字符。 '%f' % 3.14 '3.140000'\r'%.3e' % 3.14 '3.140e+00'\r'%.1f%%' % (3.14*100) '314.0%'\r当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 必须包含加圆括号的映射键，对应 % 字符之后字典中的每一项。映射键将从映射中选取要格式化的值:\n'%(language)s has %(number)03d quote types.' %\\ {'language': \"Python\", \"number\": 2} 'Python has 002 quote types.'\r",
    "description": "",
    "tags": null,
    "title": "字符串操作符",
    "uri": "/python/02_string/28_string_operators/"
  },
  {
    "content": "内置函数 hex()，Python 官方文档描述如下：\nhelp(hex) Help on built-in function hex in module builtins:\rhex(number, /)\rReturn the hexadecimal representation of an integer.\r\u003e\u003e\u003e hex(12648430)\r'0xc0ffee'\r将整数转换为以 0x 为前缀的小写十六进制整数的字符串形式。\nhex(123) '0x7b'\r0x7b 123\r",
    "description": "",
    "tags": null,
    "title": "hex() 整数的十六进制形式",
    "uri": "/python/11_built-in_function/29_hex/"
  },
  {
    "content": "字符串方法 str.encode()，Python 官方文档描述如下：\nhelp(str.encode) Help on method_descriptor:\rencode(self, /, encoding='utf-8', errors='strict')\rEncode the string using the codec registered for encoding.\rencoding\rThe encoding in which to encode the string.\rerrors\rThe error handling scheme to use for encoding errors.\rThe default is 'strict' meaning that encoding errors raise a\rUnicodeEncodeError. Other possible values are 'ignore', 'replace' and\r'xmlcharrefreplace' as well as any other name registered with\rcodecs.register_error that can handle UnicodeEncodeErrors.\r返回原字符串编码为字节串对象的版本。默认编码为 ‘utf-8’。可以给出 errors 来设置不同的错误处理方案。errors 的默认值为 ‘strict’，表示编码错误会引发 UnicodeError。\n下列为 ‘utf-8’ 和 ‘gbk’ 两种编码比较：\n'嗨 python'.encode() b'\\xe5\\x97\\xa8 python'\r'嗨 python'.encode('gbk') b'\\xe0\\xcb python'\r'▲ python'.encode('gbk') b'\\xa1\\xf8 python'\r'🔺 python'.encode() b'\\xf0\\x9f\\x94\\xba python'\r'🔺 python'.encode('gbk') #gbk 不能编码 🔺 ---------------------------------------------------------------------------\rUnicodeEncodeError Traceback (most recent call last)\r\u003cipython-input-15-60e87a9208be\u003e in \u003cmodule\u003e\r----\u003e 1 '🔺 python'.encode('gbk')\rUnicodeEncodeError: 'gbk' codec can't encode character '\\U0001f53a' in position 0: illegal multibyte sequence\r拓展：\n将字节串解码为字符串用 bytes.decode:\nhelp(bytes.decode) \u001b[1;31mSignature:\u001b[0m \u001b[0mbytes\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdecode\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m/\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mencoding\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'utf-8'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0merrors\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'strict'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\r\u001b[1;31mDocstring:\u001b[0m\rDecode the bytes using the codec registered for encoding.\rencoding\rThe encoding with which to decode the bytes.\rerrors\rThe error handling scheme to use for the handling of decoding errors.\rThe default is 'strict' meaning that decoding errors raise a\rUnicodeDecodeError. Other possible values are 'ignore' and 'replace'\ras well as any other name registered with codecs.register_error that\rcan handle UnicodeDecodeErrors.\r\u001b[1;31mType:\u001b[0m method_descriptor\rb'\\xf0\\x9f\\x94\\xba python'.decode() '🔺 python'\r",
    "description": "",
    "tags": null,
    "title": "str.encode 编码为字节串",
    "uri": "/python/02_string/29_str.encode/"
  },
  {
    "content": "内置函数 id()，Python 官方文档描述如下：\nhelp(id) Help on built-in function id in module builtins:\rid(obj, /)\rReturn the identity of an object.\rThis is guaranteed to be unique among simultaneously existing objects.\r(CPython uses the object's memory address.)\r返回对象的唯一标识。该标识是一个整数，在此对象的生命周期中保证是唯一且恒定的。\nCPython 中该标识是对象的内存地址。\nid(1), id(1.0) (140736642126656, 2785998726512)\r1 == 1.0 True\r# 两个变量引用了同一个值为 1 的对象 a = 1 b = int('01') id(a), id(b) (140736642126656, 140736642126656)\r# 两个值为 1000 的不同对象 a = 1000 b = 1000 id(a), id(b) (2785998745552, 2785998745360)\r# 可变对象改变值，还是同一个对象 _list = [1,2,3] print(id(_list),_list) del _list[:] print(id(_list),_list) 2785999307336 [1, 2, 3]\r2785999307336 []\r",
    "description": "",
    "tags": null,
    "title": "id() 返回对象的唯一标识",
    "uri": "/python/11_built-in_function/30_id/"
  },
  {
    "content": "字符串方法 str.capitalize()，Python 官方文档描述如下：\nhelp(str.capitalize) Help on method_descriptor:\rcapitalize(self, /)\rReturn a capitalized version of the string.\rMore specifically, make the first character have upper case and the rest lower\rcase.\r返回原字符串的副本，其首个字符大写，其余为小写:\n'pyTHON'.capitalize() 'Python'\r只有首个字符是字母，才会将首个字符大写：\n'嗨 pyTHON'.capitalize() '嗨 python'\r",
    "description": "",
    "tags": null,
    "title": "str.capitalize 首字符大写",
    "uri": "/python/02_string/30_str.capitalize/"
  },
  {
    "content": "内置函数 input()，Python 官方文档描述如下：\nhelp(input) Help on method raw_input in module ipykernel.kernelbase:\rraw_input(prompt='') method of ipykernel.ipkernel.IPythonKernel instance\rForward raw_input to frontends\rRaises\r------\rStdinNotImplentedError if active frontend doesn't support stdin.\r如果存在 prompt 实参，则作为提示信息输出。接下来，该函数将输入转换为字符串并返回。无输入则返回空字符串。\ninput('输入提示：') 输入提示： 1+1\r'1+1'\rinput('输入提示：') 输入提示： ''\r",
    "description": "",
    "tags": null,
    "title": "input() 接受输入返回字符串",
    "uri": "/python/11_built-in_function/31_input/"
  },
  {
    "content": "字符串方法 str.casefold()，Python 官方文档描述如下：\nhelp(str.casefold) Help on method_descriptor:\rcasefold(self, /)\rReturn a version of the string suitable for caseless comparisons.\r返回原字符串消除大小写的副本。消除大小写的字符串可用于忽略大小写的匹配。\n消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。例如，德语小写字母 ‘ß’ 相当于 “ss”，由于它已经是小写，lower() 不会对 ‘ß’ 做任何改变，而 casefold() 则会将其转换为 “ss”。\n'pYthOn'.casefold() 'python'\r'ß'.casefold() 'ss'\r'ß'.lower() 'ß'\r",
    "description": "",
    "tags": null,
    "title": "str.casefold 消除大小写",
    "uri": "/python/02_string/31_str.casefold/"
  },
  {
    "content": "内置函数（类）int，Python 官方文档描述如下：\nhelp(int) Help on class int in module builtins:\rclass int(object)\r| int([x]) -\u003e integer\r| int(x, base=10) -\u003e integer\r| | Convert a number or string to an integer, or return 0 if no arguments\r| are given. If x is a number, return x.__int__(). For floating point\r| numbers, this truncates towards zero.\r| | If x is not a number or if base is given, then x must be a string,\r| bytes, or bytearray instance representing an integer literal in the\r| given base. The literal can be preceded by '+' or '-' and be surrounded\r| by whitespace. The base defaults to 10. Valid bases are 0 and 2-36.\r| Base 0 means to interpret the base from the string as an integer literal.\r| \u003e\u003e\u003e int('0b100', base=0)\r| 4\r| | Built-in subclasses:\r| bool\r| 将一个数字，字符串或字节串转换为整数。参数说明：\n不给参数返回整数 0。 参数 x 为数字时，不能有参数 base，且数字不能是复数。浮点数将取整。 参数 x 为字符串或字节串，参数 base 可选，默认按十进制转换，否则按照 base 指定进制转换。 base 取值范围为 0 和 2~36。 base 取 0 将按照参数 x 的字面量来精确解释。取其他数字则需符合相应进制规则。 字符串或字节串不能是浮点数形式；前面可以有正负号；前后可以有空格，中间则不能有空格。 type(int) type\rint() 0\rint(3.18e01), int(10), int(0x10) (31, 10, 16)\rint(' -10 '), int(b' +10') (-10, 10)\rint('10',2), int('10',8), int('z',36) (2, 8, 35)\rint('001'), int('0b10',0) (1, 2)\rint('001',0) # 001 不是合法的整数 ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-12-1cf9048a8c3e\u003e in \u003cmodule\u003e\r----\u003e 1 int('001',0)\rValueError: invalid literal for int() with base 0: '001'\rint('9', 8) # 8 进制没有 9 ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-13-3558097bd025\u003e in \u003cmodule\u003e\r----\u003e 1 int('9', 8)\rValueError: invalid literal for int() with base 8: '9'\rint('3.14') # 不能是浮点数形式 ---------------------------------------------------------------------------\rValueError Traceback (most recent call last)\r\u003cipython-input-14-1456603af047\u003e in \u003cmodule\u003e\r----\u003e 1 int('3.14')\rValueError: invalid literal for int() with base 10: '3.14'\r",
    "description": "",
    "tags": null,
    "title": "int 创建整数",
    "uri": "/python/11_built-in_function/32_int/"
  },
  {
    "content": "字符串方法 str.lower()，Python 官方文档描述如下：\nhelp(str.lower) Help on method_descriptor:\rlower(self, /)\rReturn a copy of the string converted to lowercase.\r返回原字符串的副本，其所有区分大小写的字符均转换为小写。\n'PyThon'.lower() 'python'\r'嗨 PyThon'.lower() '嗨 python'\r'PyThon Γ'.lower() 'python γ'\r",
    "description": "",
    "tags": null,
    "title": "str.lower 转小写",
    "uri": "/python/02_string/32_str.lower/"
  },
  {
    "content": "内置函数 isinstance()，Python 官方文档描述如下：\nhelp(isinstance) Help on built-in function isinstance in module builtins:\risinstance(obj, class_or_tuple, /)\rReturn whether an object is an instance of a class or of a subclass thereof.\rA tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\rcheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\ror ...`` etc.\r如果对象 obj 是给定类的实例或者是其 (直接、间接或虚拟) 子类的实例则返回 True，不是则返回 False。给定的不是类则引发 TypeError 异常。\n给定类可以以元组形式传参，obj 是其中任何一个类型的实例就返回 True。\nisinstance(1, int) True\risinstance('abc', (float, complex)) False\r# bool 是 int 的子类型，但不是实例 isinstance(bool, int) False\r# True 是 int 的子类的实例 isinstance(True, int) True\r# bool 的实例只有 True 和 False isinstance(1, bool) False\r# 所有的对象都是 object 的实例 isinstance(object, object) True\rimport random # 模块 class A:pass # 自定义类 isinstance(1, object),\\ isinstance(int, object),\\ isinstance(list, object),\\ isinstance(random, object),\\ isinstance(A, object) (True, True, True, True, True)\r",
    "description": "",
    "tags": null,
    "title": "isinstance() 是给定类的实例？",
    "uri": "/python/11_built-in_function/33_isinstance/"
  },
  {
    "content": "字符串方法 str.title()，Python 官方文档描述如下：\nhelp(str.title) Help on method_descriptor:\rtitle(self, /)\rReturn a version of the string where each word is titlecased.\rMore specifically, words start with uppercased characters and all remaining\rcased characters have lower case.\r返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。\n'hi python'.title() 'Hi Python'\r'嗨python'.title() '嗨Python'\r该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:\n\"they're bill's friends from the UK\".title() \"They'Re Bill'S Friends From The Uk\"\r",
    "description": "",
    "tags": null,
    "title": "str.title 单词首字母大写",
    "uri": "/python/02_string/33_str.title/"
  },
  {
    "content": "内置函数 issubclass()，Python 官方文档描述如下：\nhelp(issubclass) Help on built-in function issubclass in module builtins:\rissubclass(cls, class_or_tuple, /)\rReturn whether 'cls' is a derived from another class or is the same class.\rA tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\rcheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\ror ...`` etc.\r如果类 cls 是给定类的 (直接、间接或虚拟) 子类则返回 True，不是则返回 False。给定的不是类则引发 TypeError 异常。\n给定类可以以元组形式传参，cls 是其中任何一个类的子类就返回 True。\nissubclass(1, int) # 1 不是类 ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-2-257e7a8dbb04\u003e in \u003cmodule\u003e\r----\u003e 1 issubclass(1, int)\rTypeError: issubclass() arg 1 must be a class\rissubclass(bool, int) True\rissubclass(bool, (set, str, list)) False\r# 所有的类都是 object 的子类 class A:pass issubclass(A, object),\\ issubclass(str, object),\\ issubclass(object, object) (True, True, True)\r",
    "description": "",
    "tags": null,
    "title": "issubclass() 是给定类的子类吗？",
    "uri": "/python/11_built-in_function/34_issubclass/"
  },
  {
    "content": "字符串方法 str.upper()，Python 官方文档描述如下：\nhelp(str.upper) Help on method_descriptor:\rupper(self, /)\rReturn a copy of the string converted to uppercase.\r返回原字符串的副本，其中所有区分大小写的字符均转换为大写。\n'嗨python'.upper() '嗨PYTHON'\r'πpython'.upper() 'ΠPYTHON'\r",
    "description": "",
    "tags": null,
    "title": "str.upper 转大写",
    "uri": "/python/02_string/34_str.upper/"
  },
  {
    "content": "内置函数 iter()，Python 官方文档描述如下：\nhelp(iter) Help on built-in function iter in module builtins:\riter(...)\riter(iterable) -\u003e iterator\riter(callable, sentinel) -\u003e iterator\rGet an iterator from an object. In the first form, the argument must\rsupply its own iterator, or be a sequence.\rIn the second form, the callable is called until it returns the sentinel.\r将一个可迭代对象（iterable）或可调用对象（callable）转换为一个迭代器。\n当参数是可调用对象时，需要提供参数 sentinel，生成的迭代器，每次 迭代时都会不带实参地调用 callable，返回 sentinel 时则触 发 StopIteration。\na = iter('abcd') a \u003cstr_iterator at 0x1c7eea4f910\u003e\rnext(a),next(a),next(a),next(a) ('a', 'b', 'c', 'd')\ra = iter(int, 1) for i in range(3): print(next(a)) 0\r0\r0\ra = iter(int, 0) next(a) ---------------------------------------------------------------------------\rStopIteration Traceback (most recent call last)\r\u003cipython-input-21-694e44f6d78c\u003e in \u003cmodule\u003e\r1 a = iter(int, 0)\r----\u003e 2 next(a)\rStopIteration: ",
    "description": "",
    "tags": null,
    "title": "iter() 转迭代器",
    "uri": "/python/11_built-in_function/35_iter/"
  },
  {
    "content": "字符串方法 str.swapcase()，Python 官方文档描述如下：\nhelp(str.swapcase) Help on method_descriptor:\rswapcase(self, /)\rConvert uppercase characters to lowercase and lowercase characters to uppercase.\r返回原字符串的副本，其中大写字符转换为小写，反之亦然。请注意 s.swapcase().swapcase() == s 并不一定为真值。\n'PythoN'.swapcase() 'pYTHOn'\r'pYTHOn'.swapcase() 'PythoN'\r'ß'.swapcase() # 德语的小写字母 ß 相当于 ss 'SS'\r'SS'.swapcase() 'ss'\r'ß'.swapcase().swapcase() == 'ß' False\r",
    "description": "",
    "tags": null,
    "title": "str.swapcase 大小写互转",
    "uri": "/python/02_string/35_str.swapcase/"
  },
  {
    "content": "内置函数 len()，Python 官方文档描述如下：\nhelp(len) Help on built-in function len in module builtins:\rlen(obj, /)\rReturn the number of items in a container.\r返回对象的长度（元素个数）。实参可以是序列（如 str、bytes、tuple、list 或 range 等的实例），集合（set 或 frozenset 的实例），或字典（dict 的实例）等。\nlen('123') 3\rlen('嗨') 1\rlen('嗨'.encode()) 3\rlen([1,2,3]) 3\rlen({'a':1,'b':2}) 2\r",
    "description": "",
    "tags": null,
    "title": "len() 返回元素个数",
    "uri": "/python/11_built-in_function/36_len/"
  },
  {
    "content": "字符串方法 str.zfill()，Python 官方文档描述如下：\nhelp(str.zfill) Help on method_descriptor:\rzfill(self, width, /)\rPad a numeric string with zeros on the left, to fill a field of the given width.\rThe string is never truncated.\r返回原字符串的副本，在左边填充 ASCII ‘0’ 数码使其长度变为 width。正负值前缀 (’+’/’-’) 的处理方式是在正负符号 之后填充而非在之前。如果 width 小于等于 len(str) 则返回原字符串的副本。\n\"42a\".zfill(5) '0042a'\r\"-42\".zfill(5) '-0042'\r\"-42\".zfill(1) '-42'\r",
    "description": "",
    "tags": null,
    "title": "str.zfill 填充 0",
    "uri": "/python/02_string/36_str.zfill/"
  },
  {
    "content": "内置函数（类）list，Python 官方文档描述如下：\nhelp(list) Help on class list in module builtins:\rclass list(object)\r| list(iterable=(), /)\r| | Built-in mutable sequence.\r| | If no argument is given, the constructor creates a new empty list.\r| The argument must be an iterable if specified.\r| 将一个可迭代对象转为列表。不传参数将得到空列表。\ntype(list) type\rlist() []\rlist('123') ['1', '2', '3']\rlist({'a':1,'b':2}) ['a', 'b']\r",
    "description": "",
    "tags": null,
    "title": "list 创建列表",
    "uri": "/python/11_built-in_function/37_list/"
  },
  {
    "content": "文档描述如下：\nhelp(str.translate) Help on method_descriptor:\rtranslate(self, table, /)\rReplace each character in the string using the given translation table.\rtable\rTranslation table, which must be a mapping of Unicode ordinals to\rUnicode ordinals, strings, or None.\rThe table must implement lookup/indexing via __getitem__, for instance a\rdictionary or list. If this operation raises LookupError, the character is\rleft untouched. Characters mapped to None are deleted.\r返回原字符串的副本，其中每个字符按给定的转换表进行映射。转换表必须是一个使用 __getitem__() 来实现索引操作的对象，通常为 mapping 或 sequence。当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 None，将字符从结果字符串中删除；或引发 LookupError 异常，将字符映射为其自身。\nord('p'),ord('C') (112, 67)\r'python'.translate({112:67}) 'Cython'\r'python'.translate({112:'Cp'}) 'Cpython'\r'python'.translate({112:None}) 'ython'\r你可以使用 str.maketrans() 基于不同格式的字符到字符映射来创建一个转换映射表。\ntable = str.maketrans('pto','123') 'python'.translate(table) '1y2h3n'\r",
    "description": "",
    "tags": null,
    "title": "str.translate 按表转换",
    "uri": "/python/02_string/37_str.translate/"
  },
  {
    "content": "内置函数 locals()，Python 官方文档描述如下：\nhelp(locals) Help on built-in function locals in module builtins:\rlocals()\rReturn a dictionary containing the current scope's local variables.\rNOTE: Whether or not updates to this dictionary will affect name lookups in\rthe local scope and vice-versa is *implementation dependent* and not\rcovered by any backwards compatibility guarantees.\r返回包含当前作用域的局部变量的字典。在模块层级上，locals() 和 globals() 是同一个字典。\nglobals() 和 locals() 函数各自返回当前的全局和本地字典，因此可以将它们传递给 eval() 或 exec() 来使用。\nlocals() {'__name__': '__main__',\r'__doc__': 'Automatically created module for IPython interactive environment',\r'__package__': None,\r'__loader__': None,\r'__spec__': None,\r'__builtin__': \u003cmodule 'builtins' (built-in)\u003e,\r'__builtins__': \u003cmodule 'builtins' (built-in)\u003e,\r'_ih': ['', 'help(locals)', 'locals()'],\r'_oh': {},\r'_dh': ['D:\\\\Jupyter\\\\xuecn_books\\\\books\\\\xue_python_kp\\\\11_built-in_function'],\r'In': ['', 'help(locals)', 'locals()'],\r'Out': {},\r'get_ipython': \u003cbound method InteractiveShell.get_ipython of \u003cipykernel.zmqshell.ZMQInteractiveShell object at 0x0000023E24AE89B0\u003e\u003e,\r'exit': \u003cIPython.core.autocall.ZMQExitAutocall at 0x23e27368898\u003e,\r'quit': \u003cIPython.core.autocall.ZMQExitAutocall at 0x23e27368898\u003e,\r'_': '',\r'__': '',\r'___': '',\r'_i': 'help(locals)',\r'_ii': '',\r'_iii': '',\r'_i1': 'help(locals)',\r'_i2': 'locals()'}\rdef f(): a = 1 print(locals()) f() {'a': 1}\r",
    "description": "",
    "tags": null,
    "title": "locals() 返回局部变量的字典",
    "uri": "/python/11_built-in_function/38_locals/"
  },
  {
    "content": "字符串方法 str.maketrans()，该方法是一个静态方法（没有 self），Python 官方文档描述如下：\nhelp(str.maketrans) Help on built-in function maketrans:\rmaketrans(x, y=None, z=None, /)\rReturn a translation table usable for str.translate().\rIf there is only one argument, it must be a dictionary mapping Unicode\rordinals (integers) or characters to Unicode ordinals, strings or None.\rCharacter keys will be then converted to ordinals.\rIf there are two arguments, they must be strings of equal length, and\rin the resulting dictionary, each character in x will be mapped to the\rcharacter at the same position in y. If there is a third argument, it\rmust be a string, whose characters will be mapped to None in the result.\r返回一个可供 str.translate() 使用的转换对照表。\n如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串 或 None 的字典。字符键将会被转换为码位序号。\nstr.maketrans({97:'123'}) {97: '123'}\rstr.maketrans({'a':97}) {97: 97}\rstr.maketrans({'a':None}) {97: None}\r如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。\nstr.maketrans('abc','123') {97: 49, 98: 50, 99: 51}\r如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映 射到 None。\nstr.maketrans('ab','12','xy') {97: 49, 98: 50, 120: None, 121: None}\r",
    "description": "",
    "tags": null,
    "title": "str.maketrans 生成转换表",
    "uri": "/python/02_string/38_str.maketrans/"
  },
  {
    "content": "内置函数（类）map，Python 官方文档描述如下：\nhelp(map) Help on class map in module builtins:\rclass map(object)\r| map(func, *iterables) --\u003e map object\r| | Make an iterator that computes the function using arguments from\r| each of the iterables. Stops when the shortest iterable is exhausted.\r| | Methods defined here:\r| | __getattribute__(self, name, /)\r| Return getattr(self, name).\r| | __iter__(self, /)\r| Implement iter(self).\r| | __next__(self, /)\r| Implement next(self).\r| | __reduce__(...)\r| Return state information for pickling.\r| | ----------------------------------------------------------------------\r| Static methods defined here:\r| | __new__(*args, **kwargs) from builtins.type\r| Create and return a new object. See help(type) for accurate signature.\r返回一个将函数 func 应用于 iterable 中每一项并输出其结果的迭代器。\n如果传入了额外的 iterable 参数，func 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。\n当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。\ntype(map) type\ra = map(int, '1234') a \u003cmap at 0x16048be3828\u003e\rlist(a) [1, 2, 3, 4]\rm = map(int,'abc',(16,16)) list(m) [10, 11]\rdef f(x,y): d = {} d[x] = y return d m = map(f,'abc',(1,2)) list(m) [{'a': 1}, {'b': 2}]\r",
    "description": "",
    "tags": null,
    "title": "map 以给定函数转换元素",
    "uri": "/python/11_built-in_function/39_map/"
  },
  {
    "content": "字符串方法 str.isalnum()，Python 官方文档描述如下：\nhelp(str.isalnum) Help on method_descriptor:\risalnum(self, /)\rReturn True if the string is an alpha-numeric string, False otherwise.\rA string is alpha-numeric if all characters in the string are alpha-numeric and\rthere is at least one character in the string.\r如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 True ，否则返回 False 。\n''.isalnum() False\r'python123'.isalnum() True\r'python 123'.isalnum() False\r'γ'.isalnum() True\r",
    "description": "",
    "tags": null,
    "title": "str.isalnum 是字母或数字？",
    "uri": "/python/02_string/39_str.isalnum/"
  },
  {
    "content": "内置函数 max()，Python 官方文档描述如下：\nhelp(max) Help on built-in function max in module builtins:\rmax(...)\rmax(iterable, *[, default=obj, key=func]) -\u003e value\rmax(arg1, arg2, *args, *[, key=func]) -\u003e value\rWith a single iterable argument, return its biggest item. The\rdefault keyword-only argument specifies an object to return if\rthe provided iterable is empty.\rWith two or more arguments, return the largest argument.\r返回可迭代对象中最大的元素，或多个实参中最大的项。参数说明：\n如果只提供了一个位置参数，它必须是可迭代对象（iterable），返回 iterable 中最大的元素，iterable 为空，返回 default。 如果提供了两个及以上的位置参数，则返回最大的位置参数。 如果有多个最大元素，则此函数将返回第一个找到的。 参数 key（可选）指定排序函数，将排序的项都经此函数计算，按计算值取最大的项。 max('3142') '4'\rmax([], default=0) 0\rmax(2,4,3,4) 4\rmax([2,1],[2,1,1]) [2, 1, 1]\rmax(('a','ab','bcd'),key=len) 'bcd'\r",
    "description": "",
    "tags": null,
    "title": "max() 求最大项",
    "uri": "/python/11_built-in_function/40_max/"
  },
  {
    "content": "字符串方法 str.isalpha()，Python 官方文档描述如下：\nhelp(str.isalpha) Help on method_descriptor:\risalpha(self, /)\rReturn True if the string is an alphabetic string, False otherwise.\rA string is alphabetic if all characters in the string are alphabetic and there\ris at least one character in the string.\r如果字符串中的所有字符都是字母，并且至少有一个字符，返回 True ，否则返回 False 。\n字母字符是指那些在 Unicode 字符数据库中定义为 ”Letter” 的字符，即那些具有 ”Lm”、”Lt”、”Lu”、”Ll” 或 ”Lo” 之一的通用类别属性的字符。注意，这与 Unicode 标准中定义的 ”字母” 属性不同。\n此处的字母包括汉字等。\n''.isalpha() False\r'γ'.isalpha() True\r'嗨你好'.isalpha() True\r'嗨！你好'.isalpha() False\r",
    "description": "",
    "tags": null,
    "title": "str.isalpha 是字母（包括汉字等）？",
    "uri": "/python/02_string/40_str.isalpha/"
  },
  {
    "content": "内置函数 min()，Python 官方文档描述如下：\nhelp(min) Help on built-in function min in module builtins:\rmin(...)\rmin(iterable, *[, default=obj, key=func]) -\u003e value\rmin(arg1, arg2, *args, *[, key=func]) -\u003e value\rWith a single iterable argument, return its smallest item. The\rdefault keyword-only argument specifies an object to return if\rthe provided iterable is empty.\rWith two or more arguments, return the smallest argument.\r返回可迭代对象中最小的元素，或多个实参中最小的项。参数说明：\n如果只提供了一个位置参数，它必须是可迭代对象（iterable），返回 iterable 中最小的元素，iterable 为空，返回 default。 如果提供了两个及以上的位置参数，则返回最小的位置参数。 如果有多个最小元素，则此函数将返回第一个找到的。 参数 key（可选）指定排序函数，将排序的项都经此函数计算，按计算值取最小的项。 min('3142') '1'\rmin([], default=0) 0\rmin(2,3,2,4) 2\rmin([2,1],[2,1,1]) [2, 1]\rmin(('a','ab','bcd'),key=len) 'a'\r",
    "description": "",
    "tags": null,
    "title": "min() 求最小项",
    "uri": "/python/11_built-in_function/41_min/"
  },
  {
    "content": "字符串方法 str.isdecimal()，Python 官方文档描述如下：\nhelp(str.isdecimal) Help on method_descriptor:\risdecimal(self, /)\rReturn True if the string is a decimal string, False otherwise.\rA string is a decimal string if all characters in the string are decimal and\rthere is at least one character in the string.\r如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 True，否则返回 False。\n十进制字符指那些可以用来组成 10 进制数字的字符。严格地讲，十进制字符是 Unicode 通用类别 ”Nd” 中的一个字符。\n''.isdecimal() False\r'3.14'.isdecimal() False\r'０1２3'.isdecimal() True\r'5²'.isdecimal() False\r'python'.isdecimal() False\rb'100'.isdecimal() ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-13-52e1682babfd\u003e in \u003cmodule\u003e\r----\u003e 1 b'100'.isdecimal()\rAttributeError: 'bytes' object has no attribute 'isdecimal'\r",
    "description": "",
    "tags": null,
    "title": "str.isdecimal 是十进制字符？",
    "uri": "/python/02_string/41_str.isdecimal/"
  },
  {
    "content": "内置函数 next()，Python 官方文档描述如下：\nhelp(next) Help on built-in function next in module builtins:\rnext(...)\rnext(iterator[, default])\rReturn the next item from the iterator. If default is given and the iterator\ris exhausted, it is returned instead of raising StopIteration.\r返回迭代器（iterator）的下一个元素。如果迭代器耗尽，则返回给定的 default，如果没有默认值则触发 StopIteration。\ni = iter('123') next(i,'迭代结束') '1'\rnext(i,'迭代结束') '2'\rnext(i,'迭代结束') '3'\rnext(i,'迭代结束') '迭代结束'\rnext(i,'迭代结束') '迭代结束'\r",
    "description": "",
    "tags": null,
    "title": "next() 返回迭代器下一个元素",
    "uri": "/python/11_built-in_function/42_next/"
  },
  {
    "content": "字符串方法 str.isdigit()，Python 官方文档描述如下：\nhelp(str.isdigit) Help on method_descriptor:\risdigit(self, /)\rReturn True if the string is a digit string, False otherwise.\rA string is a digit string if all characters in the string are digits and there\ris at least one character in the string.\r如果字符串中的所有字符都是数字，并且至少有一个字符，返回 True ，否则返回 False 。\n数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制数的数字，如 Kharosthi 数。严格地讲，数字是指属性值为 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字符。\n'一'.isdigit() False\r'3.14'.isdigit() False\r'１２３'.isdigit() True\rb'123'.isdigit() True\r'5²'.isdigit() True\r",
    "description": "",
    "tags": null,
    "title": "str.isdigit 是数字？",
    "uri": "/python/02_string/42_str.isdigit/"
  },
  {
    "content": "内置函数（类）object，Python 官方文档描述如下：\nhelp(object) Help on class object in module builtins:\rclass object\r| The most base type\r当被调用时，它不接受任何参数，并返回一个新的无特性实例，并且不能给定任何实例属性。\nobject 是所有类的基类。它具有所有 Python 类实例的通用方法。\ntype(object) type\robject() \u003cobject at 0x1de8bc75170\u003e\rdir(object) ['__class__',\r'__delattr__',\r'__dir__',\r'__doc__',\r'__eq__',\r'__format__',\r'__ge__',\r'__getattribute__',\r'__gt__',\r'__hash__',\r'__init__',\r'__init_subclass__',\r'__le__',\r'__lt__',\r'__ne__',\r'__new__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__setattr__',\r'__sizeof__',\r'__str__',\r'__subclasshook__']\r",
    "description": "",
    "tags": null,
    "title": "object 所有类的基类",
    "uri": "/python/11_built-in_function/43_object/"
  },
  {
    "content": "字符串方法 str.isnumeric()，Python 官方文档描述如下：\nhelp(str.isnumeric) Help on method_descriptor:\risnumeric(self, /)\rReturn True if the string is a numeric string, False otherwise.\rA string is numeric if all characters in the string are numeric and there is at\rleast one character in the string.\r如果字符串中至少有一个字符且所有字符均为数值字符则返回 True，否则返回 False。\n数值字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155, VUL-GAR FRACTION ONE FIFTH。正式的定义为：数值字符就是具有特征属性值 Numeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。\n此处所指数字包括罗马数字，汉字数字等。\n'②'.isnumeric() True\r'3.14'.isnumeric() False\r'5²'.isnumeric() True\r'Ⅷ'.isnumeric() True\r'一'.isnumeric() True\r'壹'.isnumeric() True\r",
    "description": "",
    "tags": null,
    "title": "str.isnumeric 是数值字符？",
    "uri": "/python/02_string/43_str.isnumeric/"
  },
  {
    "content": "内置函数 oct()，Python 官方文档描述如下：\nhelp(oct) Help on built-in function oct in module builtins:\roct(number, /)\rReturn the octal representation of an integer.\r\u003e\u003e\u003e oct(342391)\r'0o1234567'\r将一个整数转换为八进制整数的字符串形式。\noct(123) '0o173'\r0o173 123\roct(0x12) '0o22'\r0x12, 0o22 (18, 18)\r",
    "description": "",
    "tags": null,
    "title": "oct() 整数的八进制形式",
    "uri": "/python/11_built-in_function/44_oct/"
  },
  {
    "content": "字符串方法 str.islower()，Python 官方文档描述如下：\nhelp(str.islower) Help on method_descriptor:\rislower(self, /)\rReturn True if the string is a lowercase string, False otherwise.\rA string is lowercase if all cased characters in the string are lowercase and\rthere is at least one cased character in the string.\r如果字符串中至少有一个区分大小写的字符且此类字符均为小写则返回 True，否则返回 False。\n'嗨'.islower() False\r'嗨 Abc'.islower() False\r'嗨 abc'.islower() True\r",
    "description": "",
    "tags": null,
    "title": "str.islower 是小写？",
    "uri": "/python/02_string/44_str.islower/"
  },
  {
    "content": "内置函数 open()，Python 官方文档描述如下：\nhelp(open) Help on built-in function open in module io:\ropen(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\rOpen file and return a stream. Raise OSError upon failure.\rfile is either a text or byte string giving the name (and the path\rif the file isn't in the current working directory) of the file to\rbe opened or an integer file descriptor of the file to be\rwrapped. (If a file descriptor is given, it is closed when the\rreturned I/O object is closed, unless closefd is set to False.)\rmode is an optional string that specifies the mode in which the file\ris opened. It defaults to 'r' which means open for reading in text\rmode. Other common values are 'w' for writing (truncating the file if\rit already exists), 'x' for creating and writing to a new file, and\r'a' for appending (which on some Unix systems, means that all writes\rappend to the end of the file regardless of the current seek position).\rIn text mode, if encoding is not specified the encoding used is platform\rdependent: locale.getpreferredencoding(False) is called to get the\rcurrent locale encoding. (For reading and writing raw bytes use binary\rmode and leave encoding unspecified.) The available modes are:\r========= ===============================================================\rCharacter Meaning\r--------- ---------------------------------------------------------------\r'r' open for reading (default)\r'w' open for writing, truncating the file first\r'x' create a new file and open it for writing\r'a' open for writing, appending to the end of the file if it exists\r'b' binary mode\r't' text mode (default)\r'+' open a disk file for updating (reading and writing)\r'U' universal newline mode (deprecated)\r========= ===============================================================\rThe default mode is 'rt' (open for reading text). For binary random\raccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\r'r+b' opens the file without truncation. The 'x' mode implies 'w' and\rraises an `FileExistsError` if the file already exists.\rPython distinguishes between files opened in binary and text modes,\reven when the underlying operating system doesn't. Files opened in\rbinary mode (appending 'b' to the mode argument) return contents as\rbytes objects without any decoding. In text mode (the default, or when\r't' is appended to the mode argument), the contents of the file are\rreturned as strings, the bytes having been first decoded using a\rplatform-dependent encoding or using the specified encoding if given.\r'U' mode is deprecated and will raise an exception in future versions\rof Python. It has no effect in Python 3. Use newline to control\runiversal newlines mode.\rbuffering is an optional integer used to set the buffering policy.\rPass 0 to switch buffering off (only allowed in binary mode), 1 to select\rline buffering (only usable in text mode), and an integer \u003e 1 to indicate\rthe size of a fixed-size chunk buffer. When no buffering argument is\rgiven, the default buffering policy works as follows:\r* Binary files are buffered in fixed-size chunks; the size of the buffer\ris chosen using a heuristic trying to determine the underlying device's\r\"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\rOn many systems, the buffer will typically be 4096 or 8192 bytes long.\r* \"Interactive\" text files (files for which isatty() returns True)\ruse line buffering. Other text files use the policy described above\rfor binary files.\rencoding is the name of the encoding used to decode or encode the\rfile. This should only be used in text mode. The default encoding is\rplatform dependent, but any encoding supported by Python can be\rpassed. See the codecs module for the list of supported encodings.\rerrors is an optional string that specifies how encoding errors are to\rbe handled---this argument should not be used in binary mode. Pass\r'strict' to raise a ValueError exception if there is an encoding error\r(the default of None has the same effect), or pass 'ignore' to ignore\rerrors. (Note that ignoring encoding errors can lead to data loss.)\rSee the documentation for codecs.register or run 'help(codecs.Codec)'\rfor a list of the permitted encoding error strings.\rnewline controls how universal newlines works (it only applies to text\rmode). It can be None, '', '\\n', '\\r', and '\\r\\n'. It works as\rfollows:\r* On input, if newline is None, universal newlines mode is\renabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\rthese are translated into '\\n' before being returned to the\rcaller. If it is '', universal newline mode is enabled, but line\rendings are returned to the caller untranslated. If it has any of\rthe other legal values, input lines are only terminated by the given\rstring, and the line ending is returned to the caller untranslated.\r* On output, if newline is None, any '\\n' characters written are\rtranslated to the system default line separator, os.linesep. If\rnewline is '' or '\\n', no translation takes place. If newline is any\rof the other legal values, any '\\n' characters written are translated\rto the given string.\rIf closefd is False, the underlying file descriptor will be kept open\rwhen the file is closed. This does not work when a file name is given\rand must be True in that case.\rA custom opener can be used by passing a callable as *opener*. The\runderlying file descriptor for the file object is then obtained by\rcalling *opener* with (*file*, *flags*). *opener* must return an open\rfile descriptor (passing os.open as *opener* results in functionality\rsimilar to passing None).\ropen() returns a file object whose type depends on the mode, and\rthrough which the standard file operations such as reading and writing\rare performed. When open() is used to open a file in a text mode ('w',\r'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\ra file in a binary mode, the returned class varies: in read binary\rmode, it returns a BufferedReader; in write binary and append binary\rmodes, it returns a BufferedWriter, and in read/write mode, it returns\ra BufferedRandom.\rIt is also possible to use a string or bytearray as a file for both\rreading and writing. For strings StringIO can be used like a file\ropened in a text mode, and for bytes a BytesIO can be used like a file\ropened in a binary mode.\r打开文件 file 并返回对应的文件对象（file object）。\n参数说明：\n1，file 是将要打开的文件的路径（绝对路径或者当前工作目录的相对路径），也可以是要被封装的整数类型文件描述符。（如果是文件描述符，它会随着返回的 I/O 对象关闭而关闭，除非 closefd 被设为 False ）。\n2，mode 是一个可选字符串，用于指定打开文件的模式。默认值是 ‘r’ ，这意味着它以文本模式打开并读取。在文本模式，如果 encoding 没有指定，则根据平台来决定使用的编码（要读取和写入原始字节，请使用二进制模式并不要指定 encoding）。可用的模式有：\n‘r’ 读取（默认） ‘w’ 写入，并先截断文件（会删除原内容），文件不存在则创建 ‘x’ 排它性创建，如果文件已存在则失败 ‘a’ 写入，如果文件存在则在末尾追加，不存在则创建 ‘b’ 二进制模式 ’t’ 文本模式（默认） ‘+’ 打开用于更新（读取与写入） 模式 ‘r’，‘w’，‘x’，‘a’ 可以单独使用，也可与 ‘b’ 或 ‘+’，或两者同时组合使用。‘b’，’t’ 和 ‘+’ 不能单独使用。‘b’ 和 ’t’ 互斥，’t’ 默认省略。\n默认模式为 ‘r’ (打开用于读取文本，与 ‘rt’ 同义)。模式 ‘w+’ 与 ‘w+b’ 打开文件并清空内容。模式 ‘r+’ 与 ‘r+b’ 打开文件并不清空内容。\n以二进制模式打开的文件返回的内容为字节串，不进行任何解码。在文本模式下打开时，文件内容返回为字符串，首先使用指定的 encoding （如果给定）或者使用平台默认的的字节编码解码。\n3，buffering 是一个可选的整数，用于设置缓冲策略。\n4，encoding 是用于解码或编码文件的编码的名称。这应该只在文本模式下使用。\n5，errors 是一个可选的字符串参数，用于指定如何处理编码和解码错误。这不能在二进制模式下使用。\n6，newline 控制通用换行模式如何生效（它仅适用于文本模式）。\n7，如果 closefd 是 False 并且打开文件给出了文件描述符而不是文件名，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出文件名则 closefd 必须为 True （默认值），否则将引发错误。\n8，可以通过传递可调用的 opener 来使用自定义开启器。\nwith open('test.txt') as f: print(f) \u003c_io.TextIOWrapper name='test.txt' mode='r' encoding='cp936'\u003e\rwith open('test.txt',encoding='utf-8') as f: print(f.read()) xue.cn\r自学是门手艺\rwith open('test.txt','rb') as f: print(f.read()) b'xue.cn\\r\\n\\r\\n\\xe8\\x87\\xaa\\xe5\\xad\\xa6\\xe6\\x98\\xaf\\xe9\\x97\\xa8\\xe6\\x89\\x8b\\xe8\\x89\\xba'\r",
    "description": "",
    "tags": null,
    "title": "open() 打开文件",
    "uri": "/python/11_built-in_function/45_open/"
  },
  {
    "content": "字符串方法 str.isupper()，Python 官方文档描述如下：\nhelp(str.isupper) Help on method_descriptor:\risupper(self, /)\rReturn True if the string is an uppercase string, False otherwise.\rA string is uppercase if all cased characters in the string are uppercase and\rthere is at least one cased character in the string.\r如果字符串中至少有一个区分大小写的字符且此类字符均为大写则返回 True，否则返回 False。\n'Γ'.isupper() True\r'嗨 AB'.isupper() True\r'嗨 Ab'.isupper() False\r",
    "description": "",
    "tags": null,
    "title": "str.isupper 是大写？",
    "uri": "/python/02_string/45_str.isupper/"
  },
  {
    "content": "内置函数 ord()，Python 官方文档描述如下：\nhelp(ord) Help on built-in function ord in module builtins:\rord(c, /)\rReturn the Unicode code point for a one-character string.\r返回单个字符 Unicode 码点的整数。这是 chr() 的逆函数。\nord('a') 97\rchr(97) 'a'\r",
    "description": "",
    "tags": null,
    "title": "ord() 返回单个字符 Unicode 码位值",
    "uri": "/python/11_built-in_function/46_ord/"
  },
  {
    "content": "字符串方法 str.istitle()，Python 官方文档描述如下：\nhelp(str.istitle) Help on method_descriptor:\ristitle(self, /)\rReturn True if the string is a title-cased string, False otherwise.\rIn a title-cased string, upper- and title-case characters may only\rfollow uncased characters and lowercase characters only cased ones.\r如果字符串中至少有一个字符且为标题字符串则返回 True，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。否则返回 False。\n'Abc Py'.istitle() True\r'嗨 A11'.istitle() True\r'嗨 Abc'.istitle() True\r'嗨 ABC'.istitle() False\r",
    "description": "",
    "tags": null,
    "title": "str.istitle 是标题字符串？",
    "uri": "/python/02_string/46_str.istitle/"
  },
  {
    "content": "内置函数 pow()，Python 官方文档描述如下：\nhelp(pow) Help on built-in function pow in module builtins:\rpow(base, exp, mod=None)\rEquivalent to base**exp with 2 arguments or base**exp % mod with 3 arguments\rSome types, such as ints, are able to use a more efficient algorithm when\rinvoked using the three argument form.\r返回 base 的 exp 次幂；如果 mod 存在，则返回 base 的 exp 次幂对 mod 取余（比 pow(base, exp) % mod 更高效）。\n对于混用的操作数类型，则将应用双目算术运算符的类型强制转换规则。 对于 int 操作数，结果具有与操作数相同的类型（强制转换后），除非第二个参数为负值；在这种情况下，所有参数将被转换为浮点数并输出浮点数结果。\n对于 int 操作数 base 和 exp，如果给出 mod，则 mod 必须为整数类型并且 mod 必须不为零。如果给出 mod 并且 exp 为负值，则 base 必须相对于 mod 不可整除。在这种情况下，将会返回 pow(inv_base, -exp, mod)，其中 inv_base 为 base 的倒数对 mod 取余。\n在 3.8 版更改: 对于 int 操作数，三参数形式的 pow 现在允许第二个参数为负值，即可以计算倒数的余数；允许关键字参数。\npow(2, 3, 4) 0\rpow(2.0, 3) 8.0\rpow(2, -1) 0.5\rpow(38, -1, 97) # 38 的倒数对 97 取余为 23 23\r23 * 38 % 97 == 1 True\rpow(38, -2, 97), pow(23, 2, 97) (44, 44)\r",
    "description": "",
    "tags": null,
    "title": "pow() 幂运算并取余",
    "uri": "/python/11_built-in_function/47_pow/"
  },
  {
    "content": "字符串方法 str.isascii()，Python 官方文档描述如下：\nhelp(str.isascii) Help on method_descriptor:\risascii(self, /)\rReturn True if all characters in the string are ASCII, False otherwise.\rASCII characters have code points in the range U+0000-U+007F.\rEmpty string is ASCII too.\r如果字符串为空或字符串中的所有字符都是 ASCII ，返回 True，否则返回 False。ASCII 字符的码点范围是 U+0000-U+007F。\n''.isascii() True\r'python'.isascii() True\r'python.3'.isascii() True\r'嗨 python'.isascii() False\r",
    "description": "",
    "tags": null,
    "title": "str.isascii 是 ASCII 字符？",
    "uri": "/python/02_string/47_str.isascii/"
  },
  {
    "content": "内置函数 print()，Python 官方文档描述如下：\nhelp(print) Help on built-in function print in module builtins:\rprint(...)\rprint(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\rPrints the values to a stream, or to sys.stdout by default.\rOptional keyword arguments:\rfile: a file-like object (stream); defaults to the current sys.stdout.\rsep: string inserted between values, default a space.\rend: string appended after the last value, default a newline.\rflush: whether to forcibly flush the stream.\r将 value … 打印到 file 指定的文本流，以 sep 分隔并在末尾加上 end。sep, end, file 和 flush 如果存在，它们必须以关键字参数的形式给出。\n所有非关键字参数都会被转换为字符串，就像是执行了 str() 一样，并会被写入到流。sep 和 end 都必须为字符串。sep 默认为一个空格 ’ ‘，end 默认为换行 ‘\\n’。\n如果没有给出 value …，则 print() 将只打印 end。\nfile 参数必须是一个具有 write(string) 方法的对象。如果参数不指定，则将使用解释器用于标准输出的文件对象 sys.stdout。\n输出是否被缓存通常决定于 file，但如果 flush 关键字参数为真值，流会被强制刷新。\n该函数返回值为 None。\nprint(1+1) print('a','b') 2\ra b\rprint('a',1,int, sep='-', end='end') a-1-\u003cclass 'int'\u003eend\rprint(end='end') end\rp = print('end') print(p) end\rNone\r",
    "description": "",
    "tags": null,
    "title": "print()",
    "uri": "/python/11_built-in_function/48_print/"
  },
  {
    "content": "字符串方法 str.isidentifier()，Python 官方文档描述如下：\nhelp(str.isidentifier) Help on method_descriptor:\risidentifier(self, /)\rReturn True if the string is a valid Python identifier, False otherwise.\rCall keyword.iskeyword(s) to test whether string s is a reserved identifier,\rsuch as \"def\" or \"class\".\r如果字符串是有效的标识符，返回 True，否则返回 False。\n''.isidentifier() False\r'1mycode'.isidentifier() False\r'_mycode'.isidentifier() True\r'123'.isidentifier() False\r'_123'.isidentifier() True\r'变量名'.isidentifier() True\r'for'.isidentifier() True\r",
    "description": "",
    "tags": null,
    "title": "str.isidentifier 是有效标识符？",
    "uri": "/python/02_string/48_str.isidentifier/"
  },
  {
    "content": "内置函数（类）property，Python 官方文档描述如下：\nhelp(property) Help on class property in module builtins:\rclass property(object)\r| property(fget=None, fset=None, fdel=None, doc=None)\r| | Property attribute.\r| | fget\r| function to be used for getting an attribute value\r| fset\r| function to be used for setting an attribute value\r| fdel\r| function to be used for del'ing an attribute\r| doc\r| docstring\r| | Typical use is to define a managed attribute x:\r| | class C(object):\r| def getx(self): return self._x\r| def setx(self, value): self._x = value\r| def delx(self): del self._x\r| x = property(getx, setx, delx, \"I'm the 'x' property.\")\r| | Decorators make defining new properties or modifying existing ones easy:\r| | class C(object):\r| @property\r| def x(self):\r| \"I am the 'x' property.\"\r| return self._x\r| @x.setter\r| def x(self, value):\r| self._x = value\r| @x.deleter\r| def x(self):\r| del self._x\r| 返回 property 属性。\nfget 是获取属性值的函数。fset 是用于设置属性值的函数。fdel 是用于删除属性值的函数，doc 为属性对象创建文档字符串。\ntype(property) type\rdir(property) ['__class__',\r'__delattr__',\r'__delete__',\r'__dir__',\r'__doc__',\r'__eq__',\r'__format__',\r'__ge__',\r'__get__',\r'__getattribute__',\r'__gt__',\r'__hash__',\r'__init__',\r'__init_subclass__',\r'__isabstractmethod__',\r'__le__',\r'__lt__',\r'__ne__',\r'__new__',\r'__reduce__',\r'__reduce_ex__',\r'__repr__',\r'__set__',\r'__setattr__',\r'__sizeof__',\r'__str__',\r'__subclasshook__',\r'deleter',\r'fdel',\r'fget',\r'fset',\r'getter',\r'setter']\r一个典型的用法是定义一个托管属性 x:\n# 列一 class C: def __init__(self,value): self._x = value def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") 如果 c 是 C 的实例，c.x 将调用 getter，c.x = value 将调用 setter，del c.x 将调用 deleter。\n如果给出，doc 将成为该 property 属性的文档字符串。否则该 property 将拷贝 fget 的文档字符串（如果存在）。\nc = C(1) c.x 1\rc.x = 2 c.x 2\rdel c.x c.x ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-16-d32ce31f0255\u003e in \u003cmodule\u003e\r1 del c.x\r----\u003e 2 c.x\r\u003cipython-input-10-eaaa1d84111b\u003e in getx(self)\r4 5 def getx(self):\r----\u003e 6 return self._x\r7 8 def setx(self, value):\rAttributeError: 'C' object has no attribute '_x'\r这令使用 property() 作为装饰器来创建只读的特征属性可以很容易地实现:\nclass Parrot: def __init__(self): self._voltage = 100000 @property def voltage(self): \"\"\"Get the current voltage.\"\"\" return self._voltage 以上 @property 装饰器会将 voltage() 方法转化为一个具有相同名称的只读属性的 getter，并将 voltage 的文档字符串设置为 ‘Get the current voltage.’\np = Parrot() p.voltage 100000\rp.voltage = 100 ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-20-50ba7917c8b5\u003e in \u003cmodule\u003e\r----\u003e 1 p.voltage = 100\rAttributeError: can't set attribute\r特征属性对象具有 getter, setter 以及 deleter 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。\nclass C: def __init__(self,value): self._x = value @property def x(self): \"\"\"I'm the 'x' property.\"\"\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x 上述代码与 例一 完全等价。注意一定要给附加函数与原始的特征属性相同的名称。\nc = C(1) c.x 1\rc.x = 2 c.x 2\rdel c.x c.x ---------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u003cipython-input-7-d32ce31f0255\u003e in \u003cmodule\u003e\r1 del c.x\r----\u003e 2 c.x\r\u003cipython-input-4-356a299284e7\u003e in x(self)\r6 def x(self):\r7 \"\"\"I'm the 'x' property.\"\"\"\r----\u003e 8 return self._x\r9 10 @x.setter\rAttributeError: 'C' object has no attribute '_x'\r",
    "description": "",
    "tags": null,
    "title": "property 返回 property 属性",
    "uri": "/python/11_built-in_function/49_property/"
  },
  {
    "content": "字符串方法 str.isprintable()，Python 官方文档描述如下：\nhelp(str.isprintable) Help on method_descriptor:\risprintable(self, /)\rReturn True if the string is printable, False otherwise.\rA string is printable if all of its characters are considered printable in\rrepr() or if it is empty.\r如果字符串中所有字符均为可打印字符或字符串为空则返回 True，否则返回 False。\n不可打印字符是在 Unicode 字符数据库中被定义为 ”Other” 或 ”Separator” 的字符，例外情况是 ASCII 空格字符 (0x20) 被视作可打印字符。\n请注意在此语境下可打印字符是指当对一个字符串发起调用 repr() 时不必被转义的字符。它们与字符串写入 sys.stdout 或 sys.stderr 时所需的处理无关。\n''.isprintable() True\r' '.isprintable() True\r'\\n'.isprintable() False\r'\\python'.isprintable() True\r'py\\thon'.isprintable() False\r",
    "description": "",
    "tags": null,
    "title": "str.isprintable 是可打印字符？",
    "uri": "/python/02_string/49_str.isprintable/"
  },
  {
    "content": "内置函数（类）range，Python 官方文档描述如下：\nhelp(range) Help on class range in module builtins:\rclass range(object)\r| range(stop) -\u003e range object\r| range(start, stop[, step]) -\u003e range object\r| | Return an object that produces a sequence of integers from start (inclusive)\r| to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1.\r| start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3.\r| These are exactly the valid indices for a list of 4 elements.\r| When step is given, it specifies the increment (or decrement).\r| | Methods defined here:\r| | __bool__(self, /)\r| self != 0\r| | __contains__(self, key, /)\r| Return key in self.\r| | __eq__(self, value, /)\r| Return self==value.\r| | __ge__(self, value, /)\r| Return self\u003e=value.\r| | __getattribute__(self, name, /)\r| Return getattr(self, name).\r| | __getitem__(self, key, /)\r| Return self[key].\r| | __gt__(self, value, /)\r| Return self\u003evalue.\r| | __hash__(self, /)\r| Return hash(self).\r| | __iter__(self, /)\r| Implement iter(self).\r| | __le__(self, value, /)\r| Return self\u003c=value.\r| | __len__(self, /)\r| Return len(self).\r| | __lt__(self, value, /)\r| Return self\u003cvalue.\r| | __ne__(self, value, /)\r| Return self!=value.\r| | __reduce__(...)\r| Helper for pickle.\r| | __repr__(self, /)\r| Return repr(self).\r| | __reversed__(...)\r| Return a reverse iterator.\r| | count(...)\r| rangeobject.count(value) -\u003e integer -- return number of occurrences of value\r| | index(...)\r| rangeobject.index(value, [start, [stop]]) -\u003e integer -- return index of value.\r| Raise ValueError if the value is not present.\r| | ----------------------------------------------------------------------\r| Static methods defined here:\r| | __new__(*args, **kwargs) from builtins.type\r| Create and return a new object. See help(type) for accurate signature.\r| | ----------------------------------------------------------------------\r| Data descriptors defined here:\r| | start\r| | step\r| | stop\r虽然被称为函数，但 range 实际上是一个不可变的序列类型，参见 range 对象。\ntype(range) type\rlist(range(3)) [0, 1, 2]\rlist(range(-5)) []\rlist(range(1,5,2)) [1, 3]\rlist(range(0,-5,-1)) [0, -1, -2, -3, -4]\r",
    "description": "",
    "tags": null,
    "title": "range 创建 range 序列",
    "uri": "/python/11_built-in_function/50_range/"
  },
  {
    "content": "字符串方法 str.isspace()，Python 官方文档描述如下：\nhelp(str.isspace) Help on method_descriptor:\risspace(self, /)\rReturn True if the string is a whitespace string, False otherwise.\rA string is whitespace if all characters in the string are whitespace and there\ris at least one character in the string.\r如果字符串中只有空白字符且至少有一个字符则返回 True，否则返回 False。\n''.isspace() False\r' '.isspace() True\r'\\n\\t\\r\\f'.isspace() True\r' \\\\'.isspace() False\r",
    "description": "",
    "tags": null,
    "title": "str.isspace 是空白字符？",
    "uri": "/python/02_string/50_str.isspace/"
  },
  {
    "content": "内置函数 repr()，Python 官方文档描述如下：\nhelp(repr) Help on built-in function repr in module builtins:\rrepr(obj, /)\rReturn the canonical string representation of the object.\rFor many object types, including most builtins, eval(repr(obj)) == obj.\r返回包含一个对象的可打印表示形式的字符串。\n对于许多类型来说，该函数会尝试返回的字符串将会与该对象被传递给 eval() 时所生成的对象具有相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包含对象类型的名称与通常包括对象名称和地址的附加信息。\nrepr(1+1) '2'\rrepr(int) \"\u003cclass 'int'\u003e\"\rstr('python\\n') 'python\\n'\rrepr('python\\n') \"'python\\\\n'\"\r",
    "description": "",
    "tags": null,
    "title": "repr() 返回对象的可打印字符串",
    "uri": "/python/11_built-in_function/51_repr/"
  },
  {
    "content": "字符串方法 str.removeprefix()。\n3.9 版本新功能。\nstr.removeprefix(prefix, /)，如果字符串以 前缀字符串 prefix 开头，返回 string[len(prefix):]，否则，返回原始字符串的副本。\n'TestHook'.removeprefix('Test') 'Hook'\r'BaseTestCase'.removeprefix('Test') 'BaseTestCase'\r",
    "description": "",
    "tags": null,
    "title": "str.removeprefix  移除前缀",
    "uri": "/python/02_string/51_str.removeprefix/"
  },
  {
    "content": "内置函数（类）reversed，Python 官方文档描述如下：\nhelp(reversed) Help on class reversed in module builtins:\rclass reversed(object)\r| reversed(sequence, /)\r| | Return a reverse iterator over the values of the given sequence.\r| | Methods defined here:\r| | __getattribute__(self, name, /)\r| Return getattr(self, name).\r| | __iter__(self, /)\r| Implement iter(self).\r| | __length_hint__(...)\r| Private method returning an estimate of len(list(it)).\r| | __next__(self, /)\r| Implement next(self).\r| | __reduce__(...)\r| Return state information for pickling.\r| | __setstate__(...)\r| Set state information for unpickling.\r| | ----------------------------------------------------------------------\r| Static methods defined here:\r| | __new__(*args, **kwargs) from builtins.type\r| Create and return a new object. See help(type) for accurate signature.\r返回给定的序列逆置之后的迭代器。\ntype(reversed) type\rreversed('1234') \u003creversed at 0x14b684fe460\u003e\rlist(reversed('1234')) ['4', '3', '2', '1']\r因为字典顺序会确保为插入顺序，字典和字典视图都是可逆的。3.8 新版可以返回一个逆序获取字典键的迭代器。\nd = reversed({'a':1,'b':2,'c':3}) list(d) ['c', 'b', 'a']\r",
    "description": "",
    "tags": null,
    "title": "reversed 序列逆置",
    "uri": "/python/11_built-in_function/52_reversed/"
  },
  {
    "content": "字符串方法 str.removesuffix()。\n3.9 版本新功能。\nstr.removesuffix(suffix, /)，如果字符串以 后缀字符串 suffix 结尾，并且后缀非空，返回 string[:-len(suffix)]，否则，返回原始字符串的副本。\n'MiscTests'.removesuffix('Tests') 'Misc'\r'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin'\r",
    "description": "",
    "tags": null,
    "title": "str.removesuffix 移除后缀",
    "uri": "/python/02_string/52_str.removesuffix/"
  },
  {
    "content": "内置函数 round()，Python 官方文档描述如下：\nhelp(round) Help on built-in function round in module builtins:\rround(number, ndigits=None)\rRound a number to a given precision in decimal digits.\rThe return value is an integer if ndigits is omitted or None. Otherwise\rthe return value has the same type as the number. ndigits may be negative.\r返回 number 舍入到小数点后 ndigits 位精度的值。如果 ndigits 被省略或为 None，则返回最接近输入值的整数。\n对于支持 round() 的内置类型，值会被舍入到最接近的 10 的负 ndigits 次幂的倍数；如果与两个倍数的距离相等，则选择偶数。\n任何整数值都可作为有效的 ndigits (正数、零或负数)。如果 ndigits 被省略或为 None 则返回值将为整数。否则返回值与 number 的类型相同。\n由于大多数十进制小数实际上都不能以浮点数精确地表示。返回值可能会不是预期的四舍五入结果。\nround(3.14) 3\rround(3.14, 3) 3.14\rround(3.14, 0) 3.0\rround(13.14,-1) 10.0\rround(2.5), round(-2.5) (2, -2)\rround(1.5), round(-1.5) (2, -2)\rround(2.675, 2), round(2.665, 2) (2.67, 2.67)\r",
    "description": "",
    "tags": null,
    "title": "round() 数字舍入",
    "uri": "/python/11_built-in_function/53_round/"
  },
  {
    "content": "内置函数（类）set，Python 官方文档描述如下：\nhelp(set) Help on class set in module builtins:\rclass set(object)\r| set() -\u003e new empty set object\r| set(iterable) -\u003e new set object\r| | Build an unordered collection of unique elements.\r| 将一个可迭代对象转换为集合。可迭代对象为空，或不传参数，将得到空集合。\ntype(set) type\rset([]) set()\rset() set()\rset('1231') {'1', '2', '3'}\rset({'1':1, '2':2, '3':3}) {'1', '2', '3'}\r",
    "description": "",
    "tags": null,
    "title": "set 创建集合",
    "uri": "/python/11_built-in_function/54_set/"
  },
  {
    "content": "内置函数 setattr()，Python 官方文档描述如下：\nhelp(setattr) Help on built-in function setattr in module builtins:\rsetattr(obj, name, value, /)\rSets the named attribute on the given object to the specified value.\rsetattr(x, 'y', v) is equivalent to ``x.y = v''\r参数为一个对象、一个字符串和一个任意值。字符串指定一个现有属性或者新增属性。函数会将值赋给该属性，只要对象允许这种操作。\nclass A: y = 1 x = A() x.y 1\r# 为实例 x 新增属性 setattr(x, 'y', 10) x.y 10\rA.y 1\r# 修改类 A 的 y 属性 setattr(A, 'y', 100) A.y 100\rx.y 10\r",
    "description": "",
    "tags": null,
    "title": "setattr() 设置或新增属性",
    "uri": "/python/11_built-in_function/55_setattr/"
  },
  {
    "content": "内置函数（类）slice，Python 官方文档描述如下：\nhelp(slice) Help on class slice in module builtins:\rclass slice(object)\r| slice(stop)\r| slice(start, stop[, step])\r| | Create a slice object. This is used for extended slicing (e.g. a[0:10:2]).\r| 返回一个表示由 range(start, stop, step) 指定索引集的 slice 对象。其中 start 和 step 参数默认为 None。\n切片对象具有仅会返回对应参数值（或其默认值）的只读数据属性 start, stop 和 step。它们没有其他的显式功能。\ntype(slice) type\rs = slice(3) s slice(None, 3, None)\ra = list(range(5)) a[s] [0, 1, 2]\rslice(2,8,2) slice(2, 8, 2)\rlist(range(10)[slice(2,8,2)]) [2, 4, 6]\r",
    "description": "",
    "tags": null,
    "title": "slice 创建切片对象",
    "uri": "/python/11_built-in_function/56_slice/"
  },
  {
    "content": "内置函数 sorted()，Python 官方文档描述如下：\nhelp(sorted) Help on built-in function sorted in module builtins:\rsorted(iterable, /, *, key=None, reverse=False)\rReturn a new list containing all items from the iterable in ascending order.\rA custom key function can be supplied to customize the sort order, and the\rreverse flag can be set to request the result in descending order.\r根据 iterable 中的项返回一个新的已排序列表。\n具有两个可选参数，它们都必须指定为关键字参数。\nkey 指定带有单个参数的函数，应用于 iterable 中的每个元素，将计算结果用来对原 iterable 排序。默认值为 None (直接比较)。\nreverse 为一个布尔值。如果设为 True，则每个列表元素将按反向顺序比较进行排序。\nsorted() 排序确保是稳定的。如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 — 这有利于进行多重排序。\nsorted({'b':1,'a':3,'c':2}) ['a', 'b', 'c']\rd = [{'age':18},{'age':30},{'age':26}] sorted(d,key=lambda x:x['age']) [{'age': 18}, {'age': 26}, {'age': 30}]\rsorted([1.5,'2.0','1.5',3.14], key=float) [1.5, '1.5', '2.0', 3.14]\rsorted('3123', reverse=True) ['3', '3', '2', '1']\r",
    "description": "",
    "tags": null,
    "title": "sorted() 返回排序列表",
    "uri": "/python/11_built-in_function/57_sorted/"
  },
  {
    "content": "内置函数（类）staticmethod，Python 官方文档描述如下：\nhelp(staticmethod) Help on class staticmethod in module builtins:\rclass staticmethod(object)\r| staticmethod(function) -\u003e method\r| | Convert a function to be a static method.\r| | A static method does not receive an implicit first argument.\r| To declare a static method, use this idiom:\r| | class C:\r| @staticmethod\r| def f(arg1, arg2, ...):\r| ...\r| | It can be called either on the class (e.g. C.f()) or on an instance\r| (e.g. C().f()). The instance is ignored except for its class.\r| | Static methods in Python are similar to those found in Java or C++.\r| For a more advanced concept, see the classmethod builtin.\r| 将函数转换为静态方法。\n静态方法不会接收隐式的第一个参数。可以传递一个函数作为参数定义为静态方法，也可以使用装饰器的形式将一个自定义函数定义为静态方法。\ntype(staticmethod) type\rclass A: in_print = staticmethod(print) a = A() a.in_print('静态方法') 静态方法\rclass A: @staticmethod def in_print(value): print(value) a = A() a.in_print('静态方法') 静态方法\r",
    "description": "",
    "tags": null,
    "title": "staticmethod 封装函数为静态方法",
    "uri": "/python/11_built-in_function/58_staticmethod/"
  },
  {
    "content": "内置函数（类）str，Python 官方文档描述如下：\nhelp(str) Help on class str in module builtins:\rclass str(object)\r| str(object='') -\u003e str\r| str(bytes_or_buffer[, encoding[, errors]]) -\u003e str\r| | Create a new string object from the given object. If encoding or\r| errors is specified, then the object must expose a data buffer\r| that will be decoded using the given encoding and error handler.\r| Otherwise, returns the result of object.__str__() (if defined)\r| or repr(object).\r| encoding defaults to sys.getdefaultencoding().\r| errors defaults to 'strict'.\r| 返回对象 object 的字符串形式。如果未提供 object 则返回空字符串。\n如果 encoding 或 errors 至少给出其中之一，则 bytes_or_buffer 应该是一个 bytes-like object (例如字节串或字节数组)。在此情况下，如果是一个字节串 (或字节数组) 对象，则 str(bytes, encoding, errors) 等价于 bytes.decode(encoding, errors)。否则的话，会在调用 bytes.decode() 之前获取缓冲区对象下层的 bytes 对象。\n将一个 bytes 对象传入 str() 而不给出 encoding 或 errors 参数，将直接转 bytes 对象为字符串。\ntype(str) type\rstr() ''\rstr(int) \"\u003cclass 'int'\u003e\"\rstr([1,2,3]) '[1, 2, 3]'\rstr(b'\\xe8\\x87\\xaa\\xe5\\xad\\xa6',encoding='utf-8') '自学'\rb'\\xe8\\x87\\xaa\\xe5\\xad\\xa6'.decode(encoding='utf-8') '自学'\rstr(b'\\xe8\\x87\\xaa\\xe5\\xad\\xa6') \"b'\\\\xe8\\\\x87\\\\xaa\\\\xe5\\\\xad\\\\xa6'\"\r",
    "description": "",
    "tags": null,
    "title": "str 创建字符串",
    "uri": "/python/11_built-in_function/59_str/"
  },
  {
    "content": "内置函数 sum()，Python 官方文档描述如下：\nhelp(sum) Help on built-in function sum in module builtins:\rsum(iterable, start=0, /)\rReturn the sum of a 'start' value (default: 0) plus an iterable of numbers\rWhen the iterable is empty, return the start value.\rThis function is intended specifically for use with numeric values and may\rreject non-numeric types.\r通常对一个以数字为元素的可迭代对象求和并返回和。如果指定 start 参数，和需要加上 start。\nstart 不能为字符串，拼接字符串 sum() 不支持，更好更快的方式是 str.join() 方法。\nsum() 还支持其他序列（列表和元组）。\nsum([1,2,3]) 6\rsum(range(4), 10) 16\rsum([(1,2),(3,4)], (5,)) (5, 1, 2, 3, 4)\rsum([[1,2],[3]],[0]) [0, 1, 2, 3]\r",
    "description": "",
    "tags": null,
    "title": "sum() 数字求和或序列拼接",
    "uri": "/python/11_built-in_function/60_sum/"
  },
  {
    "content": "内置函数（类）super，Python 官方文档描述如下：\nhelp(super) Help on class super in module builtins:\rclass super(object)\r| super() -\u003e same as super(__class__, \u003cfirst argument\u003e)\r| super(type) -\u003e unbound super object\r| super(type, obj) -\u003e bound super object; requires isinstance(obj, type)\r| super(type, type2) -\u003e bound super object; requires issubclass(type2, type)\r| Typical use to call a cooperative superclass method:\r| class C(B):\r| def meth(self, arg):\r| super().meth(arg)\r| This works for class methods too:\r| class C(B):\r| @classmethod\r| def cmeth(cls, arg):\r| super().cmeth(arg)\r| 返回一个代理对象，它会将方法调用委托给类 type 的父类或兄弟类。这对于访问已在类中被重载的继承方法很有用。\nsuper() 和 super(__class__, \u003cfirst argument\u003e) 一样。 如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 isinstance(obj, type) 必须为真值。 如果第二个参数为一个类型，则 issubclass(type2, type) 必须为真值（这适用于类方法）。 super 有两个典型用例：\n在具有单继承的类层级结构中，super 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 第二个用例是在动态执行环境中支持协作多重继承。此用例为 Python 所独有。这使得实现 “菱形图” 成为可能，在这时会有多个基类实现相同的方法。好的设计强制要求这种方法在每个情况下具有相同的调用签名（因为调用顺序是在运行时确定的，也因为该顺序要适应类层级结构的更改，还因为该顺序可能包含在运行时之前未知的兄弟类）。 类或方法的 __mro__ 属性列出了 getattr() 和 super() 所共同使用的方法解析顺序（MRO）。该属性是动态的，可以在任何继承层级结构发生更新的时候被改变。\n除了方法查找之外，super() 也可用于属性查找。一个可能的应用场合是在上级或同级类中调用描述器。\n请注意 super() 是作为显式加点属性查找的绑定过程的一部分来实现的，例如 super().__getitem__(name)。它做到这一点是通过实现自己的 __getattribute__() 方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。\n还要注意的是，除了零个参数的形式以外，super() 并不限于在方法内部使用。两个参数的形式明确指定参数并进行相应的引用。零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。\n方法调用委托给父类：\ntype(super) type\rclass A: def add(self, x): y = x + x print(y) class B(A): def add(self, x): super().add(x) # super() 等价于 super(B,self) b = B() b.add(5) 10\r初始化委托给父类：\nclass A: def __init__(self): self.a = '父类A' print ('A') def print_msg(self,a): print (f'{a}来自A') class B(A): def __init__(self): # super(B, self) 可写为 super() super(B, self).__init__() print ('B') def print_msg(self,b): super().print_msg(b) print (f'{b}来自B') print (self.a) b = B() b.print_msg('HelloWorld') A\rB\rHelloWorld来自A\rHelloWorld来自B\r父类A\r",
    "description": "",
    "tags": null,
    "title": "super 调用委托给父类或兄弟类",
    "uri": "/python/11_built-in_function/61_super/"
  },
  {
    "content": "内置函数（类）tuple，Python 官方文档描述如下：\nhelp(tuple) Help on class tuple in module builtins:\rclass tuple(object)\r| tuple(iterable=(), /)\r| | Built-in immutable sequence.\r| | If no argument is given, the constructor returns an empty tuple.\r| If iterable is specified the tuple is initialized from iterable's items.\r| | If the argument is a tuple, the return value is the same object.\r| 将可迭代对象转换为元组。可迭代对象为空或不传参数，返回空元组。\ntype(tuple) type\rtuple('') ()\rtuple('123') ('1', '2', '3')\r",
    "description": "",
    "tags": null,
    "title": "tuple 创建元组",
    "uri": "/python/11_built-in_function/62_tuple/"
  },
  {
    "content": "内置函数（类）type，Python 官方文档描述如下：\nhelp(type) Help on class type in module builtins:\rclass type(object)\r| type(object_or_name, bases, dict)\r| type(object) -\u003e the object's type\r| type(name, bases, dict) -\u003e a new type\r| 传入一个参数时，返回对象的类型。推荐使用 isinstance() 内置函数来检测对象的类型，因为它会考虑子类的情况。\n传入三个参数时，返回一个新的 type 对象。这在本质上是 class 语句的一种动态形式。name 参数是字符串即类名并且会成为 __name__ 属性；bases 元组列出基类并且会成为 __bases__ 属性；而 dict 字典为包含类主体定义的命名空间并且会被复制到一个标准字典成为 __dict__ 属性。\ntype(type) type\rtype(int), type(object) (type, type)\risinstance(int, object) True\rclass A: a = 1 A.__name__, A.__bases__, A.__dict__ ('A',\r(object,),\rmappingproxy({'__module__': '__main__',\r'a': 1,\r'__dict__': \u003cattribute '__dict__' of 'A' objects\u003e,\r'__weakref__': \u003cattribute '__weakref__' of 'A' objects\u003e,\r'__doc__': None}))\rA = type('A', (object,), dict(a=1)) A.__name__, A.__bases__, A.__dict__ ('A',\r(object,),\rmappingproxy({'a': 1,\r'__module__': '__main__',\r'__dict__': \u003cattribute '__dict__' of 'A' objects\u003e,\r'__weakref__': \u003cattribute '__weakref__' of 'A' objects\u003e,\r'__doc__': None}))\r",
    "description": "",
    "tags": null,
    "title": "type 判断类型或创建类",
    "uri": "/python/11_built-in_function/63_type/"
  },
  {
    "content": "内置函数 vars()，Python 官方文档描述如下：\nhelp(vars) Help on built-in function vars in module builtins:\rvars(...)\rvars([object]) -\u003e dictionary\rWithout arguments, equivalent to locals().\rWith an argument, equivalent to object.__dict__.\r返回模块、类、实例或任何其它具有 __dict__ 属性的对象的 __dict__ 属性。\n模块和实例这样的对象具有可更新的 __dict__ 属性；但是，其它对象的 __dict__ 属性可能会设为限制写入（例如，类会使用types.MappingProxyType 来防止直接更新字典）。\n不带参数时，vars() 的行为类似 locals()。请注意，locals 字典仅对于读取起作用，因为对 locals 字典的更新会被忽略。\n如果指定了一个对象但它没有 __dict__ 属性则会引发TypeError 异常。\nvars() {'__name__': '__main__',\r'__doc__': 'Automatically created module for IPython interactive environment',\r'__package__': None,\r'__loader__': None,\r'__spec__': None,\r'__builtin__': \u003cmodule 'builtins' (built-in)\u003e,\r'__builtins__': \u003cmodule 'builtins' (built-in)\u003e,\r'_ih': ['', \"get_ipython().run_line_magic('pinfo', 'vars')\", 'vars()'],\r'_oh': {},\r'_dh': ['E:\\\\xue\\\\脚本\\\\kp_book\\\\11_built-in_function'],\r'In': ['', \"get_ipython().run_line_magic('pinfo', 'vars')\", 'vars()'],\r'Out': {},\r'get_ipython': \u003cbound method InteractiveShell.get_ipython of \u003cipykernel.zmqshell.ZMQInteractiveShell object at 0x00000189A6512310\u003e\u003e,\r'exit': \u003cIPython.core.autocall.ZMQExitAutocall at 0x189a65b32e0\u003e,\r'quit': \u003cIPython.core.autocall.ZMQExitAutocall at 0x189a65b32e0\u003e,\r'_': '',\r'__': '',\r'___': '',\r'_i': 'vars?',\r'_ii': '',\r'_iii': '',\r'_i1': 'vars?',\r'_i2': 'vars()'}\rdef f():pass vars(f) {}\rf.__dict__['a'] = 1 f.a 1\rvars(1) ---------------------------------------------------------------------------\rTypeError Traceback (most recent call last)\r\u003cipython-input-9-3391faf83557\u003e in \u003cmodule\u003e\r----\u003e 1 vars(1)\rTypeError: vars() argument must have __dict__ attribute\r",
    "description": "",
    "tags": null,
    "title": "vars() 返回对象的变量字典",
    "uri": "/python/11_built-in_function/64_vars/"
  },
  {
    "content": "内置函数（类）zip，Python 官方文档描述如下：\nhelp(zip) Help on class zip in module builtins:\rclass zip(object)\r| zip(iter1 [,iter2 [...]]) --\u003e zip object\r| | Return a zip object whose .__next__() method returns a tuple where\r| the i-th element comes from the i-th iterable argument. The .__next__()\r| method continues until the shortest iterable in the argument sequence\r| is exhausted and then it raises StopIteration.\r| | Methods defined here:\r| | __getattribute__(self, name, /)\r| Return getattr(self, name).\r| | __iter__(self, /)\r| Implement iter(self).\r| | __next__(self, /)\r| Implement next(self).\r| | __reduce__(...)\r| Return state information for pickling.\r| | ----------------------------------------------------------------------\r| Static methods defined here:\r| | __new__(*args, **kwargs) from builtins.type\r| Create and return a new object. See help(type) for accurate signature.\r创建一个聚合了来自每个可迭代对象中的元素的迭代器。\n返回一个元组的迭代器，其中的第 i 个元组包含来自每个可迭代对象的第 i 个元素。\n当所输入可迭代对象中最短的一个被耗尽时，迭代器将停止迭代。\n当只有一个可迭代对象参数时，它将返回一个单元组的迭代器。\n不带参数时，它将返回一个空迭代器。\ntype(zip) type\rzip() \u003czip at 0x2ac600edac8\u003e\rlist(zip('123')) [('1',), ('2',), ('3',)]\rlist(zip('123',{3,2,1})) [('1', 1), ('2', 2), ('3', 3)]\rlist(zip([3,2,1],(1,2,3,4),'12')) [(3, 1, '1'), (2, 2, '2')]\rlist(zip(*['abc','123'])) [('a', '1'), ('b', '2'), ('c', '3')]\r",
    "description": "",
    "tags": null,
    "title": "zip 重组可迭代对象",
    "uri": "/python/11_built-in_function/65_zip/"
  },
  {
    "content": "公众号:\n视频号:\n微信号:\n抖音:\n快手:\n小红书:\nB 站:\n",
    "description": "",
    "tags": null,
    "title": "关注我",
    "uri": "/about/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/"
  }
]
